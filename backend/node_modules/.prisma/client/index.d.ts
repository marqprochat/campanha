
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model TenantQuota
 * 
 */
export type TenantQuota = $Result.DefaultSelection<Prisma.$TenantQuotaPayload>
/**
 * Model TenantSettings
 * 
 */
export type TenantSettings = $Result.DefaultSelection<Prisma.$TenantSettingsPayload>
/**
 * Model UserTenant
 * 
 */
export type UserTenant = $Result.DefaultSelection<Prisma.$UserTenantPayload>
/**
 * Model GlobalSettings
 * 
 */
export type GlobalSettings = $Result.DefaultSelection<Prisma.$GlobalSettingsPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model WhatsAppSession
 * 
 */
export type WhatsAppSession = $Result.DefaultSelection<Prisma.$WhatsAppSessionPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignMessage
 * 
 */
export type CampaignMessage = $Result.DefaultSelection<Prisma.$CampaignMessagePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model UserNotification
 * 
 */
export type UserNotification = $Result.DefaultSelection<Prisma.$UserNotificationPayload>
/**
 * Model MessageTemplate
 * 
 */
export type MessageTemplate = $Result.DefaultSelection<Prisma.$MessageTemplatePayload>
/**
 * Model AutomationFlow
 * 
 */
export type AutomationFlow = $Result.DefaultSelection<Prisma.$AutomationFlowPayload>
/**
 * Model AutomationExecution
 * 
 */
export type AutomationExecution = $Result.DefaultSelection<Prisma.$AutomationExecutionPayload>
/**
 * Model Integration
 * 
 */
export type Integration = $Result.DefaultSelection<Prisma.$IntegrationPayload>
/**
 * Model IntegrationSync
 * 
 */
export type IntegrationSync = $Result.DefaultSelection<Prisma.$IntegrationSyncPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AlertType: {
  QUOTA_WARNING: 'QUOTA_WARNING',
  QUOTA_EXCEEDED: 'QUOTA_EXCEEDED',
  SYSTEM_ERROR: 'SYSTEM_ERROR',
  TENANT_INACTIVE: 'TENANT_INACTIVE',
  SESSION_FAILED: 'SESSION_FAILED',
  CAMPAIGN_FAILED: 'CAMPAIGN_FAILED',
  DATABASE_ERROR: 'DATABASE_ERROR',
  API_ERROR: 'API_ERROR',
  BACKUP_FAILED: 'BACKUP_FAILED',
  SECURITY_ALERT: 'SECURITY_ALERT'
};

export type AlertType = (typeof AlertType)[keyof typeof AlertType]


export const AlertSeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type AlertSeverity = (typeof AlertSeverity)[keyof typeof AlertSeverity]


export const NotificationMethod: {
  IN_APP: 'IN_APP',
  EMAIL: 'EMAIL',
  WEBHOOK: 'WEBHOOK'
};

export type NotificationMethod = (typeof NotificationMethod)[keyof typeof NotificationMethod]


export const UserNotificationType: {
  INFO: 'INFO',
  SUCCESS: 'SUCCESS',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
  CAMPAIGN: 'CAMPAIGN',
  BACKUP: 'BACKUP',
  SYSTEM: 'SYSTEM'
};

export type UserNotificationType = (typeof UserNotificationType)[keyof typeof UserNotificationType]


export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  DOCUMENT: 'DOCUMENT',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const IntegrationType: {
  WEBHOOK: 'WEBHOOK',
  ZAPIER: 'ZAPIER',
  CRM: 'CRM',
  ERP: 'ERP',
  ECOMMERCE: 'ECOMMERCE',
  EMAIL: 'EMAIL',
  CALENDAR: 'CALENDAR',
  STORAGE: 'STORAGE',
  ANALYTICS: 'ANALYTICS',
  CUSTOM: 'CUSTOM'
};

export type IntegrationType = (typeof IntegrationType)[keyof typeof IntegrationType]

}

export type AlertType = $Enums.AlertType

export const AlertType: typeof $Enums.AlertType

export type AlertSeverity = $Enums.AlertSeverity

export const AlertSeverity: typeof $Enums.AlertSeverity

export type NotificationMethod = $Enums.NotificationMethod

export const NotificationMethod: typeof $Enums.NotificationMethod

export type UserNotificationType = $Enums.UserNotificationType

export const UserNotificationType: typeof $Enums.UserNotificationType

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type IntegrationType = $Enums.IntegrationType

export const IntegrationType: typeof $Enums.IntegrationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.tenantQuota`: Exposes CRUD operations for the **TenantQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantQuotas
    * const tenantQuotas = await prisma.tenantQuota.findMany()
    * ```
    */
  get tenantQuota(): Prisma.TenantQuotaDelegate<ExtArgs>;

  /**
   * `prisma.tenantSettings`: Exposes CRUD operations for the **TenantSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantSettings
    * const tenantSettings = await prisma.tenantSettings.findMany()
    * ```
    */
  get tenantSettings(): Prisma.TenantSettingsDelegate<ExtArgs>;

  /**
   * `prisma.userTenant`: Exposes CRUD operations for the **UserTenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTenants
    * const userTenants = await prisma.userTenant.findMany()
    * ```
    */
  get userTenant(): Prisma.UserTenantDelegate<ExtArgs>;

  /**
   * `prisma.globalSettings`: Exposes CRUD operations for the **GlobalSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GlobalSettings
    * const globalSettings = await prisma.globalSettings.findMany()
    * ```
    */
  get globalSettings(): Prisma.GlobalSettingsDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.whatsAppSession`: Exposes CRUD operations for the **WhatsAppSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppSessions
    * const whatsAppSessions = await prisma.whatsAppSession.findMany()
    * ```
    */
  get whatsAppSession(): Prisma.WhatsAppSessionDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.campaignMessage`: Exposes CRUD operations for the **CampaignMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignMessages
    * const campaignMessages = await prisma.campaignMessage.findMany()
    * ```
    */
  get campaignMessage(): Prisma.CampaignMessageDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.userNotification`: Exposes CRUD operations for the **UserNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNotifications
    * const userNotifications = await prisma.userNotification.findMany()
    * ```
    */
  get userNotification(): Prisma.UserNotificationDelegate<ExtArgs>;

  /**
   * `prisma.messageTemplate`: Exposes CRUD operations for the **MessageTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageTemplates
    * const messageTemplates = await prisma.messageTemplate.findMany()
    * ```
    */
  get messageTemplate(): Prisma.MessageTemplateDelegate<ExtArgs>;

  /**
   * `prisma.automationFlow`: Exposes CRUD operations for the **AutomationFlow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationFlows
    * const automationFlows = await prisma.automationFlow.findMany()
    * ```
    */
  get automationFlow(): Prisma.AutomationFlowDelegate<ExtArgs>;

  /**
   * `prisma.automationExecution`: Exposes CRUD operations for the **AutomationExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationExecutions
    * const automationExecutions = await prisma.automationExecution.findMany()
    * ```
    */
  get automationExecution(): Prisma.AutomationExecutionDelegate<ExtArgs>;

  /**
   * `prisma.integration`: Exposes CRUD operations for the **Integration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integration.findMany()
    * ```
    */
  get integration(): Prisma.IntegrationDelegate<ExtArgs>;

  /**
   * `prisma.integrationSync`: Exposes CRUD operations for the **IntegrationSync** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntegrationSyncs
    * const integrationSyncs = await prisma.integrationSync.findMany()
    * ```
    */
  get integrationSync(): Prisma.IntegrationSyncDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    TenantQuota: 'TenantQuota',
    TenantSettings: 'TenantSettings',
    UserTenant: 'UserTenant',
    GlobalSettings: 'GlobalSettings',
    Contact: 'Contact',
    Category: 'Category',
    WhatsAppSession: 'WhatsAppSession',
    Campaign: 'Campaign',
    CampaignMessage: 'CampaignMessage',
    User: 'User',
    Alert: 'Alert',
    Notification: 'Notification',
    UserNotification: 'UserNotification',
    MessageTemplate: 'MessageTemplate',
    AutomationFlow: 'AutomationFlow',
    AutomationExecution: 'AutomationExecution',
    Integration: 'Integration',
    IntegrationSync: 'IntegrationSync',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenant" | "tenantQuota" | "tenantSettings" | "userTenant" | "globalSettings" | "contact" | "category" | "whatsAppSession" | "campaign" | "campaignMessage" | "user" | "alert" | "notification" | "userNotification" | "messageTemplate" | "automationFlow" | "automationExecution" | "integration" | "integrationSync" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      TenantQuota: {
        payload: Prisma.$TenantQuotaPayload<ExtArgs>
        fields: Prisma.TenantQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantQuotaPayload>
          }
          findFirst: {
            args: Prisma.TenantQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantQuotaPayload>
          }
          findMany: {
            args: Prisma.TenantQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantQuotaPayload>[]
          }
          create: {
            args: Prisma.TenantQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantQuotaPayload>
          }
          createMany: {
            args: Prisma.TenantQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantQuotaPayload>[]
          }
          delete: {
            args: Prisma.TenantQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantQuotaPayload>
          }
          update: {
            args: Prisma.TenantQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantQuotaPayload>
          }
          deleteMany: {
            args: Prisma.TenantQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantQuotaPayload>
          }
          aggregate: {
            args: Prisma.TenantQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantQuota>
          }
          groupBy: {
            args: Prisma.TenantQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<TenantQuotaCountAggregateOutputType> | number
          }
        }
      }
      TenantSettings: {
        payload: Prisma.$TenantSettingsPayload<ExtArgs>
        fields: Prisma.TenantSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          findFirst: {
            args: Prisma.TenantSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          findMany: {
            args: Prisma.TenantSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>[]
          }
          create: {
            args: Prisma.TenantSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          createMany: {
            args: Prisma.TenantSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>[]
          }
          delete: {
            args: Prisma.TenantSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          update: {
            args: Prisma.TenantSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          deleteMany: {
            args: Prisma.TenantSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          aggregate: {
            args: Prisma.TenantSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantSettings>
          }
          groupBy: {
            args: Prisma.TenantSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<TenantSettingsCountAggregateOutputType> | number
          }
        }
      }
      UserTenant: {
        payload: Prisma.$UserTenantPayload<ExtArgs>
        fields: Prisma.UserTenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantPayload>
          }
          findFirst: {
            args: Prisma.UserTenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantPayload>
          }
          findMany: {
            args: Prisma.UserTenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantPayload>[]
          }
          create: {
            args: Prisma.UserTenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantPayload>
          }
          createMany: {
            args: Prisma.UserTenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantPayload>[]
          }
          delete: {
            args: Prisma.UserTenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantPayload>
          }
          update: {
            args: Prisma.UserTenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantPayload>
          }
          deleteMany: {
            args: Prisma.UserTenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserTenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantPayload>
          }
          aggregate: {
            args: Prisma.UserTenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTenant>
          }
          groupBy: {
            args: Prisma.UserTenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTenantCountArgs<ExtArgs>
            result: $Utils.Optional<UserTenantCountAggregateOutputType> | number
          }
        }
      }
      GlobalSettings: {
        payload: Prisma.$GlobalSettingsPayload<ExtArgs>
        fields: Prisma.GlobalSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlobalSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlobalSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>
          }
          findFirst: {
            args: Prisma.GlobalSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlobalSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>
          }
          findMany: {
            args: Prisma.GlobalSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>[]
          }
          create: {
            args: Prisma.GlobalSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>
          }
          createMany: {
            args: Prisma.GlobalSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GlobalSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>[]
          }
          delete: {
            args: Prisma.GlobalSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>
          }
          update: {
            args: Prisma.GlobalSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>
          }
          deleteMany: {
            args: Prisma.GlobalSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GlobalSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GlobalSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>
          }
          aggregate: {
            args: Prisma.GlobalSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGlobalSettings>
          }
          groupBy: {
            args: Prisma.GlobalSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GlobalSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlobalSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<GlobalSettingsCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppSession: {
        payload: Prisma.$WhatsAppSessionPayload<ExtArgs>
        fields: Prisma.WhatsAppSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          findMany: {
            args: Prisma.WhatsAppSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>[]
          }
          create: {
            args: Prisma.WhatsAppSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          createMany: {
            args: Prisma.WhatsAppSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          update: {
            args: Prisma.WhatsAppSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WhatsAppSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppSession>
          }
          groupBy: {
            args: Prisma.WhatsAppSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppSessionCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppSessionCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignMessage: {
        payload: Prisma.$CampaignMessagePayload<ExtArgs>
        fields: Prisma.CampaignMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          findFirst: {
            args: Prisma.CampaignMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          findMany: {
            args: Prisma.CampaignMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>[]
          }
          create: {
            args: Prisma.CampaignMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          createMany: {
            args: Prisma.CampaignMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>[]
          }
          delete: {
            args: Prisma.CampaignMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          update: {
            args: Prisma.CampaignMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          deleteMany: {
            args: Prisma.CampaignMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          aggregate: {
            args: Prisma.CampaignMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignMessage>
          }
          groupBy: {
            args: Prisma.CampaignMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignMessageCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignMessageCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      UserNotification: {
        payload: Prisma.$UserNotificationPayload<ExtArgs>
        fields: Prisma.UserNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>
          }
          findFirst: {
            args: Prisma.UserNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>
          }
          findMany: {
            args: Prisma.UserNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>[]
          }
          create: {
            args: Prisma.UserNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>
          }
          createMany: {
            args: Prisma.UserNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>[]
          }
          delete: {
            args: Prisma.UserNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>
          }
          update: {
            args: Prisma.UserNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>
          }
          deleteMany: {
            args: Prisma.UserNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>
          }
          aggregate: {
            args: Prisma.UserNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserNotification>
          }
          groupBy: {
            args: Prisma.UserNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationCountAggregateOutputType> | number
          }
        }
      }
      MessageTemplate: {
        payload: Prisma.$MessageTemplatePayload<ExtArgs>
        fields: Prisma.MessageTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          findFirst: {
            args: Prisma.MessageTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          findMany: {
            args: Prisma.MessageTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          create: {
            args: Prisma.MessageTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          createMany: {
            args: Prisma.MessageTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          delete: {
            args: Prisma.MessageTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          update: {
            args: Prisma.MessageTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          deleteMany: {
            args: Prisma.MessageTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          aggregate: {
            args: Prisma.MessageTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageTemplate>
          }
          groupBy: {
            args: Prisma.MessageTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplateCountAggregateOutputType> | number
          }
        }
      }
      AutomationFlow: {
        payload: Prisma.$AutomationFlowPayload<ExtArgs>
        fields: Prisma.AutomationFlowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationFlowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationFlowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationFlowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationFlowPayload>
          }
          findFirst: {
            args: Prisma.AutomationFlowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationFlowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationFlowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationFlowPayload>
          }
          findMany: {
            args: Prisma.AutomationFlowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationFlowPayload>[]
          }
          create: {
            args: Prisma.AutomationFlowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationFlowPayload>
          }
          createMany: {
            args: Prisma.AutomationFlowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationFlowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationFlowPayload>[]
          }
          delete: {
            args: Prisma.AutomationFlowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationFlowPayload>
          }
          update: {
            args: Prisma.AutomationFlowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationFlowPayload>
          }
          deleteMany: {
            args: Prisma.AutomationFlowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationFlowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationFlowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationFlowPayload>
          }
          aggregate: {
            args: Prisma.AutomationFlowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationFlow>
          }
          groupBy: {
            args: Prisma.AutomationFlowGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationFlowGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationFlowCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationFlowCountAggregateOutputType> | number
          }
        }
      }
      AutomationExecution: {
        payload: Prisma.$AutomationExecutionPayload<ExtArgs>
        fields: Prisma.AutomationExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          findFirst: {
            args: Prisma.AutomationExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          findMany: {
            args: Prisma.AutomationExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>[]
          }
          create: {
            args: Prisma.AutomationExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          createMany: {
            args: Prisma.AutomationExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>[]
          }
          delete: {
            args: Prisma.AutomationExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          update: {
            args: Prisma.AutomationExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          deleteMany: {
            args: Prisma.AutomationExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          aggregate: {
            args: Prisma.AutomationExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationExecution>
          }
          groupBy: {
            args: Prisma.AutomationExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationExecutionCountAggregateOutputType> | number
          }
        }
      }
      Integration: {
        payload: Prisma.$IntegrationPayload<ExtArgs>
        fields: Prisma.IntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findFirst: {
            args: Prisma.IntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findMany: {
            args: Prisma.IntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          create: {
            args: Prisma.IntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          createMany: {
            args: Prisma.IntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          delete: {
            args: Prisma.IntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          update: {
            args: Prisma.IntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          aggregate: {
            args: Prisma.IntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration>
          }
          groupBy: {
            args: Prisma.IntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCountAggregateOutputType> | number
          }
        }
      }
      IntegrationSync: {
        payload: Prisma.$IntegrationSyncPayload<ExtArgs>
        fields: Prisma.IntegrationSyncFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationSyncFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSyncPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationSyncFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSyncPayload>
          }
          findFirst: {
            args: Prisma.IntegrationSyncFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSyncPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationSyncFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSyncPayload>
          }
          findMany: {
            args: Prisma.IntegrationSyncFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSyncPayload>[]
          }
          create: {
            args: Prisma.IntegrationSyncCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSyncPayload>
          }
          createMany: {
            args: Prisma.IntegrationSyncCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationSyncCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSyncPayload>[]
          }
          delete: {
            args: Prisma.IntegrationSyncDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSyncPayload>
          }
          update: {
            args: Prisma.IntegrationSyncUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSyncPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationSyncDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationSyncUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegrationSyncUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSyncPayload>
          }
          aggregate: {
            args: Prisma.IntegrationSyncAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegrationSync>
          }
          groupBy: {
            args: Prisma.IntegrationSyncGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationSyncGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationSyncCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationSyncCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    userTenants: number
    contacts: number
    categories: number
    campaigns: number
    campaignMessages: number
    whatsappSessions: number
    alerts: number
    messageTemplates: number
    automationFlows: number
    integrations: number
    auditLogs: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    userTenants?: boolean | TenantCountOutputTypeCountUserTenantsArgs
    contacts?: boolean | TenantCountOutputTypeCountContactsArgs
    categories?: boolean | TenantCountOutputTypeCountCategoriesArgs
    campaigns?: boolean | TenantCountOutputTypeCountCampaignsArgs
    campaignMessages?: boolean | TenantCountOutputTypeCountCampaignMessagesArgs
    whatsappSessions?: boolean | TenantCountOutputTypeCountWhatsappSessionsArgs
    alerts?: boolean | TenantCountOutputTypeCountAlertsArgs
    messageTemplates?: boolean | TenantCountOutputTypeCountMessageTemplatesArgs
    automationFlows?: boolean | TenantCountOutputTypeCountAutomationFlowsArgs
    integrations?: boolean | TenantCountOutputTypeCountIntegrationsArgs
    auditLogs?: boolean | TenantCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUserTenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTenantWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCampaignMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMessageWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWhatsappSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppSessionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountMessageTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplateWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAutomationFlowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationFlowWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    contacts: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | CategoryCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * Count Type WhatsAppSessionCountOutputType
   */

  export type WhatsAppSessionCountOutputType = {
    campaigns: number
  }

  export type WhatsAppSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | WhatsAppSessionCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * WhatsAppSessionCountOutputType without action
   */
  export type WhatsAppSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSessionCountOutputType
     */
    select?: WhatsAppSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsAppSessionCountOutputType without action
   */
  export type WhatsAppSessionCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    messages: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | CampaignCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMessageWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tenants: number
    alerts: number
    notifications: number
    userNotifications: number
    createdTemplates: number
    createdFlows: number
    createdIntegrations: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenants?: boolean | UserCountOutputTypeCountTenantsArgs
    alerts?: boolean | UserCountOutputTypeCountAlertsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    userNotifications?: boolean | UserCountOutputTypeCountUserNotificationsArgs
    createdTemplates?: boolean | UserCountOutputTypeCountCreatedTemplatesArgs
    createdFlows?: boolean | UserCountOutputTypeCountCreatedFlowsArgs
    createdIntegrations?: boolean | UserCountOutputTypeCountCreatedIntegrationsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTenantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedFlowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationFlowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type AlertCountOutputType
   */

  export type AlertCountOutputType = {
    notifications: number
  }

  export type AlertCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | AlertCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCountOutputType
     */
    select?: AlertCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type AutomationFlowCountOutputType
   */

  export type AutomationFlowCountOutputType = {
    executions: number
  }

  export type AutomationFlowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | AutomationFlowCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * AutomationFlowCountOutputType without action
   */
  export type AutomationFlowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlowCountOutputType
     */
    select?: AutomationFlowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutomationFlowCountOutputType without action
   */
  export type AutomationFlowCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationExecutionWhereInput
  }


  /**
   * Count Type IntegrationCountOutputType
   */

  export type IntegrationCountOutputType = {
    syncLogs: number
  }

  export type IntegrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syncLogs?: boolean | IntegrationCountOutputTypeCountSyncLogsArgs
  }

  // Custom InputTypes
  /**
   * IntegrationCountOutputType without action
   */
  export type IntegrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCountOutputType
     */
    select?: IntegrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IntegrationCountOutputType without action
   */
  export type IntegrationCountOutputTypeCountSyncLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationSyncWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    slug: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    userTenants?: boolean | Tenant$userTenantsArgs<ExtArgs>
    contacts?: boolean | Tenant$contactsArgs<ExtArgs>
    categories?: boolean | Tenant$categoriesArgs<ExtArgs>
    campaigns?: boolean | Tenant$campaignsArgs<ExtArgs>
    campaignMessages?: boolean | Tenant$campaignMessagesArgs<ExtArgs>
    whatsappSessions?: boolean | Tenant$whatsappSessionsArgs<ExtArgs>
    quotas?: boolean | Tenant$quotasArgs<ExtArgs>
    settings?: boolean | Tenant$settingsArgs<ExtArgs>
    alerts?: boolean | Tenant$alertsArgs<ExtArgs>
    messageTemplates?: boolean | Tenant$messageTemplatesArgs<ExtArgs>
    automationFlows?: boolean | Tenant$automationFlowsArgs<ExtArgs>
    integrations?: boolean | Tenant$integrationsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    userTenants?: boolean | Tenant$userTenantsArgs<ExtArgs>
    contacts?: boolean | Tenant$contactsArgs<ExtArgs>
    categories?: boolean | Tenant$categoriesArgs<ExtArgs>
    campaigns?: boolean | Tenant$campaignsArgs<ExtArgs>
    campaignMessages?: boolean | Tenant$campaignMessagesArgs<ExtArgs>
    whatsappSessions?: boolean | Tenant$whatsappSessionsArgs<ExtArgs>
    quotas?: boolean | Tenant$quotasArgs<ExtArgs>
    settings?: boolean | Tenant$settingsArgs<ExtArgs>
    alerts?: boolean | Tenant$alertsArgs<ExtArgs>
    messageTemplates?: boolean | Tenant$messageTemplatesArgs<ExtArgs>
    automationFlows?: boolean | Tenant$automationFlowsArgs<ExtArgs>
    integrations?: boolean | Tenant$integrationsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      userTenants: Prisma.$UserTenantPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      campaignMessages: Prisma.$CampaignMessagePayload<ExtArgs>[]
      whatsappSessions: Prisma.$WhatsAppSessionPayload<ExtArgs>[]
      quotas: Prisma.$TenantQuotaPayload<ExtArgs> | null
      settings: Prisma.$TenantSettingsPayload<ExtArgs> | null
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      messageTemplates: Prisma.$MessageTemplatePayload<ExtArgs>[]
      automationFlows: Prisma.$AutomationFlowPayload<ExtArgs>[]
      integrations: Prisma.$IntegrationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    userTenants<T extends Tenant$userTenantsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$userTenantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTenantPayload<ExtArgs>, T, "findMany"> | Null>
    contacts<T extends Tenant$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    categories<T extends Tenant$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany"> | Null>
    campaigns<T extends Tenant$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    campaignMessages<T extends Tenant$campaignMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$campaignMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findMany"> | Null>
    whatsappSessions<T extends Tenant$whatsappSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$whatsappSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findMany"> | Null>
    quotas<T extends Tenant$quotasArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$quotasArgs<ExtArgs>>): Prisma__TenantQuotaClient<$Result.GetResult<Prisma.$TenantQuotaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    settings<T extends Tenant$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$settingsArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    alerts<T extends Tenant$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    messageTemplates<T extends Tenant$messageTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$messageTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    automationFlows<T extends Tenant$automationFlowsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$automationFlowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "findMany"> | Null>
    integrations<T extends Tenant$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Tenant$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly slug: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly active: FieldRef<"Tenant", 'Boolean'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.userTenants
   */
  export type Tenant$userTenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantInclude<ExtArgs> | null
    where?: UserTenantWhereInput
    orderBy?: UserTenantOrderByWithRelationInput | UserTenantOrderByWithRelationInput[]
    cursor?: UserTenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTenantScalarFieldEnum | UserTenantScalarFieldEnum[]
  }

  /**
   * Tenant.contacts
   */
  export type Tenant$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Tenant.categories
   */
  export type Tenant$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Tenant.campaigns
   */
  export type Tenant$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Tenant.campaignMessages
   */
  export type Tenant$campaignMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    where?: CampaignMessageWhereInput
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    cursor?: CampaignMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * Tenant.whatsappSessions
   */
  export type Tenant$whatsappSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    where?: WhatsAppSessionWhereInput
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    cursor?: WhatsAppSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppSessionScalarFieldEnum | WhatsAppSessionScalarFieldEnum[]
  }

  /**
   * Tenant.quotas
   */
  export type Tenant$quotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantQuota
     */
    select?: TenantQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantQuotaInclude<ExtArgs> | null
    where?: TenantQuotaWhereInput
  }

  /**
   * Tenant.settings
   */
  export type Tenant$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    where?: TenantSettingsWhereInput
  }

  /**
   * Tenant.alerts
   */
  export type Tenant$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Tenant.messageTemplates
   */
  export type Tenant$messageTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    where?: MessageTemplateWhereInput
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    cursor?: MessageTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * Tenant.automationFlows
   */
  export type Tenant$automationFlowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowInclude<ExtArgs> | null
    where?: AutomationFlowWhereInput
    orderBy?: AutomationFlowOrderByWithRelationInput | AutomationFlowOrderByWithRelationInput[]
    cursor?: AutomationFlowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationFlowScalarFieldEnum | AutomationFlowScalarFieldEnum[]
  }

  /**
   * Tenant.integrations
   */
  export type Tenant$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    cursor?: IntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Tenant.auditLogs
   */
  export type Tenant$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model TenantQuota
   */

  export type AggregateTenantQuota = {
    _count: TenantQuotaCountAggregateOutputType | null
    _avg: TenantQuotaAvgAggregateOutputType | null
    _sum: TenantQuotaSumAggregateOutputType | null
    _min: TenantQuotaMinAggregateOutputType | null
    _max: TenantQuotaMaxAggregateOutputType | null
  }

  export type TenantQuotaAvgAggregateOutputType = {
    maxUsers: number | null
    maxContacts: number | null
    maxCampaigns: number | null
    maxConnections: number | null
  }

  export type TenantQuotaSumAggregateOutputType = {
    maxUsers: number | null
    maxContacts: number | null
    maxCampaigns: number | null
    maxConnections: number | null
  }

  export type TenantQuotaMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    maxUsers: number | null
    maxContacts: number | null
    maxCampaigns: number | null
    maxConnections: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantQuotaMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    maxUsers: number | null
    maxContacts: number | null
    maxCampaigns: number | null
    maxConnections: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantQuotaCountAggregateOutputType = {
    id: number
    tenantId: number
    maxUsers: number
    maxContacts: number
    maxCampaigns: number
    maxConnections: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantQuotaAvgAggregateInputType = {
    maxUsers?: true
    maxContacts?: true
    maxCampaigns?: true
    maxConnections?: true
  }

  export type TenantQuotaSumAggregateInputType = {
    maxUsers?: true
    maxContacts?: true
    maxCampaigns?: true
    maxConnections?: true
  }

  export type TenantQuotaMinAggregateInputType = {
    id?: true
    tenantId?: true
    maxUsers?: true
    maxContacts?: true
    maxCampaigns?: true
    maxConnections?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantQuotaMaxAggregateInputType = {
    id?: true
    tenantId?: true
    maxUsers?: true
    maxContacts?: true
    maxCampaigns?: true
    maxConnections?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantQuotaCountAggregateInputType = {
    id?: true
    tenantId?: true
    maxUsers?: true
    maxContacts?: true
    maxCampaigns?: true
    maxConnections?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantQuota to aggregate.
     */
    where?: TenantQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantQuotas to fetch.
     */
    orderBy?: TenantQuotaOrderByWithRelationInput | TenantQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantQuotas
    **/
    _count?: true | TenantQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantQuotaMaxAggregateInputType
  }

  export type GetTenantQuotaAggregateType<T extends TenantQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantQuota[P]>
      : GetScalarType<T[P], AggregateTenantQuota[P]>
  }




  export type TenantQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantQuotaWhereInput
    orderBy?: TenantQuotaOrderByWithAggregationInput | TenantQuotaOrderByWithAggregationInput[]
    by: TenantQuotaScalarFieldEnum[] | TenantQuotaScalarFieldEnum
    having?: TenantQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantQuotaCountAggregateInputType | true
    _avg?: TenantQuotaAvgAggregateInputType
    _sum?: TenantQuotaSumAggregateInputType
    _min?: TenantQuotaMinAggregateInputType
    _max?: TenantQuotaMaxAggregateInputType
  }

  export type TenantQuotaGroupByOutputType = {
    id: string
    tenantId: string
    maxUsers: number
    maxContacts: number
    maxCampaigns: number
    maxConnections: number
    createdAt: Date
    updatedAt: Date
    _count: TenantQuotaCountAggregateOutputType | null
    _avg: TenantQuotaAvgAggregateOutputType | null
    _sum: TenantQuotaSumAggregateOutputType | null
    _min: TenantQuotaMinAggregateOutputType | null
    _max: TenantQuotaMaxAggregateOutputType | null
  }

  type GetTenantQuotaGroupByPayload<T extends TenantQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], TenantQuotaGroupByOutputType[P]>
        }
      >
    >


  export type TenantQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    maxUsers?: boolean
    maxContacts?: boolean
    maxCampaigns?: boolean
    maxConnections?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantQuota"]>

  export type TenantQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    maxUsers?: boolean
    maxContacts?: boolean
    maxCampaigns?: boolean
    maxConnections?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantQuota"]>

  export type TenantQuotaSelectScalar = {
    id?: boolean
    tenantId?: boolean
    maxUsers?: boolean
    maxContacts?: boolean
    maxCampaigns?: boolean
    maxConnections?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantQuotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantQuotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantQuota"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      maxUsers: number
      maxContacts: number
      maxCampaigns: number
      maxConnections: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantQuota"]>
    composites: {}
  }

  type TenantQuotaGetPayload<S extends boolean | null | undefined | TenantQuotaDefaultArgs> = $Result.GetResult<Prisma.$TenantQuotaPayload, S>

  type TenantQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantQuotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantQuotaCountAggregateInputType | true
    }

  export interface TenantQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantQuota'], meta: { name: 'TenantQuota' } }
    /**
     * Find zero or one TenantQuota that matches the filter.
     * @param {TenantQuotaFindUniqueArgs} args - Arguments to find a TenantQuota
     * @example
     * // Get one TenantQuota
     * const tenantQuota = await prisma.tenantQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantQuotaFindUniqueArgs>(args: SelectSubset<T, TenantQuotaFindUniqueArgs<ExtArgs>>): Prisma__TenantQuotaClient<$Result.GetResult<Prisma.$TenantQuotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TenantQuota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantQuotaFindUniqueOrThrowArgs} args - Arguments to find a TenantQuota
     * @example
     * // Get one TenantQuota
     * const tenantQuota = await prisma.tenantQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantQuotaClient<$Result.GetResult<Prisma.$TenantQuotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TenantQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantQuotaFindFirstArgs} args - Arguments to find a TenantQuota
     * @example
     * // Get one TenantQuota
     * const tenantQuota = await prisma.tenantQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantQuotaFindFirstArgs>(args?: SelectSubset<T, TenantQuotaFindFirstArgs<ExtArgs>>): Prisma__TenantQuotaClient<$Result.GetResult<Prisma.$TenantQuotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TenantQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantQuotaFindFirstOrThrowArgs} args - Arguments to find a TenantQuota
     * @example
     * // Get one TenantQuota
     * const tenantQuota = await prisma.tenantQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantQuotaClient<$Result.GetResult<Prisma.$TenantQuotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TenantQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantQuotas
     * const tenantQuotas = await prisma.tenantQuota.findMany()
     * 
     * // Get first 10 TenantQuotas
     * const tenantQuotas = await prisma.tenantQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantQuotaWithIdOnly = await prisma.tenantQuota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantQuotaFindManyArgs>(args?: SelectSubset<T, TenantQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantQuotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TenantQuota.
     * @param {TenantQuotaCreateArgs} args - Arguments to create a TenantQuota.
     * @example
     * // Create one TenantQuota
     * const TenantQuota = await prisma.tenantQuota.create({
     *   data: {
     *     // ... data to create a TenantQuota
     *   }
     * })
     * 
     */
    create<T extends TenantQuotaCreateArgs>(args: SelectSubset<T, TenantQuotaCreateArgs<ExtArgs>>): Prisma__TenantQuotaClient<$Result.GetResult<Prisma.$TenantQuotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TenantQuotas.
     * @param {TenantQuotaCreateManyArgs} args - Arguments to create many TenantQuotas.
     * @example
     * // Create many TenantQuotas
     * const tenantQuota = await prisma.tenantQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantQuotaCreateManyArgs>(args?: SelectSubset<T, TenantQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantQuotas and returns the data saved in the database.
     * @param {TenantQuotaCreateManyAndReturnArgs} args - Arguments to create many TenantQuotas.
     * @example
     * // Create many TenantQuotas
     * const tenantQuota = await prisma.tenantQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantQuotas and only return the `id`
     * const tenantQuotaWithIdOnly = await prisma.tenantQuota.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantQuotaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TenantQuota.
     * @param {TenantQuotaDeleteArgs} args - Arguments to delete one TenantQuota.
     * @example
     * // Delete one TenantQuota
     * const TenantQuota = await prisma.tenantQuota.delete({
     *   where: {
     *     // ... filter to delete one TenantQuota
     *   }
     * })
     * 
     */
    delete<T extends TenantQuotaDeleteArgs>(args: SelectSubset<T, TenantQuotaDeleteArgs<ExtArgs>>): Prisma__TenantQuotaClient<$Result.GetResult<Prisma.$TenantQuotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TenantQuota.
     * @param {TenantQuotaUpdateArgs} args - Arguments to update one TenantQuota.
     * @example
     * // Update one TenantQuota
     * const tenantQuota = await prisma.tenantQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantQuotaUpdateArgs>(args: SelectSubset<T, TenantQuotaUpdateArgs<ExtArgs>>): Prisma__TenantQuotaClient<$Result.GetResult<Prisma.$TenantQuotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TenantQuotas.
     * @param {TenantQuotaDeleteManyArgs} args - Arguments to filter TenantQuotas to delete.
     * @example
     * // Delete a few TenantQuotas
     * const { count } = await prisma.tenantQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantQuotaDeleteManyArgs>(args?: SelectSubset<T, TenantQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantQuotas
     * const tenantQuota = await prisma.tenantQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantQuotaUpdateManyArgs>(args: SelectSubset<T, TenantQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TenantQuota.
     * @param {TenantQuotaUpsertArgs} args - Arguments to update or create a TenantQuota.
     * @example
     * // Update or create a TenantQuota
     * const tenantQuota = await prisma.tenantQuota.upsert({
     *   create: {
     *     // ... data to create a TenantQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantQuota we want to update
     *   }
     * })
     */
    upsert<T extends TenantQuotaUpsertArgs>(args: SelectSubset<T, TenantQuotaUpsertArgs<ExtArgs>>): Prisma__TenantQuotaClient<$Result.GetResult<Prisma.$TenantQuotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TenantQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantQuotaCountArgs} args - Arguments to filter TenantQuotas to count.
     * @example
     * // Count the number of TenantQuotas
     * const count = await prisma.tenantQuota.count({
     *   where: {
     *     // ... the filter for the TenantQuotas we want to count
     *   }
     * })
    **/
    count<T extends TenantQuotaCountArgs>(
      args?: Subset<T, TenantQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantQuotaAggregateArgs>(args: Subset<T, TenantQuotaAggregateArgs>): Prisma.PrismaPromise<GetTenantQuotaAggregateType<T>>

    /**
     * Group by TenantQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantQuotaGroupByArgs['orderBy'] }
        : { orderBy?: TenantQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantQuota model
   */
  readonly fields: TenantQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantQuota model
   */ 
  interface TenantQuotaFieldRefs {
    readonly id: FieldRef<"TenantQuota", 'String'>
    readonly tenantId: FieldRef<"TenantQuota", 'String'>
    readonly maxUsers: FieldRef<"TenantQuota", 'Int'>
    readonly maxContacts: FieldRef<"TenantQuota", 'Int'>
    readonly maxCampaigns: FieldRef<"TenantQuota", 'Int'>
    readonly maxConnections: FieldRef<"TenantQuota", 'Int'>
    readonly createdAt: FieldRef<"TenantQuota", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantQuota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantQuota findUnique
   */
  export type TenantQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantQuota
     */
    select?: TenantQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantQuotaInclude<ExtArgs> | null
    /**
     * Filter, which TenantQuota to fetch.
     */
    where: TenantQuotaWhereUniqueInput
  }

  /**
   * TenantQuota findUniqueOrThrow
   */
  export type TenantQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantQuota
     */
    select?: TenantQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantQuotaInclude<ExtArgs> | null
    /**
     * Filter, which TenantQuota to fetch.
     */
    where: TenantQuotaWhereUniqueInput
  }

  /**
   * TenantQuota findFirst
   */
  export type TenantQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantQuota
     */
    select?: TenantQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantQuotaInclude<ExtArgs> | null
    /**
     * Filter, which TenantQuota to fetch.
     */
    where?: TenantQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantQuotas to fetch.
     */
    orderBy?: TenantQuotaOrderByWithRelationInput | TenantQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantQuotas.
     */
    cursor?: TenantQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantQuotas.
     */
    distinct?: TenantQuotaScalarFieldEnum | TenantQuotaScalarFieldEnum[]
  }

  /**
   * TenantQuota findFirstOrThrow
   */
  export type TenantQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantQuota
     */
    select?: TenantQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantQuotaInclude<ExtArgs> | null
    /**
     * Filter, which TenantQuota to fetch.
     */
    where?: TenantQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantQuotas to fetch.
     */
    orderBy?: TenantQuotaOrderByWithRelationInput | TenantQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantQuotas.
     */
    cursor?: TenantQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantQuotas.
     */
    distinct?: TenantQuotaScalarFieldEnum | TenantQuotaScalarFieldEnum[]
  }

  /**
   * TenantQuota findMany
   */
  export type TenantQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantQuota
     */
    select?: TenantQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantQuotaInclude<ExtArgs> | null
    /**
     * Filter, which TenantQuotas to fetch.
     */
    where?: TenantQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantQuotas to fetch.
     */
    orderBy?: TenantQuotaOrderByWithRelationInput | TenantQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantQuotas.
     */
    cursor?: TenantQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantQuotas.
     */
    skip?: number
    distinct?: TenantQuotaScalarFieldEnum | TenantQuotaScalarFieldEnum[]
  }

  /**
   * TenantQuota create
   */
  export type TenantQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantQuota
     */
    select?: TenantQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantQuota.
     */
    data: XOR<TenantQuotaCreateInput, TenantQuotaUncheckedCreateInput>
  }

  /**
   * TenantQuota createMany
   */
  export type TenantQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantQuotas.
     */
    data: TenantQuotaCreateManyInput | TenantQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantQuota createManyAndReturn
   */
  export type TenantQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantQuota
     */
    select?: TenantQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TenantQuotas.
     */
    data: TenantQuotaCreateManyInput | TenantQuotaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantQuotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantQuota update
   */
  export type TenantQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantQuota
     */
    select?: TenantQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantQuota.
     */
    data: XOR<TenantQuotaUpdateInput, TenantQuotaUncheckedUpdateInput>
    /**
     * Choose, which TenantQuota to update.
     */
    where: TenantQuotaWhereUniqueInput
  }

  /**
   * TenantQuota updateMany
   */
  export type TenantQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantQuotas.
     */
    data: XOR<TenantQuotaUpdateManyMutationInput, TenantQuotaUncheckedUpdateManyInput>
    /**
     * Filter which TenantQuotas to update
     */
    where?: TenantQuotaWhereInput
  }

  /**
   * TenantQuota upsert
   */
  export type TenantQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantQuota
     */
    select?: TenantQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantQuota to update in case it exists.
     */
    where: TenantQuotaWhereUniqueInput
    /**
     * In case the TenantQuota found by the `where` argument doesn't exist, create a new TenantQuota with this data.
     */
    create: XOR<TenantQuotaCreateInput, TenantQuotaUncheckedCreateInput>
    /**
     * In case the TenantQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantQuotaUpdateInput, TenantQuotaUncheckedUpdateInput>
  }

  /**
   * TenantQuota delete
   */
  export type TenantQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantQuota
     */
    select?: TenantQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantQuotaInclude<ExtArgs> | null
    /**
     * Filter which TenantQuota to delete.
     */
    where: TenantQuotaWhereUniqueInput
  }

  /**
   * TenantQuota deleteMany
   */
  export type TenantQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantQuotas to delete
     */
    where?: TenantQuotaWhereInput
  }

  /**
   * TenantQuota without action
   */
  export type TenantQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantQuota
     */
    select?: TenantQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantQuotaInclude<ExtArgs> | null
  }


  /**
   * Model TenantSettings
   */

  export type AggregateTenantSettings = {
    _count: TenantSettingsCountAggregateOutputType | null
    _min: TenantSettingsMinAggregateOutputType | null
    _max: TenantSettingsMaxAggregateOutputType | null
  }

  export type TenantSettingsMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    openaiApiKey: string | null
    groqApiKey: string | null
    chatwootUrl: string | null
    chatwootAccountId: string | null
    chatwootApiToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantSettingsMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    openaiApiKey: string | null
    groqApiKey: string | null
    chatwootUrl: string | null
    chatwootAccountId: string | null
    chatwootApiToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantSettingsCountAggregateOutputType = {
    id: number
    tenantId: number
    openaiApiKey: number
    groqApiKey: number
    customBranding: number
    chatwootUrl: number
    chatwootAccountId: number
    chatwootApiToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantSettingsMinAggregateInputType = {
    id?: true
    tenantId?: true
    openaiApiKey?: true
    groqApiKey?: true
    chatwootUrl?: true
    chatwootAccountId?: true
    chatwootApiToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantSettingsMaxAggregateInputType = {
    id?: true
    tenantId?: true
    openaiApiKey?: true
    groqApiKey?: true
    chatwootUrl?: true
    chatwootAccountId?: true
    chatwootApiToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantSettingsCountAggregateInputType = {
    id?: true
    tenantId?: true
    openaiApiKey?: true
    groqApiKey?: true
    customBranding?: true
    chatwootUrl?: true
    chatwootAccountId?: true
    chatwootApiToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantSettings to aggregate.
     */
    where?: TenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSettings to fetch.
     */
    orderBy?: TenantSettingsOrderByWithRelationInput | TenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantSettings
    **/
    _count?: true | TenantSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantSettingsMaxAggregateInputType
  }

  export type GetTenantSettingsAggregateType<T extends TenantSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantSettings[P]>
      : GetScalarType<T[P], AggregateTenantSettings[P]>
  }




  export type TenantSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantSettingsWhereInput
    orderBy?: TenantSettingsOrderByWithAggregationInput | TenantSettingsOrderByWithAggregationInput[]
    by: TenantSettingsScalarFieldEnum[] | TenantSettingsScalarFieldEnum
    having?: TenantSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantSettingsCountAggregateInputType | true
    _min?: TenantSettingsMinAggregateInputType
    _max?: TenantSettingsMaxAggregateInputType
  }

  export type TenantSettingsGroupByOutputType = {
    id: string
    tenantId: string
    openaiApiKey: string | null
    groqApiKey: string | null
    customBranding: JsonValue | null
    chatwootUrl: string | null
    chatwootAccountId: string | null
    chatwootApiToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantSettingsCountAggregateOutputType | null
    _min: TenantSettingsMinAggregateOutputType | null
    _max: TenantSettingsMaxAggregateOutputType | null
  }

  type GetTenantSettingsGroupByPayload<T extends TenantSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], TenantSettingsGroupByOutputType[P]>
        }
      >
    >


  export type TenantSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    openaiApiKey?: boolean
    groqApiKey?: boolean
    customBranding?: boolean
    chatwootUrl?: boolean
    chatwootAccountId?: boolean
    chatwootApiToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantSettings"]>

  export type TenantSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    openaiApiKey?: boolean
    groqApiKey?: boolean
    customBranding?: boolean
    chatwootUrl?: boolean
    chatwootAccountId?: boolean
    chatwootApiToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantSettings"]>

  export type TenantSettingsSelectScalar = {
    id?: boolean
    tenantId?: boolean
    openaiApiKey?: boolean
    groqApiKey?: boolean
    customBranding?: boolean
    chatwootUrl?: boolean
    chatwootAccountId?: boolean
    chatwootApiToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantSettings"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      openaiApiKey: string | null
      groqApiKey: string | null
      customBranding: Prisma.JsonValue | null
      chatwootUrl: string | null
      chatwootAccountId: string | null
      chatwootApiToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantSettings"]>
    composites: {}
  }

  type TenantSettingsGetPayload<S extends boolean | null | undefined | TenantSettingsDefaultArgs> = $Result.GetResult<Prisma.$TenantSettingsPayload, S>

  type TenantSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantSettingsCountAggregateInputType | true
    }

  export interface TenantSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantSettings'], meta: { name: 'TenantSettings' } }
    /**
     * Find zero or one TenantSettings that matches the filter.
     * @param {TenantSettingsFindUniqueArgs} args - Arguments to find a TenantSettings
     * @example
     * // Get one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantSettingsFindUniqueArgs>(args: SelectSubset<T, TenantSettingsFindUniqueArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TenantSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantSettingsFindUniqueOrThrowArgs} args - Arguments to find a TenantSettings
     * @example
     * // Get one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TenantSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsFindFirstArgs} args - Arguments to find a TenantSettings
     * @example
     * // Get one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantSettingsFindFirstArgs>(args?: SelectSubset<T, TenantSettingsFindFirstArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TenantSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsFindFirstOrThrowArgs} args - Arguments to find a TenantSettings
     * @example
     * // Get one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TenantSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findMany()
     * 
     * // Get first 10 TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantSettingsWithIdOnly = await prisma.tenantSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantSettingsFindManyArgs>(args?: SelectSubset<T, TenantSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TenantSettings.
     * @param {TenantSettingsCreateArgs} args - Arguments to create a TenantSettings.
     * @example
     * // Create one TenantSettings
     * const TenantSettings = await prisma.tenantSettings.create({
     *   data: {
     *     // ... data to create a TenantSettings
     *   }
     * })
     * 
     */
    create<T extends TenantSettingsCreateArgs>(args: SelectSubset<T, TenantSettingsCreateArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TenantSettings.
     * @param {TenantSettingsCreateManyArgs} args - Arguments to create many TenantSettings.
     * @example
     * // Create many TenantSettings
     * const tenantSettings = await prisma.tenantSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantSettingsCreateManyArgs>(args?: SelectSubset<T, TenantSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantSettings and returns the data saved in the database.
     * @param {TenantSettingsCreateManyAndReturnArgs} args - Arguments to create many TenantSettings.
     * @example
     * // Create many TenantSettings
     * const tenantSettings = await prisma.tenantSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantSettings and only return the `id`
     * const tenantSettingsWithIdOnly = await prisma.tenantSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TenantSettings.
     * @param {TenantSettingsDeleteArgs} args - Arguments to delete one TenantSettings.
     * @example
     * // Delete one TenantSettings
     * const TenantSettings = await prisma.tenantSettings.delete({
     *   where: {
     *     // ... filter to delete one TenantSettings
     *   }
     * })
     * 
     */
    delete<T extends TenantSettingsDeleteArgs>(args: SelectSubset<T, TenantSettingsDeleteArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TenantSettings.
     * @param {TenantSettingsUpdateArgs} args - Arguments to update one TenantSettings.
     * @example
     * // Update one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantSettingsUpdateArgs>(args: SelectSubset<T, TenantSettingsUpdateArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TenantSettings.
     * @param {TenantSettingsDeleteManyArgs} args - Arguments to filter TenantSettings to delete.
     * @example
     * // Delete a few TenantSettings
     * const { count } = await prisma.tenantSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantSettingsDeleteManyArgs>(args?: SelectSubset<T, TenantSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantSettings
     * const tenantSettings = await prisma.tenantSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantSettingsUpdateManyArgs>(args: SelectSubset<T, TenantSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TenantSettings.
     * @param {TenantSettingsUpsertArgs} args - Arguments to update or create a TenantSettings.
     * @example
     * // Update or create a TenantSettings
     * const tenantSettings = await prisma.tenantSettings.upsert({
     *   create: {
     *     // ... data to create a TenantSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantSettings we want to update
     *   }
     * })
     */
    upsert<T extends TenantSettingsUpsertArgs>(args: SelectSubset<T, TenantSettingsUpsertArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsCountArgs} args - Arguments to filter TenantSettings to count.
     * @example
     * // Count the number of TenantSettings
     * const count = await prisma.tenantSettings.count({
     *   where: {
     *     // ... the filter for the TenantSettings we want to count
     *   }
     * })
    **/
    count<T extends TenantSettingsCountArgs>(
      args?: Subset<T, TenantSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantSettingsAggregateArgs>(args: Subset<T, TenantSettingsAggregateArgs>): Prisma.PrismaPromise<GetTenantSettingsAggregateType<T>>

    /**
     * Group by TenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantSettingsGroupByArgs['orderBy'] }
        : { orderBy?: TenantSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantSettings model
   */
  readonly fields: TenantSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantSettings model
   */ 
  interface TenantSettingsFieldRefs {
    readonly id: FieldRef<"TenantSettings", 'String'>
    readonly tenantId: FieldRef<"TenantSettings", 'String'>
    readonly openaiApiKey: FieldRef<"TenantSettings", 'String'>
    readonly groqApiKey: FieldRef<"TenantSettings", 'String'>
    readonly customBranding: FieldRef<"TenantSettings", 'Json'>
    readonly chatwootUrl: FieldRef<"TenantSettings", 'String'>
    readonly chatwootAccountId: FieldRef<"TenantSettings", 'String'>
    readonly chatwootApiToken: FieldRef<"TenantSettings", 'String'>
    readonly createdAt: FieldRef<"TenantSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantSettings findUnique
   */
  export type TenantSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where: TenantSettingsWhereUniqueInput
  }

  /**
   * TenantSettings findUniqueOrThrow
   */
  export type TenantSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where: TenantSettingsWhereUniqueInput
  }

  /**
   * TenantSettings findFirst
   */
  export type TenantSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where?: TenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSettings to fetch.
     */
    orderBy?: TenantSettingsOrderByWithRelationInput | TenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantSettings.
     */
    cursor?: TenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantSettings.
     */
    distinct?: TenantSettingsScalarFieldEnum | TenantSettingsScalarFieldEnum[]
  }

  /**
   * TenantSettings findFirstOrThrow
   */
  export type TenantSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where?: TenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSettings to fetch.
     */
    orderBy?: TenantSettingsOrderByWithRelationInput | TenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantSettings.
     */
    cursor?: TenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantSettings.
     */
    distinct?: TenantSettingsScalarFieldEnum | TenantSettingsScalarFieldEnum[]
  }

  /**
   * TenantSettings findMany
   */
  export type TenantSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where?: TenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSettings to fetch.
     */
    orderBy?: TenantSettingsOrderByWithRelationInput | TenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantSettings.
     */
    cursor?: TenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSettings.
     */
    skip?: number
    distinct?: TenantSettingsScalarFieldEnum | TenantSettingsScalarFieldEnum[]
  }

  /**
   * TenantSettings create
   */
  export type TenantSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantSettings.
     */
    data: XOR<TenantSettingsCreateInput, TenantSettingsUncheckedCreateInput>
  }

  /**
   * TenantSettings createMany
   */
  export type TenantSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantSettings.
     */
    data: TenantSettingsCreateManyInput | TenantSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantSettings createManyAndReturn
   */
  export type TenantSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TenantSettings.
     */
    data: TenantSettingsCreateManyInput | TenantSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantSettings update
   */
  export type TenantSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantSettings.
     */
    data: XOR<TenantSettingsUpdateInput, TenantSettingsUncheckedUpdateInput>
    /**
     * Choose, which TenantSettings to update.
     */
    where: TenantSettingsWhereUniqueInput
  }

  /**
   * TenantSettings updateMany
   */
  export type TenantSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantSettings.
     */
    data: XOR<TenantSettingsUpdateManyMutationInput, TenantSettingsUncheckedUpdateManyInput>
    /**
     * Filter which TenantSettings to update
     */
    where?: TenantSettingsWhereInput
  }

  /**
   * TenantSettings upsert
   */
  export type TenantSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantSettings to update in case it exists.
     */
    where: TenantSettingsWhereUniqueInput
    /**
     * In case the TenantSettings found by the `where` argument doesn't exist, create a new TenantSettings with this data.
     */
    create: XOR<TenantSettingsCreateInput, TenantSettingsUncheckedCreateInput>
    /**
     * In case the TenantSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantSettingsUpdateInput, TenantSettingsUncheckedUpdateInput>
  }

  /**
   * TenantSettings delete
   */
  export type TenantSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * Filter which TenantSettings to delete.
     */
    where: TenantSettingsWhereUniqueInput
  }

  /**
   * TenantSettings deleteMany
   */
  export type TenantSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantSettings to delete
     */
    where?: TenantSettingsWhereInput
  }

  /**
   * TenantSettings without action
   */
  export type TenantSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
  }


  /**
   * Model UserTenant
   */

  export type AggregateUserTenant = {
    _count: UserTenantCountAggregateOutputType | null
    _min: UserTenantMinAggregateOutputType | null
    _max: UserTenantMaxAggregateOutputType | null
  }

  export type UserTenantMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTenantMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTenantCountAggregateOutputType = {
    id: number
    userId: number
    tenantId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserTenantMinAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTenantMaxAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTenantCountAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserTenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTenant to aggregate.
     */
    where?: UserTenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTenants to fetch.
     */
    orderBy?: UserTenantOrderByWithRelationInput | UserTenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTenants
    **/
    _count?: true | UserTenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTenantMaxAggregateInputType
  }

  export type GetUserTenantAggregateType<T extends UserTenantAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTenant[P]>
      : GetScalarType<T[P], AggregateUserTenant[P]>
  }




  export type UserTenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTenantWhereInput
    orderBy?: UserTenantOrderByWithAggregationInput | UserTenantOrderByWithAggregationInput[]
    by: UserTenantScalarFieldEnum[] | UserTenantScalarFieldEnum
    having?: UserTenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTenantCountAggregateInputType | true
    _min?: UserTenantMinAggregateInputType
    _max?: UserTenantMaxAggregateInputType
  }

  export type UserTenantGroupByOutputType = {
    id: string
    userId: string
    tenantId: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserTenantCountAggregateOutputType | null
    _min: UserTenantMinAggregateOutputType | null
    _max: UserTenantMaxAggregateOutputType | null
  }

  type GetUserTenantGroupByPayload<T extends UserTenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTenantGroupByOutputType[P]>
            : GetScalarType<T[P], UserTenantGroupByOutputType[P]>
        }
      >
    >


  export type UserTenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTenant"]>

  export type UserTenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTenant"]>

  export type UserTenantSelectScalar = {
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserTenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserTenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserTenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTenant"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tenantId: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userTenant"]>
    composites: {}
  }

  type UserTenantGetPayload<S extends boolean | null | undefined | UserTenantDefaultArgs> = $Result.GetResult<Prisma.$UserTenantPayload, S>

  type UserTenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserTenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserTenantCountAggregateInputType | true
    }

  export interface UserTenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTenant'], meta: { name: 'UserTenant' } }
    /**
     * Find zero or one UserTenant that matches the filter.
     * @param {UserTenantFindUniqueArgs} args - Arguments to find a UserTenant
     * @example
     * // Get one UserTenant
     * const userTenant = await prisma.userTenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTenantFindUniqueArgs>(args: SelectSubset<T, UserTenantFindUniqueArgs<ExtArgs>>): Prisma__UserTenantClient<$Result.GetResult<Prisma.$UserTenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserTenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserTenantFindUniqueOrThrowArgs} args - Arguments to find a UserTenant
     * @example
     * // Get one UserTenant
     * const userTenant = await prisma.userTenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTenantFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTenantClient<$Result.GetResult<Prisma.$UserTenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserTenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantFindFirstArgs} args - Arguments to find a UserTenant
     * @example
     * // Get one UserTenant
     * const userTenant = await prisma.userTenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTenantFindFirstArgs>(args?: SelectSubset<T, UserTenantFindFirstArgs<ExtArgs>>): Prisma__UserTenantClient<$Result.GetResult<Prisma.$UserTenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserTenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantFindFirstOrThrowArgs} args - Arguments to find a UserTenant
     * @example
     * // Get one UserTenant
     * const userTenant = await prisma.userTenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTenantFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTenantClient<$Result.GetResult<Prisma.$UserTenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserTenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTenants
     * const userTenants = await prisma.userTenant.findMany()
     * 
     * // Get first 10 UserTenants
     * const userTenants = await prisma.userTenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTenantWithIdOnly = await prisma.userTenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTenantFindManyArgs>(args?: SelectSubset<T, UserTenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserTenant.
     * @param {UserTenantCreateArgs} args - Arguments to create a UserTenant.
     * @example
     * // Create one UserTenant
     * const UserTenant = await prisma.userTenant.create({
     *   data: {
     *     // ... data to create a UserTenant
     *   }
     * })
     * 
     */
    create<T extends UserTenantCreateArgs>(args: SelectSubset<T, UserTenantCreateArgs<ExtArgs>>): Prisma__UserTenantClient<$Result.GetResult<Prisma.$UserTenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserTenants.
     * @param {UserTenantCreateManyArgs} args - Arguments to create many UserTenants.
     * @example
     * // Create many UserTenants
     * const userTenant = await prisma.userTenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTenantCreateManyArgs>(args?: SelectSubset<T, UserTenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTenants and returns the data saved in the database.
     * @param {UserTenantCreateManyAndReturnArgs} args - Arguments to create many UserTenants.
     * @example
     * // Create many UserTenants
     * const userTenant = await prisma.userTenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTenants and only return the `id`
     * const userTenantWithIdOnly = await prisma.userTenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTenantCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserTenant.
     * @param {UserTenantDeleteArgs} args - Arguments to delete one UserTenant.
     * @example
     * // Delete one UserTenant
     * const UserTenant = await prisma.userTenant.delete({
     *   where: {
     *     // ... filter to delete one UserTenant
     *   }
     * })
     * 
     */
    delete<T extends UserTenantDeleteArgs>(args: SelectSubset<T, UserTenantDeleteArgs<ExtArgs>>): Prisma__UserTenantClient<$Result.GetResult<Prisma.$UserTenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserTenant.
     * @param {UserTenantUpdateArgs} args - Arguments to update one UserTenant.
     * @example
     * // Update one UserTenant
     * const userTenant = await prisma.userTenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTenantUpdateArgs>(args: SelectSubset<T, UserTenantUpdateArgs<ExtArgs>>): Prisma__UserTenantClient<$Result.GetResult<Prisma.$UserTenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserTenants.
     * @param {UserTenantDeleteManyArgs} args - Arguments to filter UserTenants to delete.
     * @example
     * // Delete a few UserTenants
     * const { count } = await prisma.userTenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTenantDeleteManyArgs>(args?: SelectSubset<T, UserTenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTenants
     * const userTenant = await prisma.userTenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTenantUpdateManyArgs>(args: SelectSubset<T, UserTenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTenant.
     * @param {UserTenantUpsertArgs} args - Arguments to update or create a UserTenant.
     * @example
     * // Update or create a UserTenant
     * const userTenant = await prisma.userTenant.upsert({
     *   create: {
     *     // ... data to create a UserTenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTenant we want to update
     *   }
     * })
     */
    upsert<T extends UserTenantUpsertArgs>(args: SelectSubset<T, UserTenantUpsertArgs<ExtArgs>>): Prisma__UserTenantClient<$Result.GetResult<Prisma.$UserTenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserTenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantCountArgs} args - Arguments to filter UserTenants to count.
     * @example
     * // Count the number of UserTenants
     * const count = await prisma.userTenant.count({
     *   where: {
     *     // ... the filter for the UserTenants we want to count
     *   }
     * })
    **/
    count<T extends UserTenantCountArgs>(
      args?: Subset<T, UserTenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTenantAggregateArgs>(args: Subset<T, UserTenantAggregateArgs>): Prisma.PrismaPromise<GetUserTenantAggregateType<T>>

    /**
     * Group by UserTenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTenantGroupByArgs['orderBy'] }
        : { orderBy?: UserTenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTenant model
   */
  readonly fields: UserTenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTenant model
   */ 
  interface UserTenantFieldRefs {
    readonly id: FieldRef<"UserTenant", 'String'>
    readonly userId: FieldRef<"UserTenant", 'String'>
    readonly tenantId: FieldRef<"UserTenant", 'String'>
    readonly role: FieldRef<"UserTenant", 'String'>
    readonly createdAt: FieldRef<"UserTenant", 'DateTime'>
    readonly updatedAt: FieldRef<"UserTenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTenant findUnique
   */
  export type UserTenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantInclude<ExtArgs> | null
    /**
     * Filter, which UserTenant to fetch.
     */
    where: UserTenantWhereUniqueInput
  }

  /**
   * UserTenant findUniqueOrThrow
   */
  export type UserTenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantInclude<ExtArgs> | null
    /**
     * Filter, which UserTenant to fetch.
     */
    where: UserTenantWhereUniqueInput
  }

  /**
   * UserTenant findFirst
   */
  export type UserTenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantInclude<ExtArgs> | null
    /**
     * Filter, which UserTenant to fetch.
     */
    where?: UserTenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTenants to fetch.
     */
    orderBy?: UserTenantOrderByWithRelationInput | UserTenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTenants.
     */
    cursor?: UserTenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTenants.
     */
    distinct?: UserTenantScalarFieldEnum | UserTenantScalarFieldEnum[]
  }

  /**
   * UserTenant findFirstOrThrow
   */
  export type UserTenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantInclude<ExtArgs> | null
    /**
     * Filter, which UserTenant to fetch.
     */
    where?: UserTenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTenants to fetch.
     */
    orderBy?: UserTenantOrderByWithRelationInput | UserTenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTenants.
     */
    cursor?: UserTenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTenants.
     */
    distinct?: UserTenantScalarFieldEnum | UserTenantScalarFieldEnum[]
  }

  /**
   * UserTenant findMany
   */
  export type UserTenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantInclude<ExtArgs> | null
    /**
     * Filter, which UserTenants to fetch.
     */
    where?: UserTenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTenants to fetch.
     */
    orderBy?: UserTenantOrderByWithRelationInput | UserTenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTenants.
     */
    cursor?: UserTenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTenants.
     */
    skip?: number
    distinct?: UserTenantScalarFieldEnum | UserTenantScalarFieldEnum[]
  }

  /**
   * UserTenant create
   */
  export type UserTenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTenant.
     */
    data: XOR<UserTenantCreateInput, UserTenantUncheckedCreateInput>
  }

  /**
   * UserTenant createMany
   */
  export type UserTenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTenants.
     */
    data: UserTenantCreateManyInput | UserTenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTenant createManyAndReturn
   */
  export type UserTenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserTenants.
     */
    data: UserTenantCreateManyInput | UserTenantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTenant update
   */
  export type UserTenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTenant.
     */
    data: XOR<UserTenantUpdateInput, UserTenantUncheckedUpdateInput>
    /**
     * Choose, which UserTenant to update.
     */
    where: UserTenantWhereUniqueInput
  }

  /**
   * UserTenant updateMany
   */
  export type UserTenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTenants.
     */
    data: XOR<UserTenantUpdateManyMutationInput, UserTenantUncheckedUpdateManyInput>
    /**
     * Filter which UserTenants to update
     */
    where?: UserTenantWhereInput
  }

  /**
   * UserTenant upsert
   */
  export type UserTenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTenant to update in case it exists.
     */
    where: UserTenantWhereUniqueInput
    /**
     * In case the UserTenant found by the `where` argument doesn't exist, create a new UserTenant with this data.
     */
    create: XOR<UserTenantCreateInput, UserTenantUncheckedCreateInput>
    /**
     * In case the UserTenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTenantUpdateInput, UserTenantUncheckedUpdateInput>
  }

  /**
   * UserTenant delete
   */
  export type UserTenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantInclude<ExtArgs> | null
    /**
     * Filter which UserTenant to delete.
     */
    where: UserTenantWhereUniqueInput
  }

  /**
   * UserTenant deleteMany
   */
  export type UserTenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTenants to delete
     */
    where?: UserTenantWhereInput
  }

  /**
   * UserTenant without action
   */
  export type UserTenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantInclude<ExtArgs> | null
  }


  /**
   * Model GlobalSettings
   */

  export type AggregateGlobalSettings = {
    _count: GlobalSettingsCountAggregateOutputType | null
    _min: GlobalSettingsMinAggregateOutputType | null
    _max: GlobalSettingsMaxAggregateOutputType | null
  }

  export type GlobalSettingsMinAggregateOutputType = {
    id: string | null
    singleton: boolean | null
    wahaHost: string | null
    wahaApiKey: string | null
    evolutionHost: string | null
    evolutionApiKey: string | null
    quepasaUrl: string | null
    quepasaLogin: string | null
    quepasaPassword: string | null
    logoUrl: string | null
    faviconUrl: string | null
    iconUrl: string | null
    companyName: string | null
    pageTitle: string | null
    primaryColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalSettingsMaxAggregateOutputType = {
    id: string | null
    singleton: boolean | null
    wahaHost: string | null
    wahaApiKey: string | null
    evolutionHost: string | null
    evolutionApiKey: string | null
    quepasaUrl: string | null
    quepasaLogin: string | null
    quepasaPassword: string | null
    logoUrl: string | null
    faviconUrl: string | null
    iconUrl: string | null
    companyName: string | null
    pageTitle: string | null
    primaryColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalSettingsCountAggregateOutputType = {
    id: number
    singleton: number
    wahaHost: number
    wahaApiKey: number
    evolutionHost: number
    evolutionApiKey: number
    quepasaUrl: number
    quepasaLogin: number
    quepasaPassword: number
    logoUrl: number
    faviconUrl: number
    iconUrl: number
    companyName: number
    pageTitle: number
    primaryColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GlobalSettingsMinAggregateInputType = {
    id?: true
    singleton?: true
    wahaHost?: true
    wahaApiKey?: true
    evolutionHost?: true
    evolutionApiKey?: true
    quepasaUrl?: true
    quepasaLogin?: true
    quepasaPassword?: true
    logoUrl?: true
    faviconUrl?: true
    iconUrl?: true
    companyName?: true
    pageTitle?: true
    primaryColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalSettingsMaxAggregateInputType = {
    id?: true
    singleton?: true
    wahaHost?: true
    wahaApiKey?: true
    evolutionHost?: true
    evolutionApiKey?: true
    quepasaUrl?: true
    quepasaLogin?: true
    quepasaPassword?: true
    logoUrl?: true
    faviconUrl?: true
    iconUrl?: true
    companyName?: true
    pageTitle?: true
    primaryColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalSettingsCountAggregateInputType = {
    id?: true
    singleton?: true
    wahaHost?: true
    wahaApiKey?: true
    evolutionHost?: true
    evolutionApiKey?: true
    quepasaUrl?: true
    quepasaLogin?: true
    quepasaPassword?: true
    logoUrl?: true
    faviconUrl?: true
    iconUrl?: true
    companyName?: true
    pageTitle?: true
    primaryColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GlobalSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalSettings to aggregate.
     */
    where?: GlobalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalSettings to fetch.
     */
    orderBy?: GlobalSettingsOrderByWithRelationInput | GlobalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlobalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GlobalSettings
    **/
    _count?: true | GlobalSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlobalSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlobalSettingsMaxAggregateInputType
  }

  export type GetGlobalSettingsAggregateType<T extends GlobalSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateGlobalSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlobalSettings[P]>
      : GetScalarType<T[P], AggregateGlobalSettings[P]>
  }




  export type GlobalSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlobalSettingsWhereInput
    orderBy?: GlobalSettingsOrderByWithAggregationInput | GlobalSettingsOrderByWithAggregationInput[]
    by: GlobalSettingsScalarFieldEnum[] | GlobalSettingsScalarFieldEnum
    having?: GlobalSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlobalSettingsCountAggregateInputType | true
    _min?: GlobalSettingsMinAggregateInputType
    _max?: GlobalSettingsMaxAggregateInputType
  }

  export type GlobalSettingsGroupByOutputType = {
    id: string
    singleton: boolean
    wahaHost: string
    wahaApiKey: string
    evolutionHost: string
    evolutionApiKey: string
    quepasaUrl: string
    quepasaLogin: string
    quepasaPassword: string
    logoUrl: string | null
    faviconUrl: string | null
    iconUrl: string | null
    companyName: string | null
    pageTitle: string | null
    primaryColor: string | null
    createdAt: Date
    updatedAt: Date
    _count: GlobalSettingsCountAggregateOutputType | null
    _min: GlobalSettingsMinAggregateOutputType | null
    _max: GlobalSettingsMaxAggregateOutputType | null
  }

  type GetGlobalSettingsGroupByPayload<T extends GlobalSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlobalSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlobalSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlobalSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], GlobalSettingsGroupByOutputType[P]>
        }
      >
    >


  export type GlobalSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    singleton?: boolean
    wahaHost?: boolean
    wahaApiKey?: boolean
    evolutionHost?: boolean
    evolutionApiKey?: boolean
    quepasaUrl?: boolean
    quepasaLogin?: boolean
    quepasaPassword?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    iconUrl?: boolean
    companyName?: boolean
    pageTitle?: boolean
    primaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["globalSettings"]>

  export type GlobalSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    singleton?: boolean
    wahaHost?: boolean
    wahaApiKey?: boolean
    evolutionHost?: boolean
    evolutionApiKey?: boolean
    quepasaUrl?: boolean
    quepasaLogin?: boolean
    quepasaPassword?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    iconUrl?: boolean
    companyName?: boolean
    pageTitle?: boolean
    primaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["globalSettings"]>

  export type GlobalSettingsSelectScalar = {
    id?: boolean
    singleton?: boolean
    wahaHost?: boolean
    wahaApiKey?: boolean
    evolutionHost?: boolean
    evolutionApiKey?: boolean
    quepasaUrl?: boolean
    quepasaLogin?: boolean
    quepasaPassword?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    iconUrl?: boolean
    companyName?: boolean
    pageTitle?: boolean
    primaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $GlobalSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GlobalSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      singleton: boolean
      wahaHost: string
      wahaApiKey: string
      evolutionHost: string
      evolutionApiKey: string
      quepasaUrl: string
      quepasaLogin: string
      quepasaPassword: string
      logoUrl: string | null
      faviconUrl: string | null
      iconUrl: string | null
      companyName: string | null
      pageTitle: string | null
      primaryColor: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["globalSettings"]>
    composites: {}
  }

  type GlobalSettingsGetPayload<S extends boolean | null | undefined | GlobalSettingsDefaultArgs> = $Result.GetResult<Prisma.$GlobalSettingsPayload, S>

  type GlobalSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GlobalSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GlobalSettingsCountAggregateInputType | true
    }

  export interface GlobalSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GlobalSettings'], meta: { name: 'GlobalSettings' } }
    /**
     * Find zero or one GlobalSettings that matches the filter.
     * @param {GlobalSettingsFindUniqueArgs} args - Arguments to find a GlobalSettings
     * @example
     * // Get one GlobalSettings
     * const globalSettings = await prisma.globalSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GlobalSettingsFindUniqueArgs>(args: SelectSubset<T, GlobalSettingsFindUniqueArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GlobalSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GlobalSettingsFindUniqueOrThrowArgs} args - Arguments to find a GlobalSettings
     * @example
     * // Get one GlobalSettings
     * const globalSettings = await prisma.globalSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GlobalSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, GlobalSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GlobalSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsFindFirstArgs} args - Arguments to find a GlobalSettings
     * @example
     * // Get one GlobalSettings
     * const globalSettings = await prisma.globalSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GlobalSettingsFindFirstArgs>(args?: SelectSubset<T, GlobalSettingsFindFirstArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GlobalSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsFindFirstOrThrowArgs} args - Arguments to find a GlobalSettings
     * @example
     * // Get one GlobalSettings
     * const globalSettings = await prisma.globalSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GlobalSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, GlobalSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GlobalSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GlobalSettings
     * const globalSettings = await prisma.globalSettings.findMany()
     * 
     * // Get first 10 GlobalSettings
     * const globalSettings = await prisma.globalSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const globalSettingsWithIdOnly = await prisma.globalSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GlobalSettingsFindManyArgs>(args?: SelectSubset<T, GlobalSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GlobalSettings.
     * @param {GlobalSettingsCreateArgs} args - Arguments to create a GlobalSettings.
     * @example
     * // Create one GlobalSettings
     * const GlobalSettings = await prisma.globalSettings.create({
     *   data: {
     *     // ... data to create a GlobalSettings
     *   }
     * })
     * 
     */
    create<T extends GlobalSettingsCreateArgs>(args: SelectSubset<T, GlobalSettingsCreateArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GlobalSettings.
     * @param {GlobalSettingsCreateManyArgs} args - Arguments to create many GlobalSettings.
     * @example
     * // Create many GlobalSettings
     * const globalSettings = await prisma.globalSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GlobalSettingsCreateManyArgs>(args?: SelectSubset<T, GlobalSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GlobalSettings and returns the data saved in the database.
     * @param {GlobalSettingsCreateManyAndReturnArgs} args - Arguments to create many GlobalSettings.
     * @example
     * // Create many GlobalSettings
     * const globalSettings = await prisma.globalSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GlobalSettings and only return the `id`
     * const globalSettingsWithIdOnly = await prisma.globalSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GlobalSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, GlobalSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GlobalSettings.
     * @param {GlobalSettingsDeleteArgs} args - Arguments to delete one GlobalSettings.
     * @example
     * // Delete one GlobalSettings
     * const GlobalSettings = await prisma.globalSettings.delete({
     *   where: {
     *     // ... filter to delete one GlobalSettings
     *   }
     * })
     * 
     */
    delete<T extends GlobalSettingsDeleteArgs>(args: SelectSubset<T, GlobalSettingsDeleteArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GlobalSettings.
     * @param {GlobalSettingsUpdateArgs} args - Arguments to update one GlobalSettings.
     * @example
     * // Update one GlobalSettings
     * const globalSettings = await prisma.globalSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GlobalSettingsUpdateArgs>(args: SelectSubset<T, GlobalSettingsUpdateArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GlobalSettings.
     * @param {GlobalSettingsDeleteManyArgs} args - Arguments to filter GlobalSettings to delete.
     * @example
     * // Delete a few GlobalSettings
     * const { count } = await prisma.globalSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GlobalSettingsDeleteManyArgs>(args?: SelectSubset<T, GlobalSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GlobalSettings
     * const globalSettings = await prisma.globalSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GlobalSettingsUpdateManyArgs>(args: SelectSubset<T, GlobalSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GlobalSettings.
     * @param {GlobalSettingsUpsertArgs} args - Arguments to update or create a GlobalSettings.
     * @example
     * // Update or create a GlobalSettings
     * const globalSettings = await prisma.globalSettings.upsert({
     *   create: {
     *     // ... data to create a GlobalSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GlobalSettings we want to update
     *   }
     * })
     */
    upsert<T extends GlobalSettingsUpsertArgs>(args: SelectSubset<T, GlobalSettingsUpsertArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GlobalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsCountArgs} args - Arguments to filter GlobalSettings to count.
     * @example
     * // Count the number of GlobalSettings
     * const count = await prisma.globalSettings.count({
     *   where: {
     *     // ... the filter for the GlobalSettings we want to count
     *   }
     * })
    **/
    count<T extends GlobalSettingsCountArgs>(
      args?: Subset<T, GlobalSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlobalSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GlobalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlobalSettingsAggregateArgs>(args: Subset<T, GlobalSettingsAggregateArgs>): Prisma.PrismaPromise<GetGlobalSettingsAggregateType<T>>

    /**
     * Group by GlobalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlobalSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlobalSettingsGroupByArgs['orderBy'] }
        : { orderBy?: GlobalSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlobalSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlobalSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GlobalSettings model
   */
  readonly fields: GlobalSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GlobalSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlobalSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GlobalSettings model
   */ 
  interface GlobalSettingsFieldRefs {
    readonly id: FieldRef<"GlobalSettings", 'String'>
    readonly singleton: FieldRef<"GlobalSettings", 'Boolean'>
    readonly wahaHost: FieldRef<"GlobalSettings", 'String'>
    readonly wahaApiKey: FieldRef<"GlobalSettings", 'String'>
    readonly evolutionHost: FieldRef<"GlobalSettings", 'String'>
    readonly evolutionApiKey: FieldRef<"GlobalSettings", 'String'>
    readonly quepasaUrl: FieldRef<"GlobalSettings", 'String'>
    readonly quepasaLogin: FieldRef<"GlobalSettings", 'String'>
    readonly quepasaPassword: FieldRef<"GlobalSettings", 'String'>
    readonly logoUrl: FieldRef<"GlobalSettings", 'String'>
    readonly faviconUrl: FieldRef<"GlobalSettings", 'String'>
    readonly iconUrl: FieldRef<"GlobalSettings", 'String'>
    readonly companyName: FieldRef<"GlobalSettings", 'String'>
    readonly pageTitle: FieldRef<"GlobalSettings", 'String'>
    readonly primaryColor: FieldRef<"GlobalSettings", 'String'>
    readonly createdAt: FieldRef<"GlobalSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"GlobalSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GlobalSettings findUnique
   */
  export type GlobalSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * Filter, which GlobalSettings to fetch.
     */
    where: GlobalSettingsWhereUniqueInput
  }

  /**
   * GlobalSettings findUniqueOrThrow
   */
  export type GlobalSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * Filter, which GlobalSettings to fetch.
     */
    where: GlobalSettingsWhereUniqueInput
  }

  /**
   * GlobalSettings findFirst
   */
  export type GlobalSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * Filter, which GlobalSettings to fetch.
     */
    where?: GlobalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalSettings to fetch.
     */
    orderBy?: GlobalSettingsOrderByWithRelationInput | GlobalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalSettings.
     */
    cursor?: GlobalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalSettings.
     */
    distinct?: GlobalSettingsScalarFieldEnum | GlobalSettingsScalarFieldEnum[]
  }

  /**
   * GlobalSettings findFirstOrThrow
   */
  export type GlobalSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * Filter, which GlobalSettings to fetch.
     */
    where?: GlobalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalSettings to fetch.
     */
    orderBy?: GlobalSettingsOrderByWithRelationInput | GlobalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalSettings.
     */
    cursor?: GlobalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalSettings.
     */
    distinct?: GlobalSettingsScalarFieldEnum | GlobalSettingsScalarFieldEnum[]
  }

  /**
   * GlobalSettings findMany
   */
  export type GlobalSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * Filter, which GlobalSettings to fetch.
     */
    where?: GlobalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalSettings to fetch.
     */
    orderBy?: GlobalSettingsOrderByWithRelationInput | GlobalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GlobalSettings.
     */
    cursor?: GlobalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalSettings.
     */
    skip?: number
    distinct?: GlobalSettingsScalarFieldEnum | GlobalSettingsScalarFieldEnum[]
  }

  /**
   * GlobalSettings create
   */
  export type GlobalSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a GlobalSettings.
     */
    data: XOR<GlobalSettingsCreateInput, GlobalSettingsUncheckedCreateInput>
  }

  /**
   * GlobalSettings createMany
   */
  export type GlobalSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GlobalSettings.
     */
    data: GlobalSettingsCreateManyInput | GlobalSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalSettings createManyAndReturn
   */
  export type GlobalSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GlobalSettings.
     */
    data: GlobalSettingsCreateManyInput | GlobalSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalSettings update
   */
  export type GlobalSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a GlobalSettings.
     */
    data: XOR<GlobalSettingsUpdateInput, GlobalSettingsUncheckedUpdateInput>
    /**
     * Choose, which GlobalSettings to update.
     */
    where: GlobalSettingsWhereUniqueInput
  }

  /**
   * GlobalSettings updateMany
   */
  export type GlobalSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GlobalSettings.
     */
    data: XOR<GlobalSettingsUpdateManyMutationInput, GlobalSettingsUncheckedUpdateManyInput>
    /**
     * Filter which GlobalSettings to update
     */
    where?: GlobalSettingsWhereInput
  }

  /**
   * GlobalSettings upsert
   */
  export type GlobalSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the GlobalSettings to update in case it exists.
     */
    where: GlobalSettingsWhereUniqueInput
    /**
     * In case the GlobalSettings found by the `where` argument doesn't exist, create a new GlobalSettings with this data.
     */
    create: XOR<GlobalSettingsCreateInput, GlobalSettingsUncheckedCreateInput>
    /**
     * In case the GlobalSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlobalSettingsUpdateInput, GlobalSettingsUncheckedUpdateInput>
  }

  /**
   * GlobalSettings delete
   */
  export type GlobalSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * Filter which GlobalSettings to delete.
     */
    where: GlobalSettingsWhereUniqueInput
  }

  /**
   * GlobalSettings deleteMany
   */
  export type GlobalSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalSettings to delete
     */
    where?: GlobalSettingsWhereInput
  }

  /**
   * GlobalSettings without action
   */
  export type GlobalSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    nome: string | null
    telefone: string | null
    email: string | null
    observacoes: string | null
    categoriaId: string | null
    tenantId: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    telefone: string | null
    email: string | null
    observacoes: string | null
    categoriaId: string | null
    tenantId: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    nome: number
    telefone: number
    email: number
    tags: number
    observacoes: number
    categoriaId: number
    tenantId: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    nome?: true
    telefone?: true
    email?: true
    observacoes?: true
    categoriaId?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    nome?: true
    telefone?: true
    email?: true
    observacoes?: true
    categoriaId?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    nome?: true
    telefone?: true
    email?: true
    tags?: true
    observacoes?: true
    categoriaId?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    nome: string
    telefone: string
    email: string | null
    tags: string[]
    observacoes: string | null
    categoriaId: string | null
    tenantId: string | null
    criadoEm: Date
    atualizadoEm: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    telefone?: boolean
    email?: boolean
    tags?: boolean
    observacoes?: boolean
    categoriaId?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    categoria?: boolean | Contact$categoriaArgs<ExtArgs>
    tenant?: boolean | Contact$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    telefone?: boolean
    email?: boolean
    tags?: boolean
    observacoes?: boolean
    categoriaId?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    categoria?: boolean | Contact$categoriaArgs<ExtArgs>
    tenant?: boolean | Contact$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    nome?: boolean
    telefone?: boolean
    email?: boolean
    tags?: boolean
    observacoes?: boolean
    categoriaId?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | Contact$categoriaArgs<ExtArgs>
    tenant?: boolean | Contact$tenantArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | Contact$categoriaArgs<ExtArgs>
    tenant?: boolean | Contact$tenantArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      categoria: Prisma.$CategoryPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      telefone: string
      email: string | null
      tags: string[]
      observacoes: string | null
      categoriaId: string | null
      tenantId: string | null
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categoria<T extends Contact$categoriaArgs<ExtArgs> = {}>(args?: Subset<T, Contact$categoriaArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tenant<T extends Contact$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Contact$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly nome: FieldRef<"Contact", 'String'>
    readonly telefone: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly tags: FieldRef<"Contact", 'String[]'>
    readonly observacoes: FieldRef<"Contact", 'String'>
    readonly categoriaId: FieldRef<"Contact", 'String'>
    readonly tenantId: FieldRef<"Contact", 'String'>
    readonly criadoEm: FieldRef<"Contact", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }

  /**
   * Contact.categoria
   */
  export type Contact$categoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Contact.tenant
   */
  export type Contact$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    nome: string | null
    cor: string | null
    descricao: string | null
    tenantId: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    cor: string | null
    descricao: string | null
    tenantId: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    nome: number
    cor: number
    descricao: number
    tenantId: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    nome?: true
    cor?: true
    descricao?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    nome?: true
    cor?: true
    descricao?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    nome?: true
    cor?: true
    descricao?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    nome: string
    cor: string
    descricao: string | null
    tenantId: string | null
    criadoEm: Date
    atualizadoEm: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cor?: boolean
    descricao?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    contacts?: boolean | Category$contactsArgs<ExtArgs>
    tenant?: boolean | Category$tenantArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cor?: boolean
    descricao?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    tenant?: boolean | Category$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    nome?: boolean
    cor?: boolean
    descricao?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | Category$contactsArgs<ExtArgs>
    tenant?: boolean | Category$tenantArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Category$tenantArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      cor: string
      descricao: string | null
      tenantId: string | null
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contacts<T extends Category$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Category$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    tenant<T extends Category$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Category$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly nome: FieldRef<"Category", 'String'>
    readonly cor: FieldRef<"Category", 'String'>
    readonly descricao: FieldRef<"Category", 'String'>
    readonly tenantId: FieldRef<"Category", 'String'>
    readonly criadoEm: FieldRef<"Category", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.contacts
   */
  export type Category$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Category.tenant
   */
  export type Category$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppSession
   */

  export type AggregateWhatsAppSession = {
    _count: WhatsAppSessionCountAggregateOutputType | null
    _min: WhatsAppSessionMinAggregateOutputType | null
    _max: WhatsAppSessionMaxAggregateOutputType | null
  }

  export type WhatsAppSessionMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    status: string | null
    config: string | null
    meId: string | null
    mePushName: string | null
    meLid: string | null
    meJid: string | null
    qr: string | null
    qrExpiresAt: Date | null
    assignedWorker: string | null
    tenantId: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
    provider: string | null
    quepasaToken: string | null
  }

  export type WhatsAppSessionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    status: string | null
    config: string | null
    meId: string | null
    mePushName: string | null
    meLid: string | null
    meJid: string | null
    qr: string | null
    qrExpiresAt: Date | null
    assignedWorker: string | null
    tenantId: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
    provider: string | null
    quepasaToken: string | null
  }

  export type WhatsAppSessionCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    status: number
    config: number
    meId: number
    mePushName: number
    meLid: number
    meJid: number
    qr: number
    qrExpiresAt: number
    assignedWorker: number
    tenantId: number
    criadoEm: number
    atualizadoEm: number
    provider: number
    quepasaToken: number
    _all: number
  }


  export type WhatsAppSessionMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    status?: true
    config?: true
    meId?: true
    mePushName?: true
    meLid?: true
    meJid?: true
    qr?: true
    qrExpiresAt?: true
    assignedWorker?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
    provider?: true
    quepasaToken?: true
  }

  export type WhatsAppSessionMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    status?: true
    config?: true
    meId?: true
    mePushName?: true
    meLid?: true
    meJid?: true
    qr?: true
    qrExpiresAt?: true
    assignedWorker?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
    provider?: true
    quepasaToken?: true
  }

  export type WhatsAppSessionCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    status?: true
    config?: true
    meId?: true
    mePushName?: true
    meLid?: true
    meJid?: true
    qr?: true
    qrExpiresAt?: true
    assignedWorker?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
    provider?: true
    quepasaToken?: true
    _all?: true
  }

  export type WhatsAppSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppSession to aggregate.
     */
    where?: WhatsAppSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppSessions to fetch.
     */
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppSessions
    **/
    _count?: true | WhatsAppSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppSessionMaxAggregateInputType
  }

  export type GetWhatsAppSessionAggregateType<T extends WhatsAppSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppSession[P]>
      : GetScalarType<T[P], AggregateWhatsAppSession[P]>
  }




  export type WhatsAppSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppSessionWhereInput
    orderBy?: WhatsAppSessionOrderByWithAggregationInput | WhatsAppSessionOrderByWithAggregationInput[]
    by: WhatsAppSessionScalarFieldEnum[] | WhatsAppSessionScalarFieldEnum
    having?: WhatsAppSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppSessionCountAggregateInputType | true
    _min?: WhatsAppSessionMinAggregateInputType
    _max?: WhatsAppSessionMaxAggregateInputType
  }

  export type WhatsAppSessionGroupByOutputType = {
    id: string
    name: string
    displayName: string | null
    status: string
    config: string | null
    meId: string | null
    mePushName: string | null
    meLid: string | null
    meJid: string | null
    qr: string | null
    qrExpiresAt: Date | null
    assignedWorker: string | null
    tenantId: string | null
    criadoEm: Date
    atualizadoEm: Date
    provider: string
    quepasaToken: string | null
    _count: WhatsAppSessionCountAggregateOutputType | null
    _min: WhatsAppSessionMinAggregateOutputType | null
    _max: WhatsAppSessionMaxAggregateOutputType | null
  }

  type GetWhatsAppSessionGroupByPayload<T extends WhatsAppSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppSessionGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppSessionGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    status?: boolean
    config?: boolean
    meId?: boolean
    mePushName?: boolean
    meLid?: boolean
    meJid?: boolean
    qr?: boolean
    qrExpiresAt?: boolean
    assignedWorker?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    provider?: boolean
    quepasaToken?: boolean
    campaigns?: boolean | WhatsAppSession$campaignsArgs<ExtArgs>
    tenant?: boolean | WhatsAppSession$tenantArgs<ExtArgs>
    _count?: boolean | WhatsAppSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppSession"]>

  export type WhatsAppSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    status?: boolean
    config?: boolean
    meId?: boolean
    mePushName?: boolean
    meLid?: boolean
    meJid?: boolean
    qr?: boolean
    qrExpiresAt?: boolean
    assignedWorker?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    provider?: boolean
    quepasaToken?: boolean
    tenant?: boolean | WhatsAppSession$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppSession"]>

  export type WhatsAppSessionSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    status?: boolean
    config?: boolean
    meId?: boolean
    mePushName?: boolean
    meLid?: boolean
    meJid?: boolean
    qr?: boolean
    qrExpiresAt?: boolean
    assignedWorker?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    provider?: boolean
    quepasaToken?: boolean
  }

  export type WhatsAppSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | WhatsAppSession$campaignsArgs<ExtArgs>
    tenant?: boolean | WhatsAppSession$tenantArgs<ExtArgs>
    _count?: boolean | WhatsAppSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsAppSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | WhatsAppSession$tenantArgs<ExtArgs>
  }

  export type $WhatsAppSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppSession"
    objects: {
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string | null
      status: string
      config: string | null
      meId: string | null
      mePushName: string | null
      meLid: string | null
      meJid: string | null
      qr: string | null
      qrExpiresAt: Date | null
      assignedWorker: string | null
      tenantId: string | null
      criadoEm: Date
      atualizadoEm: Date
      provider: string
      quepasaToken: string | null
    }, ExtArgs["result"]["whatsAppSession"]>
    composites: {}
  }

  type WhatsAppSessionGetPayload<S extends boolean | null | undefined | WhatsAppSessionDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppSessionPayload, S>

  type WhatsAppSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WhatsAppSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WhatsAppSessionCountAggregateInputType | true
    }

  export interface WhatsAppSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppSession'], meta: { name: 'WhatsAppSession' } }
    /**
     * Find zero or one WhatsAppSession that matches the filter.
     * @param {WhatsAppSessionFindUniqueArgs} args - Arguments to find a WhatsAppSession
     * @example
     * // Get one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppSessionFindUniqueArgs>(args: SelectSubset<T, WhatsAppSessionFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WhatsAppSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WhatsAppSessionFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppSession
     * @example
     * // Get one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WhatsAppSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionFindFirstArgs} args - Arguments to find a WhatsAppSession
     * @example
     * // Get one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppSessionFindFirstArgs>(args?: SelectSubset<T, WhatsAppSessionFindFirstArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WhatsAppSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionFindFirstOrThrowArgs} args - Arguments to find a WhatsAppSession
     * @example
     * // Get one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WhatsAppSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppSessions
     * const whatsAppSessions = await prisma.whatsAppSession.findMany()
     * 
     * // Get first 10 WhatsAppSessions
     * const whatsAppSessions = await prisma.whatsAppSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppSessionWithIdOnly = await prisma.whatsAppSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppSessionFindManyArgs>(args?: SelectSubset<T, WhatsAppSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WhatsAppSession.
     * @param {WhatsAppSessionCreateArgs} args - Arguments to create a WhatsAppSession.
     * @example
     * // Create one WhatsAppSession
     * const WhatsAppSession = await prisma.whatsAppSession.create({
     *   data: {
     *     // ... data to create a WhatsAppSession
     *   }
     * })
     * 
     */
    create<T extends WhatsAppSessionCreateArgs>(args: SelectSubset<T, WhatsAppSessionCreateArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WhatsAppSessions.
     * @param {WhatsAppSessionCreateManyArgs} args - Arguments to create many WhatsAppSessions.
     * @example
     * // Create many WhatsAppSessions
     * const whatsAppSession = await prisma.whatsAppSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppSessionCreateManyArgs>(args?: SelectSubset<T, WhatsAppSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppSessions and returns the data saved in the database.
     * @param {WhatsAppSessionCreateManyAndReturnArgs} args - Arguments to create many WhatsAppSessions.
     * @example
     * // Create many WhatsAppSessions
     * const whatsAppSession = await prisma.whatsAppSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppSessions and only return the `id`
     * const whatsAppSessionWithIdOnly = await prisma.whatsAppSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WhatsAppSession.
     * @param {WhatsAppSessionDeleteArgs} args - Arguments to delete one WhatsAppSession.
     * @example
     * // Delete one WhatsAppSession
     * const WhatsAppSession = await prisma.whatsAppSession.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppSession
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppSessionDeleteArgs>(args: SelectSubset<T, WhatsAppSessionDeleteArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WhatsAppSession.
     * @param {WhatsAppSessionUpdateArgs} args - Arguments to update one WhatsAppSession.
     * @example
     * // Update one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppSessionUpdateArgs>(args: SelectSubset<T, WhatsAppSessionUpdateArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WhatsAppSessions.
     * @param {WhatsAppSessionDeleteManyArgs} args - Arguments to filter WhatsAppSessions to delete.
     * @example
     * // Delete a few WhatsAppSessions
     * const { count } = await prisma.whatsAppSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppSessionDeleteManyArgs>(args?: SelectSubset<T, WhatsAppSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppSessions
     * const whatsAppSession = await prisma.whatsAppSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppSessionUpdateManyArgs>(args: SelectSubset<T, WhatsAppSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WhatsAppSession.
     * @param {WhatsAppSessionUpsertArgs} args - Arguments to update or create a WhatsAppSession.
     * @example
     * // Update or create a WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.upsert({
     *   create: {
     *     // ... data to create a WhatsAppSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppSession we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppSessionUpsertArgs>(args: SelectSubset<T, WhatsAppSessionUpsertArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WhatsAppSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionCountArgs} args - Arguments to filter WhatsAppSessions to count.
     * @example
     * // Count the number of WhatsAppSessions
     * const count = await prisma.whatsAppSession.count({
     *   where: {
     *     // ... the filter for the WhatsAppSessions we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppSessionCountArgs>(
      args?: Subset<T, WhatsAppSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppSessionAggregateArgs>(args: Subset<T, WhatsAppSessionAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppSessionAggregateType<T>>

    /**
     * Group by WhatsAppSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppSessionGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppSession model
   */
  readonly fields: WhatsAppSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends WhatsAppSession$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppSession$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    tenant<T extends WhatsAppSession$tenantArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppSession$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppSession model
   */ 
  interface WhatsAppSessionFieldRefs {
    readonly id: FieldRef<"WhatsAppSession", 'String'>
    readonly name: FieldRef<"WhatsAppSession", 'String'>
    readonly displayName: FieldRef<"WhatsAppSession", 'String'>
    readonly status: FieldRef<"WhatsAppSession", 'String'>
    readonly config: FieldRef<"WhatsAppSession", 'String'>
    readonly meId: FieldRef<"WhatsAppSession", 'String'>
    readonly mePushName: FieldRef<"WhatsAppSession", 'String'>
    readonly meLid: FieldRef<"WhatsAppSession", 'String'>
    readonly meJid: FieldRef<"WhatsAppSession", 'String'>
    readonly qr: FieldRef<"WhatsAppSession", 'String'>
    readonly qrExpiresAt: FieldRef<"WhatsAppSession", 'DateTime'>
    readonly assignedWorker: FieldRef<"WhatsAppSession", 'String'>
    readonly tenantId: FieldRef<"WhatsAppSession", 'String'>
    readonly criadoEm: FieldRef<"WhatsAppSession", 'DateTime'>
    readonly atualizadoEm: FieldRef<"WhatsAppSession", 'DateTime'>
    readonly provider: FieldRef<"WhatsAppSession", 'String'>
    readonly quepasaToken: FieldRef<"WhatsAppSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppSession findUnique
   */
  export type WhatsAppSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSession to fetch.
     */
    where: WhatsAppSessionWhereUniqueInput
  }

  /**
   * WhatsAppSession findUniqueOrThrow
   */
  export type WhatsAppSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSession to fetch.
     */
    where: WhatsAppSessionWhereUniqueInput
  }

  /**
   * WhatsAppSession findFirst
   */
  export type WhatsAppSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSession to fetch.
     */
    where?: WhatsAppSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppSessions to fetch.
     */
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppSessions.
     */
    cursor?: WhatsAppSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppSessions.
     */
    distinct?: WhatsAppSessionScalarFieldEnum | WhatsAppSessionScalarFieldEnum[]
  }

  /**
   * WhatsAppSession findFirstOrThrow
   */
  export type WhatsAppSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSession to fetch.
     */
    where?: WhatsAppSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppSessions to fetch.
     */
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppSessions.
     */
    cursor?: WhatsAppSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppSessions.
     */
    distinct?: WhatsAppSessionScalarFieldEnum | WhatsAppSessionScalarFieldEnum[]
  }

  /**
   * WhatsAppSession findMany
   */
  export type WhatsAppSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSessions to fetch.
     */
    where?: WhatsAppSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppSessions to fetch.
     */
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppSessions.
     */
    cursor?: WhatsAppSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppSessions.
     */
    skip?: number
    distinct?: WhatsAppSessionScalarFieldEnum | WhatsAppSessionScalarFieldEnum[]
  }

  /**
   * WhatsAppSession create
   */
  export type WhatsAppSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppSession.
     */
    data: XOR<WhatsAppSessionCreateInput, WhatsAppSessionUncheckedCreateInput>
  }

  /**
   * WhatsAppSession createMany
   */
  export type WhatsAppSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppSessions.
     */
    data: WhatsAppSessionCreateManyInput | WhatsAppSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppSession createManyAndReturn
   */
  export type WhatsAppSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WhatsAppSessions.
     */
    data: WhatsAppSessionCreateManyInput | WhatsAppSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppSession update
   */
  export type WhatsAppSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppSession.
     */
    data: XOR<WhatsAppSessionUpdateInput, WhatsAppSessionUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppSession to update.
     */
    where: WhatsAppSessionWhereUniqueInput
  }

  /**
   * WhatsAppSession updateMany
   */
  export type WhatsAppSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppSessions.
     */
    data: XOR<WhatsAppSessionUpdateManyMutationInput, WhatsAppSessionUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppSessions to update
     */
    where?: WhatsAppSessionWhereInput
  }

  /**
   * WhatsAppSession upsert
   */
  export type WhatsAppSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppSession to update in case it exists.
     */
    where: WhatsAppSessionWhereUniqueInput
    /**
     * In case the WhatsAppSession found by the `where` argument doesn't exist, create a new WhatsAppSession with this data.
     */
    create: XOR<WhatsAppSessionCreateInput, WhatsAppSessionUncheckedCreateInput>
    /**
     * In case the WhatsAppSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppSessionUpdateInput, WhatsAppSessionUncheckedUpdateInput>
  }

  /**
   * WhatsAppSession delete
   */
  export type WhatsAppSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppSession to delete.
     */
    where: WhatsAppSessionWhereUniqueInput
  }

  /**
   * WhatsAppSession deleteMany
   */
  export type WhatsAppSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppSessions to delete
     */
    where?: WhatsAppSessionWhereInput
  }

  /**
   * WhatsAppSession.campaigns
   */
  export type WhatsAppSession$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * WhatsAppSession.tenant
   */
  export type WhatsAppSession$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * WhatsAppSession without action
   */
  export type WhatsAppSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    randomDelay: number | null
    totalContacts: number | null
    sentCount: number | null
    failedCount: number | null
  }

  export type CampaignSumAggregateOutputType = {
    randomDelay: number | null
    totalContacts: number | null
    sentCount: number | null
    failedCount: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    nome: string | null
    targetTags: string | null
    sessionName: string | null
    messageType: string | null
    messageContent: string | null
    randomDelay: number | null
    startImmediately: boolean | null
    scheduledFor: Date | null
    status: string | null
    totalContacts: number | null
    sentCount: number | null
    failedCount: number | null
    startedAt: Date | null
    completedAt: Date | null
    startTime: string | null
    endTime: string | null
    useTimeWindow: boolean | null
    tenantId: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
    sessionNames: string | null
    createdBy: string | null
    createdByName: string | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    targetTags: string | null
    sessionName: string | null
    messageType: string | null
    messageContent: string | null
    randomDelay: number | null
    startImmediately: boolean | null
    scheduledFor: Date | null
    status: string | null
    totalContacts: number | null
    sentCount: number | null
    failedCount: number | null
    startedAt: Date | null
    completedAt: Date | null
    startTime: string | null
    endTime: string | null
    useTimeWindow: boolean | null
    tenantId: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
    sessionNames: string | null
    createdBy: string | null
    createdByName: string | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    nome: number
    targetTags: number
    sessionName: number
    messageType: number
    messageContent: number
    randomDelay: number
    startImmediately: number
    scheduledFor: number
    status: number
    totalContacts: number
    sentCount: number
    failedCount: number
    startedAt: number
    completedAt: number
    startTime: number
    endTime: number
    useTimeWindow: number
    tenantId: number
    criadoEm: number
    atualizadoEm: number
    sessionNames: number
    createdBy: number
    createdByName: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    randomDelay?: true
    totalContacts?: true
    sentCount?: true
    failedCount?: true
  }

  export type CampaignSumAggregateInputType = {
    randomDelay?: true
    totalContacts?: true
    sentCount?: true
    failedCount?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    nome?: true
    targetTags?: true
    sessionName?: true
    messageType?: true
    messageContent?: true
    randomDelay?: true
    startImmediately?: true
    scheduledFor?: true
    status?: true
    totalContacts?: true
    sentCount?: true
    failedCount?: true
    startedAt?: true
    completedAt?: true
    startTime?: true
    endTime?: true
    useTimeWindow?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
    sessionNames?: true
    createdBy?: true
    createdByName?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    nome?: true
    targetTags?: true
    sessionName?: true
    messageType?: true
    messageContent?: true
    randomDelay?: true
    startImmediately?: true
    scheduledFor?: true
    status?: true
    totalContacts?: true
    sentCount?: true
    failedCount?: true
    startedAt?: true
    completedAt?: true
    startTime?: true
    endTime?: true
    useTimeWindow?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
    sessionNames?: true
    createdBy?: true
    createdByName?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    nome?: true
    targetTags?: true
    sessionName?: true
    messageType?: true
    messageContent?: true
    randomDelay?: true
    startImmediately?: true
    scheduledFor?: true
    status?: true
    totalContacts?: true
    sentCount?: true
    failedCount?: true
    startedAt?: true
    completedAt?: true
    startTime?: true
    endTime?: true
    useTimeWindow?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
    sessionNames?: true
    createdBy?: true
    createdByName?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    nome: string
    targetTags: string
    sessionName: string | null
    messageType: string
    messageContent: string
    randomDelay: number
    startImmediately: boolean
    scheduledFor: Date | null
    status: string
    totalContacts: number
    sentCount: number
    failedCount: number
    startedAt: Date | null
    completedAt: Date | null
    startTime: string | null
    endTime: string | null
    useTimeWindow: boolean
    tenantId: string | null
    criadoEm: Date
    atualizadoEm: Date
    sessionNames: string | null
    createdBy: string | null
    createdByName: string | null
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    targetTags?: boolean
    sessionName?: boolean
    messageType?: boolean
    messageContent?: boolean
    randomDelay?: boolean
    startImmediately?: boolean
    scheduledFor?: boolean
    status?: boolean
    totalContacts?: boolean
    sentCount?: boolean
    failedCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    startTime?: boolean
    endTime?: boolean
    useTimeWindow?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessionNames?: boolean
    createdBy?: boolean
    createdByName?: boolean
    messages?: boolean | Campaign$messagesArgs<ExtArgs>
    session?: boolean | Campaign$sessionArgs<ExtArgs>
    tenant?: boolean | Campaign$tenantArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    targetTags?: boolean
    sessionName?: boolean
    messageType?: boolean
    messageContent?: boolean
    randomDelay?: boolean
    startImmediately?: boolean
    scheduledFor?: boolean
    status?: boolean
    totalContacts?: boolean
    sentCount?: boolean
    failedCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    startTime?: boolean
    endTime?: boolean
    useTimeWindow?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessionNames?: boolean
    createdBy?: boolean
    createdByName?: boolean
    session?: boolean | Campaign$sessionArgs<ExtArgs>
    tenant?: boolean | Campaign$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    nome?: boolean
    targetTags?: boolean
    sessionName?: boolean
    messageType?: boolean
    messageContent?: boolean
    randomDelay?: boolean
    startImmediately?: boolean
    scheduledFor?: boolean
    status?: boolean
    totalContacts?: boolean
    sentCount?: boolean
    failedCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    startTime?: boolean
    endTime?: boolean
    useTimeWindow?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessionNames?: boolean
    createdBy?: boolean
    createdByName?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Campaign$messagesArgs<ExtArgs>
    session?: boolean | Campaign$sessionArgs<ExtArgs>
    tenant?: boolean | Campaign$tenantArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | Campaign$sessionArgs<ExtArgs>
    tenant?: boolean | Campaign$tenantArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      messages: Prisma.$CampaignMessagePayload<ExtArgs>[]
      session: Prisma.$WhatsAppSessionPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      targetTags: string
      sessionName: string | null
      messageType: string
      messageContent: string
      randomDelay: number
      startImmediately: boolean
      scheduledFor: Date | null
      status: string
      totalContacts: number
      sentCount: number
      failedCount: number
      startedAt: Date | null
      completedAt: Date | null
      startTime: string | null
      endTime: string | null
      useTimeWindow: boolean
      tenantId: string | null
      criadoEm: Date
      atualizadoEm: Date
      sessionNames: string | null
      createdBy: string | null
      createdByName: string | null
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends Campaign$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findMany"> | Null>
    session<T extends Campaign$sessionArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$sessionArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tenant<T extends Campaign$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly nome: FieldRef<"Campaign", 'String'>
    readonly targetTags: FieldRef<"Campaign", 'String'>
    readonly sessionName: FieldRef<"Campaign", 'String'>
    readonly messageType: FieldRef<"Campaign", 'String'>
    readonly messageContent: FieldRef<"Campaign", 'String'>
    readonly randomDelay: FieldRef<"Campaign", 'Int'>
    readonly startImmediately: FieldRef<"Campaign", 'Boolean'>
    readonly scheduledFor: FieldRef<"Campaign", 'DateTime'>
    readonly status: FieldRef<"Campaign", 'String'>
    readonly totalContacts: FieldRef<"Campaign", 'Int'>
    readonly sentCount: FieldRef<"Campaign", 'Int'>
    readonly failedCount: FieldRef<"Campaign", 'Int'>
    readonly startedAt: FieldRef<"Campaign", 'DateTime'>
    readonly completedAt: FieldRef<"Campaign", 'DateTime'>
    readonly startTime: FieldRef<"Campaign", 'String'>
    readonly endTime: FieldRef<"Campaign", 'String'>
    readonly useTimeWindow: FieldRef<"Campaign", 'Boolean'>
    readonly tenantId: FieldRef<"Campaign", 'String'>
    readonly criadoEm: FieldRef<"Campaign", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Campaign", 'DateTime'>
    readonly sessionNames: FieldRef<"Campaign", 'String'>
    readonly createdBy: FieldRef<"Campaign", 'String'>
    readonly createdByName: FieldRef<"Campaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.messages
   */
  export type Campaign$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    where?: CampaignMessageWhereInput
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    cursor?: CampaignMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * Campaign.session
   */
  export type Campaign$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    where?: WhatsAppSessionWhereInput
  }

  /**
   * Campaign.tenant
   */
  export type Campaign$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignMessage
   */

  export type AggregateCampaignMessage = {
    _count: CampaignMessageCountAggregateOutputType | null
    _min: CampaignMessageMinAggregateOutputType | null
    _max: CampaignMessageMaxAggregateOutputType | null
  }

  export type CampaignMessageMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    contactId: string | null
    contactPhone: string | null
    contactName: string | null
    status: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    errorMessage: string | null
    messageId: string | null
    selectedVariation: string | null
    tenantId: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
    sessionName: string | null
  }

  export type CampaignMessageMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    contactId: string | null
    contactPhone: string | null
    contactName: string | null
    status: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    errorMessage: string | null
    messageId: string | null
    selectedVariation: string | null
    tenantId: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
    sessionName: string | null
  }

  export type CampaignMessageCountAggregateOutputType = {
    id: number
    campaignId: number
    contactId: number
    contactPhone: number
    contactName: number
    status: number
    sentAt: number
    deliveredAt: number
    readAt: number
    errorMessage: number
    messageId: number
    selectedVariation: number
    tenantId: number
    criadoEm: number
    atualizadoEm: number
    sessionName: number
    _all: number
  }


  export type CampaignMessageMinAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    contactPhone?: true
    contactName?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    errorMessage?: true
    messageId?: true
    selectedVariation?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
    sessionName?: true
  }

  export type CampaignMessageMaxAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    contactPhone?: true
    contactName?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    errorMessage?: true
    messageId?: true
    selectedVariation?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
    sessionName?: true
  }

  export type CampaignMessageCountAggregateInputType = {
    id?: true
    campaignId?: true
    contactId?: true
    contactPhone?: true
    contactName?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    errorMessage?: true
    messageId?: true
    selectedVariation?: true
    tenantId?: true
    criadoEm?: true
    atualizadoEm?: true
    sessionName?: true
    _all?: true
  }

  export type CampaignMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMessage to aggregate.
     */
    where?: CampaignMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMessages to fetch.
     */
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignMessages
    **/
    _count?: true | CampaignMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMessageMaxAggregateInputType
  }

  export type GetCampaignMessageAggregateType<T extends CampaignMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignMessage[P]>
      : GetScalarType<T[P], AggregateCampaignMessage[P]>
  }




  export type CampaignMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMessageWhereInput
    orderBy?: CampaignMessageOrderByWithAggregationInput | CampaignMessageOrderByWithAggregationInput[]
    by: CampaignMessageScalarFieldEnum[] | CampaignMessageScalarFieldEnum
    having?: CampaignMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignMessageCountAggregateInputType | true
    _min?: CampaignMessageMinAggregateInputType
    _max?: CampaignMessageMaxAggregateInputType
  }

  export type CampaignMessageGroupByOutputType = {
    id: string
    campaignId: string
    contactId: string
    contactPhone: string
    contactName: string
    status: string
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    errorMessage: string | null
    messageId: string | null
    selectedVariation: string | null
    tenantId: string | null
    criadoEm: Date
    atualizadoEm: Date
    sessionName: string | null
    _count: CampaignMessageCountAggregateOutputType | null
    _min: CampaignMessageMinAggregateOutputType | null
    _max: CampaignMessageMaxAggregateOutputType | null
  }

  type GetCampaignMessageGroupByPayload<T extends CampaignMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignMessageGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignMessageGroupByOutputType[P]>
        }
      >
    >


  export type CampaignMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    contactPhone?: boolean
    contactName?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    errorMessage?: boolean
    messageId?: boolean
    selectedVariation?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessionName?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    tenant?: boolean | CampaignMessage$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMessage"]>

  export type CampaignMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    contactPhone?: boolean
    contactName?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    errorMessage?: boolean
    messageId?: boolean
    selectedVariation?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessionName?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    tenant?: boolean | CampaignMessage$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMessage"]>

  export type CampaignMessageSelectScalar = {
    id?: boolean
    campaignId?: boolean
    contactId?: boolean
    contactPhone?: boolean
    contactName?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    errorMessage?: boolean
    messageId?: boolean
    selectedVariation?: boolean
    tenantId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessionName?: boolean
  }

  export type CampaignMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    tenant?: boolean | CampaignMessage$tenantArgs<ExtArgs>
  }
  export type CampaignMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    tenant?: boolean | CampaignMessage$tenantArgs<ExtArgs>
  }

  export type $CampaignMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignMessage"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      contactId: string
      contactPhone: string
      contactName: string
      status: string
      sentAt: Date | null
      deliveredAt: Date | null
      readAt: Date | null
      errorMessage: string | null
      messageId: string | null
      selectedVariation: string | null
      tenantId: string | null
      criadoEm: Date
      atualizadoEm: Date
      sessionName: string | null
    }, ExtArgs["result"]["campaignMessage"]>
    composites: {}
  }

  type CampaignMessageGetPayload<S extends boolean | null | undefined | CampaignMessageDefaultArgs> = $Result.GetResult<Prisma.$CampaignMessagePayload, S>

  type CampaignMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignMessageCountAggregateInputType | true
    }

  export interface CampaignMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignMessage'], meta: { name: 'CampaignMessage' } }
    /**
     * Find zero or one CampaignMessage that matches the filter.
     * @param {CampaignMessageFindUniqueArgs} args - Arguments to find a CampaignMessage
     * @example
     * // Get one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignMessageFindUniqueArgs>(args: SelectSubset<T, CampaignMessageFindUniqueArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignMessageFindUniqueOrThrowArgs} args - Arguments to find a CampaignMessage
     * @example
     * // Get one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageFindFirstArgs} args - Arguments to find a CampaignMessage
     * @example
     * // Get one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignMessageFindFirstArgs>(args?: SelectSubset<T, CampaignMessageFindFirstArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageFindFirstOrThrowArgs} args - Arguments to find a CampaignMessage
     * @example
     * // Get one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignMessages
     * const campaignMessages = await prisma.campaignMessage.findMany()
     * 
     * // Get first 10 CampaignMessages
     * const campaignMessages = await prisma.campaignMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignMessageWithIdOnly = await prisma.campaignMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignMessageFindManyArgs>(args?: SelectSubset<T, CampaignMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignMessage.
     * @param {CampaignMessageCreateArgs} args - Arguments to create a CampaignMessage.
     * @example
     * // Create one CampaignMessage
     * const CampaignMessage = await prisma.campaignMessage.create({
     *   data: {
     *     // ... data to create a CampaignMessage
     *   }
     * })
     * 
     */
    create<T extends CampaignMessageCreateArgs>(args: SelectSubset<T, CampaignMessageCreateArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignMessages.
     * @param {CampaignMessageCreateManyArgs} args - Arguments to create many CampaignMessages.
     * @example
     * // Create many CampaignMessages
     * const campaignMessage = await prisma.campaignMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignMessageCreateManyArgs>(args?: SelectSubset<T, CampaignMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignMessages and returns the data saved in the database.
     * @param {CampaignMessageCreateManyAndReturnArgs} args - Arguments to create many CampaignMessages.
     * @example
     * // Create many CampaignMessages
     * const campaignMessage = await prisma.campaignMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignMessages and only return the `id`
     * const campaignMessageWithIdOnly = await prisma.campaignMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignMessage.
     * @param {CampaignMessageDeleteArgs} args - Arguments to delete one CampaignMessage.
     * @example
     * // Delete one CampaignMessage
     * const CampaignMessage = await prisma.campaignMessage.delete({
     *   where: {
     *     // ... filter to delete one CampaignMessage
     *   }
     * })
     * 
     */
    delete<T extends CampaignMessageDeleteArgs>(args: SelectSubset<T, CampaignMessageDeleteArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignMessage.
     * @param {CampaignMessageUpdateArgs} args - Arguments to update one CampaignMessage.
     * @example
     * // Update one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignMessageUpdateArgs>(args: SelectSubset<T, CampaignMessageUpdateArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignMessages.
     * @param {CampaignMessageDeleteManyArgs} args - Arguments to filter CampaignMessages to delete.
     * @example
     * // Delete a few CampaignMessages
     * const { count } = await prisma.campaignMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignMessageDeleteManyArgs>(args?: SelectSubset<T, CampaignMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignMessages
     * const campaignMessage = await prisma.campaignMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignMessageUpdateManyArgs>(args: SelectSubset<T, CampaignMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignMessage.
     * @param {CampaignMessageUpsertArgs} args - Arguments to update or create a CampaignMessage.
     * @example
     * // Update or create a CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.upsert({
     *   create: {
     *     // ... data to create a CampaignMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignMessage we want to update
     *   }
     * })
     */
    upsert<T extends CampaignMessageUpsertArgs>(args: SelectSubset<T, CampaignMessageUpsertArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageCountArgs} args - Arguments to filter CampaignMessages to count.
     * @example
     * // Count the number of CampaignMessages
     * const count = await prisma.campaignMessage.count({
     *   where: {
     *     // ... the filter for the CampaignMessages we want to count
     *   }
     * })
    **/
    count<T extends CampaignMessageCountArgs>(
      args?: Subset<T, CampaignMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignMessageAggregateArgs>(args: Subset<T, CampaignMessageAggregateArgs>): Prisma.PrismaPromise<GetCampaignMessageAggregateType<T>>

    /**
     * Group by CampaignMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignMessageGroupByArgs['orderBy'] }
        : { orderBy?: CampaignMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignMessage model
   */
  readonly fields: CampaignMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tenant<T extends CampaignMessage$tenantArgs<ExtArgs> = {}>(args?: Subset<T, CampaignMessage$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignMessage model
   */ 
  interface CampaignMessageFieldRefs {
    readonly id: FieldRef<"CampaignMessage", 'String'>
    readonly campaignId: FieldRef<"CampaignMessage", 'String'>
    readonly contactId: FieldRef<"CampaignMessage", 'String'>
    readonly contactPhone: FieldRef<"CampaignMessage", 'String'>
    readonly contactName: FieldRef<"CampaignMessage", 'String'>
    readonly status: FieldRef<"CampaignMessage", 'String'>
    readonly sentAt: FieldRef<"CampaignMessage", 'DateTime'>
    readonly deliveredAt: FieldRef<"CampaignMessage", 'DateTime'>
    readonly readAt: FieldRef<"CampaignMessage", 'DateTime'>
    readonly errorMessage: FieldRef<"CampaignMessage", 'String'>
    readonly messageId: FieldRef<"CampaignMessage", 'String'>
    readonly selectedVariation: FieldRef<"CampaignMessage", 'String'>
    readonly tenantId: FieldRef<"CampaignMessage", 'String'>
    readonly criadoEm: FieldRef<"CampaignMessage", 'DateTime'>
    readonly atualizadoEm: FieldRef<"CampaignMessage", 'DateTime'>
    readonly sessionName: FieldRef<"CampaignMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CampaignMessage findUnique
   */
  export type CampaignMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessage to fetch.
     */
    where: CampaignMessageWhereUniqueInput
  }

  /**
   * CampaignMessage findUniqueOrThrow
   */
  export type CampaignMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessage to fetch.
     */
    where: CampaignMessageWhereUniqueInput
  }

  /**
   * CampaignMessage findFirst
   */
  export type CampaignMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessage to fetch.
     */
    where?: CampaignMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMessages to fetch.
     */
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMessages.
     */
    cursor?: CampaignMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMessages.
     */
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * CampaignMessage findFirstOrThrow
   */
  export type CampaignMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessage to fetch.
     */
    where?: CampaignMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMessages to fetch.
     */
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMessages.
     */
    cursor?: CampaignMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMessages.
     */
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * CampaignMessage findMany
   */
  export type CampaignMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessages to fetch.
     */
    where?: CampaignMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMessages to fetch.
     */
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignMessages.
     */
    cursor?: CampaignMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMessages.
     */
    skip?: number
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * CampaignMessage create
   */
  export type CampaignMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignMessage.
     */
    data: XOR<CampaignMessageCreateInput, CampaignMessageUncheckedCreateInput>
  }

  /**
   * CampaignMessage createMany
   */
  export type CampaignMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignMessages.
     */
    data: CampaignMessageCreateManyInput | CampaignMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignMessage createManyAndReturn
   */
  export type CampaignMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignMessages.
     */
    data: CampaignMessageCreateManyInput | CampaignMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignMessage update
   */
  export type CampaignMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignMessage.
     */
    data: XOR<CampaignMessageUpdateInput, CampaignMessageUncheckedUpdateInput>
    /**
     * Choose, which CampaignMessage to update.
     */
    where: CampaignMessageWhereUniqueInput
  }

  /**
   * CampaignMessage updateMany
   */
  export type CampaignMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignMessages.
     */
    data: XOR<CampaignMessageUpdateManyMutationInput, CampaignMessageUncheckedUpdateManyInput>
    /**
     * Filter which CampaignMessages to update
     */
    where?: CampaignMessageWhereInput
  }

  /**
   * CampaignMessage upsert
   */
  export type CampaignMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignMessage to update in case it exists.
     */
    where: CampaignMessageWhereUniqueInput
    /**
     * In case the CampaignMessage found by the `where` argument doesn't exist, create a new CampaignMessage with this data.
     */
    create: XOR<CampaignMessageCreateInput, CampaignMessageUncheckedCreateInput>
    /**
     * In case the CampaignMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignMessageUpdateInput, CampaignMessageUncheckedUpdateInput>
  }

  /**
   * CampaignMessage delete
   */
  export type CampaignMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter which CampaignMessage to delete.
     */
    where: CampaignMessageWhereUniqueInput
  }

  /**
   * CampaignMessage deleteMany
   */
  export type CampaignMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMessages to delete
     */
    where?: CampaignMessageWhereInput
  }

  /**
   * CampaignMessage.tenant
   */
  export type CampaignMessage$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * CampaignMessage without action
   */
  export type CampaignMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    nome: string | null
    email: string | null
    senha: string | null
    role: string | null
    ativo: boolean | null
    tenantId: string | null
    ultimoLogin: Date | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    email: string | null
    senha: string | null
    role: string | null
    ativo: boolean | null
    tenantId: string | null
    ultimoLogin: Date | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    senha: number
    role: number
    ativo: number
    tenantId: number
    ultimoLogin: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    role?: true
    ativo?: true
    tenantId?: true
    ultimoLogin?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    role?: true
    ativo?: true
    tenantId?: true
    ultimoLogin?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    role?: true
    ativo?: true
    tenantId?: true
    ultimoLogin?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    nome: string
    email: string
    senha: string
    role: string
    ativo: boolean
    tenantId: string | null
    ultimoLogin: Date | null
    criadoEm: Date
    atualizadoEm: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    role?: boolean
    ativo?: boolean
    tenantId?: boolean
    ultimoLogin?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
    tenants?: boolean | User$tenantsArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    userNotifications?: boolean | User$userNotificationsArgs<ExtArgs>
    createdTemplates?: boolean | User$createdTemplatesArgs<ExtArgs>
    createdFlows?: boolean | User$createdFlowsArgs<ExtArgs>
    createdIntegrations?: boolean | User$createdIntegrationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    role?: boolean
    ativo?: boolean
    tenantId?: boolean
    ultimoLogin?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    role?: boolean
    ativo?: boolean
    tenantId?: boolean
    ultimoLogin?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
    tenants?: boolean | User$tenantsArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    userNotifications?: boolean | User$userNotificationsArgs<ExtArgs>
    createdTemplates?: boolean | User$createdTemplatesArgs<ExtArgs>
    createdFlows?: boolean | User$createdFlowsArgs<ExtArgs>
    createdIntegrations?: boolean | User$createdIntegrationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      tenants: Prisma.$UserTenantPayload<ExtArgs>[]
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      userNotifications: Prisma.$UserNotificationPayload<ExtArgs>[]
      createdTemplates: Prisma.$MessageTemplatePayload<ExtArgs>[]
      createdFlows: Prisma.$AutomationFlowPayload<ExtArgs>[]
      createdIntegrations: Prisma.$IntegrationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      email: string
      senha: string
      role: string
      ativo: boolean
      tenantId: string | null
      ultimoLogin: Date | null
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends User$tenantArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tenants<T extends User$tenantsArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTenantPayload<ExtArgs>, T, "findMany"> | Null>
    alerts<T extends User$alertsArgs<ExtArgs> = {}>(args?: Subset<T, User$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    userNotifications<T extends User$userNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$userNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findMany"> | Null>
    createdTemplates<T extends User$createdTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    createdFlows<T extends User$createdFlowsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdFlowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "findMany"> | Null>
    createdIntegrations<T extends User$createdIntegrationsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdIntegrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly nome: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly senha: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly ativo: FieldRef<"User", 'Boolean'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly ultimoLogin: FieldRef<"User", 'DateTime'>
    readonly criadoEm: FieldRef<"User", 'DateTime'>
    readonly atualizadoEm: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.tenant
   */
  export type User$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * User.tenants
   */
  export type User$tenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenant
     */
    select?: UserTenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantInclude<ExtArgs> | null
    where?: UserTenantWhereInput
    orderBy?: UserTenantOrderByWithRelationInput | UserTenantOrderByWithRelationInput[]
    cursor?: UserTenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTenantScalarFieldEnum | UserTenantScalarFieldEnum[]
  }

  /**
   * User.alerts
   */
  export type User$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.userNotifications
   */
  export type User$userNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    where?: UserNotificationWhereInput
    orderBy?: UserNotificationOrderByWithRelationInput | UserNotificationOrderByWithRelationInput[]
    cursor?: UserNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserNotificationScalarFieldEnum | UserNotificationScalarFieldEnum[]
  }

  /**
   * User.createdTemplates
   */
  export type User$createdTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    where?: MessageTemplateWhereInput
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    cursor?: MessageTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * User.createdFlows
   */
  export type User$createdFlowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowInclude<ExtArgs> | null
    where?: AutomationFlowWhereInput
    orderBy?: AutomationFlowOrderByWithRelationInput | AutomationFlowOrderByWithRelationInput[]
    cursor?: AutomationFlowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationFlowScalarFieldEnum | AutomationFlowScalarFieldEnum[]
  }

  /**
   * User.createdIntegrations
   */
  export type User$createdIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    cursor?: IntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    type: $Enums.AlertType | null
    severity: $Enums.AlertSeverity | null
    title: string | null
    message: string | null
    tenantId: string | null
    userId: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    type: $Enums.AlertType | null
    severity: $Enums.AlertSeverity | null
    title: string | null
    message: string | null
    tenantId: string | null
    userId: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    type: number
    severity: number
    title: number
    message: number
    tenantId: number
    userId: number
    metadata: number
    resolved: number
    resolvedAt: number
    resolvedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    type?: true
    severity?: true
    title?: true
    message?: true
    tenantId?: true
    userId?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    type?: true
    severity?: true
    title?: true
    message?: true
    tenantId?: true
    userId?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    type?: true
    severity?: true
    title?: true
    message?: true
    tenantId?: true
    userId?: true
    metadata?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    title: string
    message: string
    tenantId: string | null
    userId: string | null
    metadata: JsonValue | null
    resolved: boolean
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    severity?: boolean
    title?: boolean
    message?: boolean
    tenantId?: boolean
    userId?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | Alert$tenantArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
    notifications?: boolean | Alert$notificationsArgs<ExtArgs>
    _count?: boolean | AlertCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    severity?: boolean
    title?: boolean
    message?: boolean
    tenantId?: boolean
    userId?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | Alert$tenantArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    type?: boolean
    severity?: boolean
    title?: boolean
    message?: boolean
    tenantId?: boolean
    userId?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Alert$tenantArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
    notifications?: boolean | Alert$notificationsArgs<ExtArgs>
    _count?: boolean | AlertCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Alert$tenantArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.AlertType
      severity: $Enums.AlertSeverity
      title: string
      message: string
      tenantId: string | null
      userId: string | null
      metadata: Prisma.JsonValue | null
      resolved: boolean
      resolvedAt: Date | null
      resolvedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends Alert$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Alert$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends Alert$userArgs<ExtArgs> = {}>(args?: Subset<T, Alert$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends Alert$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Alert$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */ 
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly type: FieldRef<"Alert", 'AlertType'>
    readonly severity: FieldRef<"Alert", 'AlertSeverity'>
    readonly title: FieldRef<"Alert", 'String'>
    readonly message: FieldRef<"Alert", 'String'>
    readonly tenantId: FieldRef<"Alert", 'String'>
    readonly userId: FieldRef<"Alert", 'String'>
    readonly metadata: FieldRef<"Alert", 'Json'>
    readonly resolved: FieldRef<"Alert", 'Boolean'>
    readonly resolvedAt: FieldRef<"Alert", 'DateTime'>
    readonly resolvedBy: FieldRef<"Alert", 'String'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
    readonly updatedAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
  }

  /**
   * Alert.tenant
   */
  export type Alert$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Alert.user
   */
  export type Alert$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Alert.notifications
   */
  export type Alert$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    alertId: string | null
    userId: string | null
    method: $Enums.NotificationMethod | null
    sent: boolean | null
    sentAt: Date | null
    read: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    alertId: string | null
    userId: string | null
    method: $Enums.NotificationMethod | null
    sent: boolean | null
    sentAt: Date | null
    read: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    alertId: number
    userId: number
    method: number
    sent: number
    sentAt: number
    read: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    alertId?: true
    userId?: true
    method?: true
    sent?: true
    sentAt?: true
    read?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    alertId?: true
    userId?: true
    method?: true
    sent?: true
    sentAt?: true
    read?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    alertId?: true
    userId?: true
    method?: true
    sent?: true
    sentAt?: true
    read?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    alertId: string
    userId: string
    method: $Enums.NotificationMethod
    sent: boolean
    sentAt: Date | null
    read: boolean
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    userId?: boolean
    method?: boolean
    sent?: boolean
    sentAt?: boolean
    read?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alert?: boolean | AlertDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    userId?: boolean
    method?: boolean
    sent?: boolean
    sentAt?: boolean
    read?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alert?: boolean | AlertDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    alertId?: boolean
    userId?: boolean
    method?: boolean
    sent?: boolean
    sentAt?: boolean
    read?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | AlertDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | AlertDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      alert: Prisma.$AlertPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alertId: string
      userId: string
      method: $Enums.NotificationMethod
      sent: boolean
      sentAt: Date | null
      read: boolean
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alert<T extends AlertDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlertDefaultArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly alertId: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly method: FieldRef<"Notification", 'NotificationMethod'>
    readonly sent: FieldRef<"Notification", 'Boolean'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model UserNotification
   */

  export type AggregateUserNotification = {
    _count: UserNotificationCountAggregateOutputType | null
    _min: UserNotificationMinAggregateOutputType | null
    _max: UserNotificationMaxAggregateOutputType | null
  }

  export type UserNotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: $Enums.UserNotificationType | null
    read: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserNotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: $Enums.UserNotificationType | null
    read: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserNotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    data: number
    read: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserNotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserNotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserNotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    data?: true
    read?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotification to aggregate.
     */
    where?: UserNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotifications to fetch.
     */
    orderBy?: UserNotificationOrderByWithRelationInput | UserNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNotifications
    **/
    _count?: true | UserNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNotificationMaxAggregateInputType
  }

  export type GetUserNotificationAggregateType<T extends UserNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNotification[P]>
      : GetScalarType<T[P], AggregateUserNotification[P]>
  }




  export type UserNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNotificationWhereInput
    orderBy?: UserNotificationOrderByWithAggregationInput | UserNotificationOrderByWithAggregationInput[]
    by: UserNotificationScalarFieldEnum[] | UserNotificationScalarFieldEnum
    having?: UserNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNotificationCountAggregateInputType | true
    _min?: UserNotificationMinAggregateInputType
    _max?: UserNotificationMaxAggregateInputType
  }

  export type UserNotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: $Enums.UserNotificationType
    data: JsonValue | null
    read: boolean
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserNotificationCountAggregateOutputType | null
    _min: UserNotificationMinAggregateOutputType | null
    _max: UserNotificationMaxAggregateOutputType | null
  }

  type GetUserNotificationGroupByPayload<T extends UserNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], UserNotificationGroupByOutputType[P]>
        }
      >
    >


  export type UserNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    data?: boolean
    read?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNotification"]>

  export type UserNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    data?: boolean
    read?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNotification"]>

  export type UserNotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    data?: boolean
    read?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserNotification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: $Enums.UserNotificationType
      data: Prisma.JsonValue | null
      read: boolean
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userNotification"]>
    composites: {}
  }

  type UserNotificationGetPayload<S extends boolean | null | undefined | UserNotificationDefaultArgs> = $Result.GetResult<Prisma.$UserNotificationPayload, S>

  type UserNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserNotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserNotificationCountAggregateInputType | true
    }

  export interface UserNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserNotification'], meta: { name: 'UserNotification' } }
    /**
     * Find zero or one UserNotification that matches the filter.
     * @param {UserNotificationFindUniqueArgs} args - Arguments to find a UserNotification
     * @example
     * // Get one UserNotification
     * const userNotification = await prisma.userNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserNotificationFindUniqueArgs>(args: SelectSubset<T, UserNotificationFindUniqueArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserNotification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserNotificationFindUniqueOrThrowArgs} args - Arguments to find a UserNotification
     * @example
     * // Get one UserNotification
     * const userNotification = await prisma.userNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationFindFirstArgs} args - Arguments to find a UserNotification
     * @example
     * // Get one UserNotification
     * const userNotification = await prisma.userNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserNotificationFindFirstArgs>(args?: SelectSubset<T, UserNotificationFindFirstArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationFindFirstOrThrowArgs} args - Arguments to find a UserNotification
     * @example
     * // Get one UserNotification
     * const userNotification = await prisma.userNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNotifications
     * const userNotifications = await prisma.userNotification.findMany()
     * 
     * // Get first 10 UserNotifications
     * const userNotifications = await prisma.userNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNotificationWithIdOnly = await prisma.userNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserNotificationFindManyArgs>(args?: SelectSubset<T, UserNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserNotification.
     * @param {UserNotificationCreateArgs} args - Arguments to create a UserNotification.
     * @example
     * // Create one UserNotification
     * const UserNotification = await prisma.userNotification.create({
     *   data: {
     *     // ... data to create a UserNotification
     *   }
     * })
     * 
     */
    create<T extends UserNotificationCreateArgs>(args: SelectSubset<T, UserNotificationCreateArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserNotifications.
     * @param {UserNotificationCreateManyArgs} args - Arguments to create many UserNotifications.
     * @example
     * // Create many UserNotifications
     * const userNotification = await prisma.userNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserNotificationCreateManyArgs>(args?: SelectSubset<T, UserNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserNotifications and returns the data saved in the database.
     * @param {UserNotificationCreateManyAndReturnArgs} args - Arguments to create many UserNotifications.
     * @example
     * // Create many UserNotifications
     * const userNotification = await prisma.userNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserNotifications and only return the `id`
     * const userNotificationWithIdOnly = await prisma.userNotification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserNotification.
     * @param {UserNotificationDeleteArgs} args - Arguments to delete one UserNotification.
     * @example
     * // Delete one UserNotification
     * const UserNotification = await prisma.userNotification.delete({
     *   where: {
     *     // ... filter to delete one UserNotification
     *   }
     * })
     * 
     */
    delete<T extends UserNotificationDeleteArgs>(args: SelectSubset<T, UserNotificationDeleteArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserNotification.
     * @param {UserNotificationUpdateArgs} args - Arguments to update one UserNotification.
     * @example
     * // Update one UserNotification
     * const userNotification = await prisma.userNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserNotificationUpdateArgs>(args: SelectSubset<T, UserNotificationUpdateArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserNotifications.
     * @param {UserNotificationDeleteManyArgs} args - Arguments to filter UserNotifications to delete.
     * @example
     * // Delete a few UserNotifications
     * const { count } = await prisma.userNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserNotificationDeleteManyArgs>(args?: SelectSubset<T, UserNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNotifications
     * const userNotification = await prisma.userNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserNotificationUpdateManyArgs>(args: SelectSubset<T, UserNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserNotification.
     * @param {UserNotificationUpsertArgs} args - Arguments to update or create a UserNotification.
     * @example
     * // Update or create a UserNotification
     * const userNotification = await prisma.userNotification.upsert({
     *   create: {
     *     // ... data to create a UserNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNotification we want to update
     *   }
     * })
     */
    upsert<T extends UserNotificationUpsertArgs>(args: SelectSubset<T, UserNotificationUpsertArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationCountArgs} args - Arguments to filter UserNotifications to count.
     * @example
     * // Count the number of UserNotifications
     * const count = await prisma.userNotification.count({
     *   where: {
     *     // ... the filter for the UserNotifications we want to count
     *   }
     * })
    **/
    count<T extends UserNotificationCountArgs>(
      args?: Subset<T, UserNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNotificationAggregateArgs>(args: Subset<T, UserNotificationAggregateArgs>): Prisma.PrismaPromise<GetUserNotificationAggregateType<T>>

    /**
     * Group by UserNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNotificationGroupByArgs['orderBy'] }
        : { orderBy?: UserNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserNotification model
   */
  readonly fields: UserNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserNotification model
   */ 
  interface UserNotificationFieldRefs {
    readonly id: FieldRef<"UserNotification", 'String'>
    readonly userId: FieldRef<"UserNotification", 'String'>
    readonly title: FieldRef<"UserNotification", 'String'>
    readonly message: FieldRef<"UserNotification", 'String'>
    readonly type: FieldRef<"UserNotification", 'UserNotificationType'>
    readonly data: FieldRef<"UserNotification", 'Json'>
    readonly read: FieldRef<"UserNotification", 'Boolean'>
    readonly readAt: FieldRef<"UserNotification", 'DateTime'>
    readonly createdAt: FieldRef<"UserNotification", 'DateTime'>
    readonly updatedAt: FieldRef<"UserNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserNotification findUnique
   */
  export type UserNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * Filter, which UserNotification to fetch.
     */
    where: UserNotificationWhereUniqueInput
  }

  /**
   * UserNotification findUniqueOrThrow
   */
  export type UserNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * Filter, which UserNotification to fetch.
     */
    where: UserNotificationWhereUniqueInput
  }

  /**
   * UserNotification findFirst
   */
  export type UserNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * Filter, which UserNotification to fetch.
     */
    where?: UserNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotifications to fetch.
     */
    orderBy?: UserNotificationOrderByWithRelationInput | UserNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotifications.
     */
    cursor?: UserNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotifications.
     */
    distinct?: UserNotificationScalarFieldEnum | UserNotificationScalarFieldEnum[]
  }

  /**
   * UserNotification findFirstOrThrow
   */
  export type UserNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * Filter, which UserNotification to fetch.
     */
    where?: UserNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotifications to fetch.
     */
    orderBy?: UserNotificationOrderByWithRelationInput | UserNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotifications.
     */
    cursor?: UserNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotifications.
     */
    distinct?: UserNotificationScalarFieldEnum | UserNotificationScalarFieldEnum[]
  }

  /**
   * UserNotification findMany
   */
  export type UserNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * Filter, which UserNotifications to fetch.
     */
    where?: UserNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotifications to fetch.
     */
    orderBy?: UserNotificationOrderByWithRelationInput | UserNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNotifications.
     */
    cursor?: UserNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotifications.
     */
    skip?: number
    distinct?: UserNotificationScalarFieldEnum | UserNotificationScalarFieldEnum[]
  }

  /**
   * UserNotification create
   */
  export type UserNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserNotification.
     */
    data: XOR<UserNotificationCreateInput, UserNotificationUncheckedCreateInput>
  }

  /**
   * UserNotification createMany
   */
  export type UserNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserNotifications.
     */
    data: UserNotificationCreateManyInput | UserNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserNotification createManyAndReturn
   */
  export type UserNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserNotifications.
     */
    data: UserNotificationCreateManyInput | UserNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserNotification update
   */
  export type UserNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserNotification.
     */
    data: XOR<UserNotificationUpdateInput, UserNotificationUncheckedUpdateInput>
    /**
     * Choose, which UserNotification to update.
     */
    where: UserNotificationWhereUniqueInput
  }

  /**
   * UserNotification updateMany
   */
  export type UserNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserNotifications.
     */
    data: XOR<UserNotificationUpdateManyMutationInput, UserNotificationUncheckedUpdateManyInput>
    /**
     * Filter which UserNotifications to update
     */
    where?: UserNotificationWhereInput
  }

  /**
   * UserNotification upsert
   */
  export type UserNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserNotification to update in case it exists.
     */
    where: UserNotificationWhereUniqueInput
    /**
     * In case the UserNotification found by the `where` argument doesn't exist, create a new UserNotification with this data.
     */
    create: XOR<UserNotificationCreateInput, UserNotificationUncheckedCreateInput>
    /**
     * In case the UserNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserNotificationUpdateInput, UserNotificationUncheckedUpdateInput>
  }

  /**
   * UserNotification delete
   */
  export type UserNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * Filter which UserNotification to delete.
     */
    where: UserNotificationWhereUniqueInput
  }

  /**
   * UserNotification deleteMany
   */
  export type UserNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotifications to delete
     */
    where?: UserNotificationWhereInput
  }

  /**
   * UserNotification without action
   */
  export type UserNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
  }


  /**
   * Model MessageTemplate
   */

  export type AggregateMessageTemplate = {
    _count: MessageTemplateCountAggregateOutputType | null
    _min: MessageTemplateMinAggregateOutputType | null
    _max: MessageTemplateMaxAggregateOutputType | null
  }

  export type MessageTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    tenantId: string | null
    category: string | null
    messageType: $Enums.MessageType | null
    content: string | null
    mediaUrl: string | null
    active: boolean | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    tenantId: string | null
    category: string | null
    messageType: $Enums.MessageType | null
    content: string | null
    mediaUrl: string | null
    active: boolean | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageTemplateCountAggregateOutputType = {
    id: number
    name: number
    tenantId: number
    category: number
    messageType: number
    content: number
    variables: number
    mediaUrl: number
    active: number
    tags: number
    description: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageTemplateMinAggregateInputType = {
    id?: true
    name?: true
    tenantId?: true
    category?: true
    messageType?: true
    content?: true
    mediaUrl?: true
    active?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    tenantId?: true
    category?: true
    messageType?: true
    content?: true
    mediaUrl?: true
    active?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageTemplateCountAggregateInputType = {
    id?: true
    name?: true
    tenantId?: true
    category?: true
    messageType?: true
    content?: true
    variables?: true
    mediaUrl?: true
    active?: true
    tags?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplate to aggregate.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageTemplates
    **/
    _count?: true | MessageTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageTemplateMaxAggregateInputType
  }

  export type GetMessageTemplateAggregateType<T extends MessageTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageTemplate[P]>
      : GetScalarType<T[P], AggregateMessageTemplate[P]>
  }




  export type MessageTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplateWhereInput
    orderBy?: MessageTemplateOrderByWithAggregationInput | MessageTemplateOrderByWithAggregationInput[]
    by: MessageTemplateScalarFieldEnum[] | MessageTemplateScalarFieldEnum
    having?: MessageTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageTemplateCountAggregateInputType | true
    _min?: MessageTemplateMinAggregateInputType
    _max?: MessageTemplateMaxAggregateInputType
  }

  export type MessageTemplateGroupByOutputType = {
    id: string
    name: string
    tenantId: string
    category: string
    messageType: $Enums.MessageType
    content: string
    variables: string[]
    mediaUrl: string | null
    active: boolean
    tags: string[]
    description: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: MessageTemplateCountAggregateOutputType | null
    _min: MessageTemplateMinAggregateOutputType | null
    _max: MessageTemplateMaxAggregateOutputType | null
  }

  type GetMessageTemplateGroupByPayload<T extends MessageTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], MessageTemplateGroupByOutputType[P]>
        }
      >
    >


  export type MessageTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tenantId?: boolean
    category?: boolean
    messageType?: boolean
    content?: boolean
    variables?: boolean
    mediaUrl?: boolean
    active?: boolean
    tags?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageTemplate"]>

  export type MessageTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tenantId?: boolean
    category?: boolean
    messageType?: boolean
    content?: boolean
    variables?: boolean
    mediaUrl?: boolean
    active?: boolean
    tags?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageTemplate"]>

  export type MessageTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    tenantId?: boolean
    category?: boolean
    messageType?: boolean
    content?: boolean
    variables?: boolean
    mediaUrl?: boolean
    active?: boolean
    tags?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageTemplate"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      tenantId: string
      category: string
      messageType: $Enums.MessageType
      content: string
      variables: string[]
      mediaUrl: string | null
      active: boolean
      tags: string[]
      description: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["messageTemplate"]>
    composites: {}
  }

  type MessageTemplateGetPayload<S extends boolean | null | undefined | MessageTemplateDefaultArgs> = $Result.GetResult<Prisma.$MessageTemplatePayload, S>

  type MessageTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageTemplateCountAggregateInputType | true
    }

  export interface MessageTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageTemplate'], meta: { name: 'MessageTemplate' } }
    /**
     * Find zero or one MessageTemplate that matches the filter.
     * @param {MessageTemplateFindUniqueArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageTemplateFindUniqueArgs>(args: SelectSubset<T, MessageTemplateFindUniqueArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageTemplateFindUniqueOrThrowArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindFirstArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageTemplateFindFirstArgs>(args?: SelectSubset<T, MessageTemplateFindFirstArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindFirstOrThrowArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageTemplates
     * const messageTemplates = await prisma.messageTemplate.findMany()
     * 
     * // Get first 10 MessageTemplates
     * const messageTemplates = await prisma.messageTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageTemplateFindManyArgs>(args?: SelectSubset<T, MessageTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageTemplate.
     * @param {MessageTemplateCreateArgs} args - Arguments to create a MessageTemplate.
     * @example
     * // Create one MessageTemplate
     * const MessageTemplate = await prisma.messageTemplate.create({
     *   data: {
     *     // ... data to create a MessageTemplate
     *   }
     * })
     * 
     */
    create<T extends MessageTemplateCreateArgs>(args: SelectSubset<T, MessageTemplateCreateArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageTemplates.
     * @param {MessageTemplateCreateManyArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageTemplateCreateManyArgs>(args?: SelectSubset<T, MessageTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageTemplates and returns the data saved in the database.
     * @param {MessageTemplateCreateManyAndReturnArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageTemplates and only return the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageTemplate.
     * @param {MessageTemplateDeleteArgs} args - Arguments to delete one MessageTemplate.
     * @example
     * // Delete one MessageTemplate
     * const MessageTemplate = await prisma.messageTemplate.delete({
     *   where: {
     *     // ... filter to delete one MessageTemplate
     *   }
     * })
     * 
     */
    delete<T extends MessageTemplateDeleteArgs>(args: SelectSubset<T, MessageTemplateDeleteArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageTemplate.
     * @param {MessageTemplateUpdateArgs} args - Arguments to update one MessageTemplate.
     * @example
     * // Update one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageTemplateUpdateArgs>(args: SelectSubset<T, MessageTemplateUpdateArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageTemplates.
     * @param {MessageTemplateDeleteManyArgs} args - Arguments to filter MessageTemplates to delete.
     * @example
     * // Delete a few MessageTemplates
     * const { count } = await prisma.messageTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageTemplateDeleteManyArgs>(args?: SelectSubset<T, MessageTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageTemplateUpdateManyArgs>(args: SelectSubset<T, MessageTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageTemplate.
     * @param {MessageTemplateUpsertArgs} args - Arguments to update or create a MessageTemplate.
     * @example
     * // Update or create a MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.upsert({
     *   create: {
     *     // ... data to create a MessageTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageTemplate we want to update
     *   }
     * })
     */
    upsert<T extends MessageTemplateUpsertArgs>(args: SelectSubset<T, MessageTemplateUpsertArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateCountArgs} args - Arguments to filter MessageTemplates to count.
     * @example
     * // Count the number of MessageTemplates
     * const count = await prisma.messageTemplate.count({
     *   where: {
     *     // ... the filter for the MessageTemplates we want to count
     *   }
     * })
    **/
    count<T extends MessageTemplateCountArgs>(
      args?: Subset<T, MessageTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageTemplateAggregateArgs>(args: Subset<T, MessageTemplateAggregateArgs>): Prisma.PrismaPromise<GetMessageTemplateAggregateType<T>>

    /**
     * Group by MessageTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageTemplateGroupByArgs['orderBy'] }
        : { orderBy?: MessageTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageTemplate model
   */
  readonly fields: MessageTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageTemplate model
   */ 
  interface MessageTemplateFieldRefs {
    readonly id: FieldRef<"MessageTemplate", 'String'>
    readonly name: FieldRef<"MessageTemplate", 'String'>
    readonly tenantId: FieldRef<"MessageTemplate", 'String'>
    readonly category: FieldRef<"MessageTemplate", 'String'>
    readonly messageType: FieldRef<"MessageTemplate", 'MessageType'>
    readonly content: FieldRef<"MessageTemplate", 'String'>
    readonly variables: FieldRef<"MessageTemplate", 'String[]'>
    readonly mediaUrl: FieldRef<"MessageTemplate", 'String'>
    readonly active: FieldRef<"MessageTemplate", 'Boolean'>
    readonly tags: FieldRef<"MessageTemplate", 'String[]'>
    readonly description: FieldRef<"MessageTemplate", 'String'>
    readonly createdBy: FieldRef<"MessageTemplate", 'String'>
    readonly createdAt: FieldRef<"MessageTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageTemplate findUnique
   */
  export type MessageTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate findUniqueOrThrow
   */
  export type MessageTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate findFirst
   */
  export type MessageTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate findFirstOrThrow
   */
  export type MessageTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate findMany
   */
  export type MessageTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MessageTemplates to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate create
   */
  export type MessageTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageTemplate.
     */
    data: XOR<MessageTemplateCreateInput, MessageTemplateUncheckedCreateInput>
  }

  /**
   * MessageTemplate createMany
   */
  export type MessageTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageTemplates.
     */
    data: MessageTemplateCreateManyInput | MessageTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageTemplate createManyAndReturn
   */
  export type MessageTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageTemplates.
     */
    data: MessageTemplateCreateManyInput | MessageTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageTemplate update
   */
  export type MessageTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageTemplate.
     */
    data: XOR<MessageTemplateUpdateInput, MessageTemplateUncheckedUpdateInput>
    /**
     * Choose, which MessageTemplate to update.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate updateMany
   */
  export type MessageTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageTemplates.
     */
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyInput>
    /**
     * Filter which MessageTemplates to update
     */
    where?: MessageTemplateWhereInput
  }

  /**
   * MessageTemplate upsert
   */
  export type MessageTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageTemplate to update in case it exists.
     */
    where: MessageTemplateWhereUniqueInput
    /**
     * In case the MessageTemplate found by the `where` argument doesn't exist, create a new MessageTemplate with this data.
     */
    create: XOR<MessageTemplateCreateInput, MessageTemplateUncheckedCreateInput>
    /**
     * In case the MessageTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageTemplateUpdateInput, MessageTemplateUncheckedUpdateInput>
  }

  /**
   * MessageTemplate delete
   */
  export type MessageTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
    /**
     * Filter which MessageTemplate to delete.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate deleteMany
   */
  export type MessageTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplates to delete
     */
    where?: MessageTemplateWhereInput
  }

  /**
   * MessageTemplate without action
   */
  export type MessageTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageTemplateInclude<ExtArgs> | null
  }


  /**
   * Model AutomationFlow
   */

  export type AggregateAutomationFlow = {
    _count: AutomationFlowCountAggregateOutputType | null
    _min: AutomationFlowMinAggregateOutputType | null
    _max: AutomationFlowMaxAggregateOutputType | null
  }

  export type AutomationFlowMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tenantId: string | null
    active: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationFlowMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tenantId: string | null
    active: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationFlowCountAggregateOutputType = {
    id: number
    name: number
    description: number
    tenantId: number
    active: number
    trigger: number
    conditions: number
    actions: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AutomationFlowMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    active?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationFlowMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    active?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationFlowCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    active?: true
    trigger?: true
    conditions?: true
    actions?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AutomationFlowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationFlow to aggregate.
     */
    where?: AutomationFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationFlows to fetch.
     */
    orderBy?: AutomationFlowOrderByWithRelationInput | AutomationFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationFlows
    **/
    _count?: true | AutomationFlowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationFlowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationFlowMaxAggregateInputType
  }

  export type GetAutomationFlowAggregateType<T extends AutomationFlowAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationFlow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationFlow[P]>
      : GetScalarType<T[P], AggregateAutomationFlow[P]>
  }




  export type AutomationFlowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationFlowWhereInput
    orderBy?: AutomationFlowOrderByWithAggregationInput | AutomationFlowOrderByWithAggregationInput[]
    by: AutomationFlowScalarFieldEnum[] | AutomationFlowScalarFieldEnum
    having?: AutomationFlowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationFlowCountAggregateInputType | true
    _min?: AutomationFlowMinAggregateInputType
    _max?: AutomationFlowMaxAggregateInputType
  }

  export type AutomationFlowGroupByOutputType = {
    id: string
    name: string
    description: string | null
    tenantId: string
    active: boolean
    trigger: JsonValue
    conditions: JsonValue | null
    actions: JsonValue
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: AutomationFlowCountAggregateOutputType | null
    _min: AutomationFlowMinAggregateOutputType | null
    _max: AutomationFlowMaxAggregateOutputType | null
  }

  type GetAutomationFlowGroupByPayload<T extends AutomationFlowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationFlowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationFlowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationFlowGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationFlowGroupByOutputType[P]>
        }
      >
    >


  export type AutomationFlowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    active?: boolean
    trigger?: boolean
    conditions?: boolean
    actions?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | AutomationFlow$executionsArgs<ExtArgs>
    _count?: boolean | AutomationFlowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationFlow"]>

  export type AutomationFlowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    active?: boolean
    trigger?: boolean
    conditions?: boolean
    actions?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationFlow"]>

  export type AutomationFlowSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    active?: boolean
    trigger?: boolean
    conditions?: boolean
    actions?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AutomationFlowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | AutomationFlow$executionsArgs<ExtArgs>
    _count?: boolean | AutomationFlowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AutomationFlowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AutomationFlowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationFlow"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      executions: Prisma.$AutomationExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      tenantId: string
      active: boolean
      trigger: Prisma.JsonValue
      conditions: Prisma.JsonValue | null
      actions: Prisma.JsonValue
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["automationFlow"]>
    composites: {}
  }

  type AutomationFlowGetPayload<S extends boolean | null | undefined | AutomationFlowDefaultArgs> = $Result.GetResult<Prisma.$AutomationFlowPayload, S>

  type AutomationFlowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutomationFlowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutomationFlowCountAggregateInputType | true
    }

  export interface AutomationFlowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationFlow'], meta: { name: 'AutomationFlow' } }
    /**
     * Find zero or one AutomationFlow that matches the filter.
     * @param {AutomationFlowFindUniqueArgs} args - Arguments to find a AutomationFlow
     * @example
     * // Get one AutomationFlow
     * const automationFlow = await prisma.automationFlow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationFlowFindUniqueArgs>(args: SelectSubset<T, AutomationFlowFindUniqueArgs<ExtArgs>>): Prisma__AutomationFlowClient<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutomationFlow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutomationFlowFindUniqueOrThrowArgs} args - Arguments to find a AutomationFlow
     * @example
     * // Get one AutomationFlow
     * const automationFlow = await prisma.automationFlow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationFlowFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationFlowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationFlowClient<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutomationFlow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFlowFindFirstArgs} args - Arguments to find a AutomationFlow
     * @example
     * // Get one AutomationFlow
     * const automationFlow = await prisma.automationFlow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationFlowFindFirstArgs>(args?: SelectSubset<T, AutomationFlowFindFirstArgs<ExtArgs>>): Prisma__AutomationFlowClient<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutomationFlow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFlowFindFirstOrThrowArgs} args - Arguments to find a AutomationFlow
     * @example
     * // Get one AutomationFlow
     * const automationFlow = await prisma.automationFlow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationFlowFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationFlowFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationFlowClient<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutomationFlows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFlowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationFlows
     * const automationFlows = await prisma.automationFlow.findMany()
     * 
     * // Get first 10 AutomationFlows
     * const automationFlows = await prisma.automationFlow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationFlowWithIdOnly = await prisma.automationFlow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationFlowFindManyArgs>(args?: SelectSubset<T, AutomationFlowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutomationFlow.
     * @param {AutomationFlowCreateArgs} args - Arguments to create a AutomationFlow.
     * @example
     * // Create one AutomationFlow
     * const AutomationFlow = await prisma.automationFlow.create({
     *   data: {
     *     // ... data to create a AutomationFlow
     *   }
     * })
     * 
     */
    create<T extends AutomationFlowCreateArgs>(args: SelectSubset<T, AutomationFlowCreateArgs<ExtArgs>>): Prisma__AutomationFlowClient<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutomationFlows.
     * @param {AutomationFlowCreateManyArgs} args - Arguments to create many AutomationFlows.
     * @example
     * // Create many AutomationFlows
     * const automationFlow = await prisma.automationFlow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationFlowCreateManyArgs>(args?: SelectSubset<T, AutomationFlowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationFlows and returns the data saved in the database.
     * @param {AutomationFlowCreateManyAndReturnArgs} args - Arguments to create many AutomationFlows.
     * @example
     * // Create many AutomationFlows
     * const automationFlow = await prisma.automationFlow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationFlows and only return the `id`
     * const automationFlowWithIdOnly = await prisma.automationFlow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationFlowCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationFlowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AutomationFlow.
     * @param {AutomationFlowDeleteArgs} args - Arguments to delete one AutomationFlow.
     * @example
     * // Delete one AutomationFlow
     * const AutomationFlow = await prisma.automationFlow.delete({
     *   where: {
     *     // ... filter to delete one AutomationFlow
     *   }
     * })
     * 
     */
    delete<T extends AutomationFlowDeleteArgs>(args: SelectSubset<T, AutomationFlowDeleteArgs<ExtArgs>>): Prisma__AutomationFlowClient<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutomationFlow.
     * @param {AutomationFlowUpdateArgs} args - Arguments to update one AutomationFlow.
     * @example
     * // Update one AutomationFlow
     * const automationFlow = await prisma.automationFlow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationFlowUpdateArgs>(args: SelectSubset<T, AutomationFlowUpdateArgs<ExtArgs>>): Prisma__AutomationFlowClient<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutomationFlows.
     * @param {AutomationFlowDeleteManyArgs} args - Arguments to filter AutomationFlows to delete.
     * @example
     * // Delete a few AutomationFlows
     * const { count } = await prisma.automationFlow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationFlowDeleteManyArgs>(args?: SelectSubset<T, AutomationFlowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationFlows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFlowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationFlows
     * const automationFlow = await prisma.automationFlow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationFlowUpdateManyArgs>(args: SelectSubset<T, AutomationFlowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutomationFlow.
     * @param {AutomationFlowUpsertArgs} args - Arguments to update or create a AutomationFlow.
     * @example
     * // Update or create a AutomationFlow
     * const automationFlow = await prisma.automationFlow.upsert({
     *   create: {
     *     // ... data to create a AutomationFlow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationFlow we want to update
     *   }
     * })
     */
    upsert<T extends AutomationFlowUpsertArgs>(args: SelectSubset<T, AutomationFlowUpsertArgs<ExtArgs>>): Prisma__AutomationFlowClient<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutomationFlows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFlowCountArgs} args - Arguments to filter AutomationFlows to count.
     * @example
     * // Count the number of AutomationFlows
     * const count = await prisma.automationFlow.count({
     *   where: {
     *     // ... the filter for the AutomationFlows we want to count
     *   }
     * })
    **/
    count<T extends AutomationFlowCountArgs>(
      args?: Subset<T, AutomationFlowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationFlowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationFlow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFlowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationFlowAggregateArgs>(args: Subset<T, AutomationFlowAggregateArgs>): Prisma.PrismaPromise<GetAutomationFlowAggregateType<T>>

    /**
     * Group by AutomationFlow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFlowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationFlowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationFlowGroupByArgs['orderBy'] }
        : { orderBy?: AutomationFlowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationFlowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationFlowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationFlow model
   */
  readonly fields: AutomationFlowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationFlow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationFlowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executions<T extends AutomationFlow$executionsArgs<ExtArgs> = {}>(args?: Subset<T, AutomationFlow$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationFlow model
   */ 
  interface AutomationFlowFieldRefs {
    readonly id: FieldRef<"AutomationFlow", 'String'>
    readonly name: FieldRef<"AutomationFlow", 'String'>
    readonly description: FieldRef<"AutomationFlow", 'String'>
    readonly tenantId: FieldRef<"AutomationFlow", 'String'>
    readonly active: FieldRef<"AutomationFlow", 'Boolean'>
    readonly trigger: FieldRef<"AutomationFlow", 'Json'>
    readonly conditions: FieldRef<"AutomationFlow", 'Json'>
    readonly actions: FieldRef<"AutomationFlow", 'Json'>
    readonly createdBy: FieldRef<"AutomationFlow", 'String'>
    readonly createdAt: FieldRef<"AutomationFlow", 'DateTime'>
    readonly updatedAt: FieldRef<"AutomationFlow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutomationFlow findUnique
   */
  export type AutomationFlowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowInclude<ExtArgs> | null
    /**
     * Filter, which AutomationFlow to fetch.
     */
    where: AutomationFlowWhereUniqueInput
  }

  /**
   * AutomationFlow findUniqueOrThrow
   */
  export type AutomationFlowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowInclude<ExtArgs> | null
    /**
     * Filter, which AutomationFlow to fetch.
     */
    where: AutomationFlowWhereUniqueInput
  }

  /**
   * AutomationFlow findFirst
   */
  export type AutomationFlowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowInclude<ExtArgs> | null
    /**
     * Filter, which AutomationFlow to fetch.
     */
    where?: AutomationFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationFlows to fetch.
     */
    orderBy?: AutomationFlowOrderByWithRelationInput | AutomationFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationFlows.
     */
    cursor?: AutomationFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationFlows.
     */
    distinct?: AutomationFlowScalarFieldEnum | AutomationFlowScalarFieldEnum[]
  }

  /**
   * AutomationFlow findFirstOrThrow
   */
  export type AutomationFlowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowInclude<ExtArgs> | null
    /**
     * Filter, which AutomationFlow to fetch.
     */
    where?: AutomationFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationFlows to fetch.
     */
    orderBy?: AutomationFlowOrderByWithRelationInput | AutomationFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationFlows.
     */
    cursor?: AutomationFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationFlows.
     */
    distinct?: AutomationFlowScalarFieldEnum | AutomationFlowScalarFieldEnum[]
  }

  /**
   * AutomationFlow findMany
   */
  export type AutomationFlowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowInclude<ExtArgs> | null
    /**
     * Filter, which AutomationFlows to fetch.
     */
    where?: AutomationFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationFlows to fetch.
     */
    orderBy?: AutomationFlowOrderByWithRelationInput | AutomationFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationFlows.
     */
    cursor?: AutomationFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationFlows.
     */
    skip?: number
    distinct?: AutomationFlowScalarFieldEnum | AutomationFlowScalarFieldEnum[]
  }

  /**
   * AutomationFlow create
   */
  export type AutomationFlowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationFlow.
     */
    data: XOR<AutomationFlowCreateInput, AutomationFlowUncheckedCreateInput>
  }

  /**
   * AutomationFlow createMany
   */
  export type AutomationFlowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationFlows.
     */
    data: AutomationFlowCreateManyInput | AutomationFlowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationFlow createManyAndReturn
   */
  export type AutomationFlowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AutomationFlows.
     */
    data: AutomationFlowCreateManyInput | AutomationFlowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationFlow update
   */
  export type AutomationFlowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationFlow.
     */
    data: XOR<AutomationFlowUpdateInput, AutomationFlowUncheckedUpdateInput>
    /**
     * Choose, which AutomationFlow to update.
     */
    where: AutomationFlowWhereUniqueInput
  }

  /**
   * AutomationFlow updateMany
   */
  export type AutomationFlowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationFlows.
     */
    data: XOR<AutomationFlowUpdateManyMutationInput, AutomationFlowUncheckedUpdateManyInput>
    /**
     * Filter which AutomationFlows to update
     */
    where?: AutomationFlowWhereInput
  }

  /**
   * AutomationFlow upsert
   */
  export type AutomationFlowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationFlow to update in case it exists.
     */
    where: AutomationFlowWhereUniqueInput
    /**
     * In case the AutomationFlow found by the `where` argument doesn't exist, create a new AutomationFlow with this data.
     */
    create: XOR<AutomationFlowCreateInput, AutomationFlowUncheckedCreateInput>
    /**
     * In case the AutomationFlow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationFlowUpdateInput, AutomationFlowUncheckedUpdateInput>
  }

  /**
   * AutomationFlow delete
   */
  export type AutomationFlowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowInclude<ExtArgs> | null
    /**
     * Filter which AutomationFlow to delete.
     */
    where: AutomationFlowWhereUniqueInput
  }

  /**
   * AutomationFlow deleteMany
   */
  export type AutomationFlowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationFlows to delete
     */
    where?: AutomationFlowWhereInput
  }

  /**
   * AutomationFlow.executions
   */
  export type AutomationFlow$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    where?: AutomationExecutionWhereInput
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    cursor?: AutomationExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * AutomationFlow without action
   */
  export type AutomationFlowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationFlow
     */
    select?: AutomationFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationFlowInclude<ExtArgs> | null
  }


  /**
   * Model AutomationExecution
   */

  export type AggregateAutomationExecution = {
    _count: AutomationExecutionCountAggregateOutputType | null
    _avg: AutomationExecutionAvgAggregateOutputType | null
    _sum: AutomationExecutionSumAggregateOutputType | null
    _min: AutomationExecutionMinAggregateOutputType | null
    _max: AutomationExecutionMaxAggregateOutputType | null
  }

  export type AutomationExecutionAvgAggregateOutputType = {
    duration: number | null
  }

  export type AutomationExecutionSumAggregateOutputType = {
    duration: number | null
  }

  export type AutomationExecutionMinAggregateOutputType = {
    id: string | null
    flowId: string | null
    status: string | null
    executedAt: Date | null
    error: string | null
    duration: number | null
  }

  export type AutomationExecutionMaxAggregateOutputType = {
    id: string | null
    flowId: string | null
    status: string | null
    executedAt: Date | null
    error: string | null
    duration: number | null
  }

  export type AutomationExecutionCountAggregateOutputType = {
    id: number
    flowId: number
    status: number
    executedAt: number
    context: number
    error: number
    duration: number
    _all: number
  }


  export type AutomationExecutionAvgAggregateInputType = {
    duration?: true
  }

  export type AutomationExecutionSumAggregateInputType = {
    duration?: true
  }

  export type AutomationExecutionMinAggregateInputType = {
    id?: true
    flowId?: true
    status?: true
    executedAt?: true
    error?: true
    duration?: true
  }

  export type AutomationExecutionMaxAggregateInputType = {
    id?: true
    flowId?: true
    status?: true
    executedAt?: true
    error?: true
    duration?: true
  }

  export type AutomationExecutionCountAggregateInputType = {
    id?: true
    flowId?: true
    status?: true
    executedAt?: true
    context?: true
    error?: true
    duration?: true
    _all?: true
  }

  export type AutomationExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationExecution to aggregate.
     */
    where?: AutomationExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationExecutions to fetch.
     */
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationExecutions
    **/
    _count?: true | AutomationExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationExecutionMaxAggregateInputType
  }

  export type GetAutomationExecutionAggregateType<T extends AutomationExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationExecution[P]>
      : GetScalarType<T[P], AggregateAutomationExecution[P]>
  }




  export type AutomationExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationExecutionWhereInput
    orderBy?: AutomationExecutionOrderByWithAggregationInput | AutomationExecutionOrderByWithAggregationInput[]
    by: AutomationExecutionScalarFieldEnum[] | AutomationExecutionScalarFieldEnum
    having?: AutomationExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationExecutionCountAggregateInputType | true
    _avg?: AutomationExecutionAvgAggregateInputType
    _sum?: AutomationExecutionSumAggregateInputType
    _min?: AutomationExecutionMinAggregateInputType
    _max?: AutomationExecutionMaxAggregateInputType
  }

  export type AutomationExecutionGroupByOutputType = {
    id: string
    flowId: string
    status: string
    executedAt: Date
    context: JsonValue | null
    error: string | null
    duration: number | null
    _count: AutomationExecutionCountAggregateOutputType | null
    _avg: AutomationExecutionAvgAggregateOutputType | null
    _sum: AutomationExecutionSumAggregateOutputType | null
    _min: AutomationExecutionMinAggregateOutputType | null
    _max: AutomationExecutionMaxAggregateOutputType | null
  }

  type GetAutomationExecutionGroupByPayload<T extends AutomationExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationExecutionGroupByOutputType[P]>
        }
      >
    >


  export type AutomationExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    status?: boolean
    executedAt?: boolean
    context?: boolean
    error?: boolean
    duration?: boolean
    flow?: boolean | AutomationFlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationExecution"]>

  export type AutomationExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    status?: boolean
    executedAt?: boolean
    context?: boolean
    error?: boolean
    duration?: boolean
    flow?: boolean | AutomationFlowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationExecution"]>

  export type AutomationExecutionSelectScalar = {
    id?: boolean
    flowId?: boolean
    status?: boolean
    executedAt?: boolean
    context?: boolean
    error?: boolean
    duration?: boolean
  }

  export type AutomationExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | AutomationFlowDefaultArgs<ExtArgs>
  }
  export type AutomationExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flow?: boolean | AutomationFlowDefaultArgs<ExtArgs>
  }

  export type $AutomationExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationExecution"
    objects: {
      flow: Prisma.$AutomationFlowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flowId: string
      status: string
      executedAt: Date
      context: Prisma.JsonValue | null
      error: string | null
      duration: number | null
    }, ExtArgs["result"]["automationExecution"]>
    composites: {}
  }

  type AutomationExecutionGetPayload<S extends boolean | null | undefined | AutomationExecutionDefaultArgs> = $Result.GetResult<Prisma.$AutomationExecutionPayload, S>

  type AutomationExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutomationExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutomationExecutionCountAggregateInputType | true
    }

  export interface AutomationExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationExecution'], meta: { name: 'AutomationExecution' } }
    /**
     * Find zero or one AutomationExecution that matches the filter.
     * @param {AutomationExecutionFindUniqueArgs} args - Arguments to find a AutomationExecution
     * @example
     * // Get one AutomationExecution
     * const automationExecution = await prisma.automationExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationExecutionFindUniqueArgs>(args: SelectSubset<T, AutomationExecutionFindUniqueArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutomationExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutomationExecutionFindUniqueOrThrowArgs} args - Arguments to find a AutomationExecution
     * @example
     * // Get one AutomationExecution
     * const automationExecution = await prisma.automationExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutomationExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionFindFirstArgs} args - Arguments to find a AutomationExecution
     * @example
     * // Get one AutomationExecution
     * const automationExecution = await prisma.automationExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationExecutionFindFirstArgs>(args?: SelectSubset<T, AutomationExecutionFindFirstArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutomationExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionFindFirstOrThrowArgs} args - Arguments to find a AutomationExecution
     * @example
     * // Get one AutomationExecution
     * const automationExecution = await prisma.automationExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutomationExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationExecutions
     * const automationExecutions = await prisma.automationExecution.findMany()
     * 
     * // Get first 10 AutomationExecutions
     * const automationExecutions = await prisma.automationExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationExecutionWithIdOnly = await prisma.automationExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationExecutionFindManyArgs>(args?: SelectSubset<T, AutomationExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutomationExecution.
     * @param {AutomationExecutionCreateArgs} args - Arguments to create a AutomationExecution.
     * @example
     * // Create one AutomationExecution
     * const AutomationExecution = await prisma.automationExecution.create({
     *   data: {
     *     // ... data to create a AutomationExecution
     *   }
     * })
     * 
     */
    create<T extends AutomationExecutionCreateArgs>(args: SelectSubset<T, AutomationExecutionCreateArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutomationExecutions.
     * @param {AutomationExecutionCreateManyArgs} args - Arguments to create many AutomationExecutions.
     * @example
     * // Create many AutomationExecutions
     * const automationExecution = await prisma.automationExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationExecutionCreateManyArgs>(args?: SelectSubset<T, AutomationExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationExecutions and returns the data saved in the database.
     * @param {AutomationExecutionCreateManyAndReturnArgs} args - Arguments to create many AutomationExecutions.
     * @example
     * // Create many AutomationExecutions
     * const automationExecution = await prisma.automationExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationExecutions and only return the `id`
     * const automationExecutionWithIdOnly = await prisma.automationExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AutomationExecution.
     * @param {AutomationExecutionDeleteArgs} args - Arguments to delete one AutomationExecution.
     * @example
     * // Delete one AutomationExecution
     * const AutomationExecution = await prisma.automationExecution.delete({
     *   where: {
     *     // ... filter to delete one AutomationExecution
     *   }
     * })
     * 
     */
    delete<T extends AutomationExecutionDeleteArgs>(args: SelectSubset<T, AutomationExecutionDeleteArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutomationExecution.
     * @param {AutomationExecutionUpdateArgs} args - Arguments to update one AutomationExecution.
     * @example
     * // Update one AutomationExecution
     * const automationExecution = await prisma.automationExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationExecutionUpdateArgs>(args: SelectSubset<T, AutomationExecutionUpdateArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutomationExecutions.
     * @param {AutomationExecutionDeleteManyArgs} args - Arguments to filter AutomationExecutions to delete.
     * @example
     * // Delete a few AutomationExecutions
     * const { count } = await prisma.automationExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationExecutionDeleteManyArgs>(args?: SelectSubset<T, AutomationExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationExecutions
     * const automationExecution = await prisma.automationExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationExecutionUpdateManyArgs>(args: SelectSubset<T, AutomationExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutomationExecution.
     * @param {AutomationExecutionUpsertArgs} args - Arguments to update or create a AutomationExecution.
     * @example
     * // Update or create a AutomationExecution
     * const automationExecution = await prisma.automationExecution.upsert({
     *   create: {
     *     // ... data to create a AutomationExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationExecution we want to update
     *   }
     * })
     */
    upsert<T extends AutomationExecutionUpsertArgs>(args: SelectSubset<T, AutomationExecutionUpsertArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutomationExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionCountArgs} args - Arguments to filter AutomationExecutions to count.
     * @example
     * // Count the number of AutomationExecutions
     * const count = await prisma.automationExecution.count({
     *   where: {
     *     // ... the filter for the AutomationExecutions we want to count
     *   }
     * })
    **/
    count<T extends AutomationExecutionCountArgs>(
      args?: Subset<T, AutomationExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationExecutionAggregateArgs>(args: Subset<T, AutomationExecutionAggregateArgs>): Prisma.PrismaPromise<GetAutomationExecutionAggregateType<T>>

    /**
     * Group by AutomationExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationExecutionGroupByArgs['orderBy'] }
        : { orderBy?: AutomationExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationExecution model
   */
  readonly fields: AutomationExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flow<T extends AutomationFlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationFlowDefaultArgs<ExtArgs>>): Prisma__AutomationFlowClient<$Result.GetResult<Prisma.$AutomationFlowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationExecution model
   */ 
  interface AutomationExecutionFieldRefs {
    readonly id: FieldRef<"AutomationExecution", 'String'>
    readonly flowId: FieldRef<"AutomationExecution", 'String'>
    readonly status: FieldRef<"AutomationExecution", 'String'>
    readonly executedAt: FieldRef<"AutomationExecution", 'DateTime'>
    readonly context: FieldRef<"AutomationExecution", 'Json'>
    readonly error: FieldRef<"AutomationExecution", 'String'>
    readonly duration: FieldRef<"AutomationExecution", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AutomationExecution findUnique
   */
  export type AutomationExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecution to fetch.
     */
    where: AutomationExecutionWhereUniqueInput
  }

  /**
   * AutomationExecution findUniqueOrThrow
   */
  export type AutomationExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecution to fetch.
     */
    where: AutomationExecutionWhereUniqueInput
  }

  /**
   * AutomationExecution findFirst
   */
  export type AutomationExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecution to fetch.
     */
    where?: AutomationExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationExecutions to fetch.
     */
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationExecutions.
     */
    cursor?: AutomationExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationExecutions.
     */
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * AutomationExecution findFirstOrThrow
   */
  export type AutomationExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecution to fetch.
     */
    where?: AutomationExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationExecutions to fetch.
     */
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationExecutions.
     */
    cursor?: AutomationExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationExecutions.
     */
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * AutomationExecution findMany
   */
  export type AutomationExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecutions to fetch.
     */
    where?: AutomationExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationExecutions to fetch.
     */
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationExecutions.
     */
    cursor?: AutomationExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationExecutions.
     */
    skip?: number
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * AutomationExecution create
   */
  export type AutomationExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationExecution.
     */
    data: XOR<AutomationExecutionCreateInput, AutomationExecutionUncheckedCreateInput>
  }

  /**
   * AutomationExecution createMany
   */
  export type AutomationExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationExecutions.
     */
    data: AutomationExecutionCreateManyInput | AutomationExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationExecution createManyAndReturn
   */
  export type AutomationExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AutomationExecutions.
     */
    data: AutomationExecutionCreateManyInput | AutomationExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationExecution update
   */
  export type AutomationExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationExecution.
     */
    data: XOR<AutomationExecutionUpdateInput, AutomationExecutionUncheckedUpdateInput>
    /**
     * Choose, which AutomationExecution to update.
     */
    where: AutomationExecutionWhereUniqueInput
  }

  /**
   * AutomationExecution updateMany
   */
  export type AutomationExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationExecutions.
     */
    data: XOR<AutomationExecutionUpdateManyMutationInput, AutomationExecutionUncheckedUpdateManyInput>
    /**
     * Filter which AutomationExecutions to update
     */
    where?: AutomationExecutionWhereInput
  }

  /**
   * AutomationExecution upsert
   */
  export type AutomationExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationExecution to update in case it exists.
     */
    where: AutomationExecutionWhereUniqueInput
    /**
     * In case the AutomationExecution found by the `where` argument doesn't exist, create a new AutomationExecution with this data.
     */
    create: XOR<AutomationExecutionCreateInput, AutomationExecutionUncheckedCreateInput>
    /**
     * In case the AutomationExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationExecutionUpdateInput, AutomationExecutionUncheckedUpdateInput>
  }

  /**
   * AutomationExecution delete
   */
  export type AutomationExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter which AutomationExecution to delete.
     */
    where: AutomationExecutionWhereUniqueInput
  }

  /**
   * AutomationExecution deleteMany
   */
  export type AutomationExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationExecutions to delete
     */
    where?: AutomationExecutionWhereInput
  }

  /**
   * AutomationExecution without action
   */
  export type AutomationExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
  }


  /**
   * Model Integration
   */

  export type AggregateIntegration = {
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  export type IntegrationMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.IntegrationType | null
    tenantId: string | null
    active: boolean | null
    webhookUrl: string | null
    lastSyncAt: Date | null
    lastError: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.IntegrationType | null
    tenantId: string | null
    active: boolean | null
    webhookUrl: string | null
    lastSyncAt: Date | null
    lastError: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCountAggregateOutputType = {
    id: number
    name: number
    type: number
    tenantId: number
    active: number
    config: number
    credentials: number
    webhookUrl: number
    lastSyncAt: number
    lastError: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegrationMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    tenantId?: true
    active?: true
    webhookUrl?: true
    lastSyncAt?: true
    lastError?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    tenantId?: true
    active?: true
    webhookUrl?: true
    lastSyncAt?: true
    lastError?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    tenantId?: true
    active?: true
    config?: true
    credentials?: true
    webhookUrl?: true
    lastSyncAt?: true
    lastError?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integration to aggregate.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrations
    **/
    _count?: true | IntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMaxAggregateInputType
  }

  export type GetIntegrationAggregateType<T extends IntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration[P]>
      : GetScalarType<T[P], AggregateIntegration[P]>
  }




  export type IntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithAggregationInput | IntegrationOrderByWithAggregationInput[]
    by: IntegrationScalarFieldEnum[] | IntegrationScalarFieldEnum
    having?: IntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCountAggregateInputType | true
    _min?: IntegrationMinAggregateInputType
    _max?: IntegrationMaxAggregateInputType
  }

  export type IntegrationGroupByOutputType = {
    id: string
    name: string
    type: $Enums.IntegrationType
    tenantId: string
    active: boolean
    config: JsonValue
    credentials: JsonValue | null
    webhookUrl: string | null
    lastSyncAt: Date | null
    lastError: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  type GetIntegrationGroupByPayload<T extends IntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    tenantId?: boolean
    active?: boolean
    config?: boolean
    credentials?: boolean
    webhookUrl?: boolean
    lastSyncAt?: boolean
    lastError?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    syncLogs?: boolean | Integration$syncLogsArgs<ExtArgs>
    _count?: boolean | IntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    tenantId?: boolean
    active?: boolean
    config?: boolean
    credentials?: boolean
    webhookUrl?: boolean
    lastSyncAt?: boolean
    lastError?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    tenantId?: boolean
    active?: boolean
    config?: boolean
    credentials?: boolean
    webhookUrl?: boolean
    lastSyncAt?: boolean
    lastError?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    syncLogs?: boolean | Integration$syncLogsArgs<ExtArgs>
    _count?: boolean | IntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integration"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      syncLogs: Prisma.$IntegrationSyncPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.IntegrationType
      tenantId: string
      active: boolean
      config: Prisma.JsonValue
      credentials: Prisma.JsonValue | null
      webhookUrl: string | null
      lastSyncAt: Date | null
      lastError: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integration"]>
    composites: {}
  }

  type IntegrationGetPayload<S extends boolean | null | undefined | IntegrationDefaultArgs> = $Result.GetResult<Prisma.$IntegrationPayload, S>

  type IntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntegrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntegrationCountAggregateInputType | true
    }

  export interface IntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integration'], meta: { name: 'Integration' } }
    /**
     * Find zero or one Integration that matches the filter.
     * @param {IntegrationFindUniqueArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationFindUniqueArgs>(args: SelectSubset<T, IntegrationFindUniqueArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Integration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntegrationFindUniqueOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Integration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationFindFirstArgs>(args?: SelectSubset<T, IntegrationFindFirstArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Integration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integration.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationWithIdOnly = await prisma.integration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationFindManyArgs>(args?: SelectSubset<T, IntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Integration.
     * @param {IntegrationCreateArgs} args - Arguments to create a Integration.
     * @example
     * // Create one Integration
     * const Integration = await prisma.integration.create({
     *   data: {
     *     // ... data to create a Integration
     *   }
     * })
     * 
     */
    create<T extends IntegrationCreateArgs>(args: SelectSubset<T, IntegrationCreateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Integrations.
     * @param {IntegrationCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationCreateManyArgs>(args?: SelectSubset<T, IntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrations and returns the data saved in the database.
     * @param {IntegrationCreateManyAndReturnArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Integration.
     * @param {IntegrationDeleteArgs} args - Arguments to delete one Integration.
     * @example
     * // Delete one Integration
     * const Integration = await prisma.integration.delete({
     *   where: {
     *     // ... filter to delete one Integration
     *   }
     * })
     * 
     */
    delete<T extends IntegrationDeleteArgs>(args: SelectSubset<T, IntegrationDeleteArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Integration.
     * @param {IntegrationUpdateArgs} args - Arguments to update one Integration.
     * @example
     * // Update one Integration
     * const integration = await prisma.integration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationUpdateArgs>(args: SelectSubset<T, IntegrationUpdateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Integrations.
     * @param {IntegrationDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationDeleteManyArgs>(args?: SelectSubset<T, IntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationUpdateManyArgs>(args: SelectSubset<T, IntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Integration.
     * @param {IntegrationUpsertArgs} args - Arguments to update or create a Integration.
     * @example
     * // Update or create a Integration
     * const integration = await prisma.integration.upsert({
     *   create: {
     *     // ... data to create a Integration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationUpsertArgs>(args: SelectSubset<T, IntegrationUpsertArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integration.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCountArgs>(
      args?: Subset<T, IntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationAggregateArgs>(args: Subset<T, IntegrationAggregateArgs>): Prisma.PrismaPromise<GetIntegrationAggregateType<T>>

    /**
     * Group by Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integration model
   */
  readonly fields: IntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    syncLogs<T extends Integration$syncLogsArgs<ExtArgs> = {}>(args?: Subset<T, Integration$syncLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationSyncPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integration model
   */ 
  interface IntegrationFieldRefs {
    readonly id: FieldRef<"Integration", 'String'>
    readonly name: FieldRef<"Integration", 'String'>
    readonly type: FieldRef<"Integration", 'IntegrationType'>
    readonly tenantId: FieldRef<"Integration", 'String'>
    readonly active: FieldRef<"Integration", 'Boolean'>
    readonly config: FieldRef<"Integration", 'Json'>
    readonly credentials: FieldRef<"Integration", 'Json'>
    readonly webhookUrl: FieldRef<"Integration", 'String'>
    readonly lastSyncAt: FieldRef<"Integration", 'DateTime'>
    readonly lastError: FieldRef<"Integration", 'String'>
    readonly createdBy: FieldRef<"Integration", 'String'>
    readonly createdAt: FieldRef<"Integration", 'DateTime'>
    readonly updatedAt: FieldRef<"Integration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Integration findUnique
   */
  export type IntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findUniqueOrThrow
   */
  export type IntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findFirst
   */
  export type IntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findFirstOrThrow
   */
  export type IntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findMany
   */
  export type IntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration create
   */
  export type IntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a Integration.
     */
    data: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
  }

  /**
   * Integration createMany
   */
  export type IntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integration createManyAndReturn
   */
  export type IntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration update
   */
  export type IntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a Integration.
     */
    data: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
    /**
     * Choose, which Integration to update.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration updateMany
   */
  export type IntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
  }

  /**
   * Integration upsert
   */
  export type IntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the Integration to update in case it exists.
     */
    where: IntegrationWhereUniqueInput
    /**
     * In case the Integration found by the `where` argument doesn't exist, create a new Integration with this data.
     */
    create: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
    /**
     * In case the Integration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
  }

  /**
   * Integration delete
   */
  export type IntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter which Integration to delete.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration deleteMany
   */
  export type IntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to delete
     */
    where?: IntegrationWhereInput
  }

  /**
   * Integration.syncLogs
   */
  export type Integration$syncLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSync
     */
    select?: IntegrationSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSyncInclude<ExtArgs> | null
    where?: IntegrationSyncWhereInput
    orderBy?: IntegrationSyncOrderByWithRelationInput | IntegrationSyncOrderByWithRelationInput[]
    cursor?: IntegrationSyncWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationSyncScalarFieldEnum | IntegrationSyncScalarFieldEnum[]
  }

  /**
   * Integration without action
   */
  export type IntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
  }


  /**
   * Model IntegrationSync
   */

  export type AggregateIntegrationSync = {
    _count: IntegrationSyncCountAggregateOutputType | null
    _avg: IntegrationSyncAvgAggregateOutputType | null
    _sum: IntegrationSyncSumAggregateOutputType | null
    _min: IntegrationSyncMinAggregateOutputType | null
    _max: IntegrationSyncMaxAggregateOutputType | null
  }

  export type IntegrationSyncAvgAggregateOutputType = {
    recordsCount: number | null
  }

  export type IntegrationSyncSumAggregateOutputType = {
    recordsCount: number | null
  }

  export type IntegrationSyncMinAggregateOutputType = {
    id: string | null
    integrationId: string | null
    type: string | null
    status: string | null
    recordsCount: number | null
    errorMessage: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type IntegrationSyncMaxAggregateOutputType = {
    id: string | null
    integrationId: string | null
    type: string | null
    status: string | null
    recordsCount: number | null
    errorMessage: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type IntegrationSyncCountAggregateOutputType = {
    id: number
    integrationId: number
    type: number
    status: number
    recordsCount: number
    errorMessage: number
    metadata: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type IntegrationSyncAvgAggregateInputType = {
    recordsCount?: true
  }

  export type IntegrationSyncSumAggregateInputType = {
    recordsCount?: true
  }

  export type IntegrationSyncMinAggregateInputType = {
    id?: true
    integrationId?: true
    type?: true
    status?: true
    recordsCount?: true
    errorMessage?: true
    startedAt?: true
    completedAt?: true
  }

  export type IntegrationSyncMaxAggregateInputType = {
    id?: true
    integrationId?: true
    type?: true
    status?: true
    recordsCount?: true
    errorMessage?: true
    startedAt?: true
    completedAt?: true
  }

  export type IntegrationSyncCountAggregateInputType = {
    id?: true
    integrationId?: true
    type?: true
    status?: true
    recordsCount?: true
    errorMessage?: true
    metadata?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type IntegrationSyncAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationSync to aggregate.
     */
    where?: IntegrationSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationSyncs to fetch.
     */
    orderBy?: IntegrationSyncOrderByWithRelationInput | IntegrationSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationSyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntegrationSyncs
    **/
    _count?: true | IntegrationSyncCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntegrationSyncAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntegrationSyncSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationSyncMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationSyncMaxAggregateInputType
  }

  export type GetIntegrationSyncAggregateType<T extends IntegrationSyncAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegrationSync]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegrationSync[P]>
      : GetScalarType<T[P], AggregateIntegrationSync[P]>
  }




  export type IntegrationSyncGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationSyncWhereInput
    orderBy?: IntegrationSyncOrderByWithAggregationInput | IntegrationSyncOrderByWithAggregationInput[]
    by: IntegrationSyncScalarFieldEnum[] | IntegrationSyncScalarFieldEnum
    having?: IntegrationSyncScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationSyncCountAggregateInputType | true
    _avg?: IntegrationSyncAvgAggregateInputType
    _sum?: IntegrationSyncSumAggregateInputType
    _min?: IntegrationSyncMinAggregateInputType
    _max?: IntegrationSyncMaxAggregateInputType
  }

  export type IntegrationSyncGroupByOutputType = {
    id: string
    integrationId: string
    type: string
    status: string
    recordsCount: number | null
    errorMessage: string | null
    metadata: JsonValue | null
    startedAt: Date
    completedAt: Date | null
    _count: IntegrationSyncCountAggregateOutputType | null
    _avg: IntegrationSyncAvgAggregateOutputType | null
    _sum: IntegrationSyncSumAggregateOutputType | null
    _min: IntegrationSyncMinAggregateOutputType | null
    _max: IntegrationSyncMaxAggregateOutputType | null
  }

  type GetIntegrationSyncGroupByPayload<T extends IntegrationSyncGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationSyncGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationSyncGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationSyncGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationSyncGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSyncSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    type?: boolean
    status?: boolean
    recordsCount?: boolean
    errorMessage?: boolean
    metadata?: boolean
    startedAt?: boolean
    completedAt?: boolean
    integration?: boolean | IntegrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrationSync"]>

  export type IntegrationSyncSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    type?: boolean
    status?: boolean
    recordsCount?: boolean
    errorMessage?: boolean
    metadata?: boolean
    startedAt?: boolean
    completedAt?: boolean
    integration?: boolean | IntegrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrationSync"]>

  export type IntegrationSyncSelectScalar = {
    id?: boolean
    integrationId?: boolean
    type?: boolean
    status?: boolean
    recordsCount?: boolean
    errorMessage?: boolean
    metadata?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type IntegrationSyncInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | IntegrationDefaultArgs<ExtArgs>
  }
  export type IntegrationSyncIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | IntegrationDefaultArgs<ExtArgs>
  }

  export type $IntegrationSyncPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntegrationSync"
    objects: {
      integration: Prisma.$IntegrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      integrationId: string
      type: string
      status: string
      recordsCount: number | null
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
      startedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["integrationSync"]>
    composites: {}
  }

  type IntegrationSyncGetPayload<S extends boolean | null | undefined | IntegrationSyncDefaultArgs> = $Result.GetResult<Prisma.$IntegrationSyncPayload, S>

  type IntegrationSyncCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntegrationSyncFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntegrationSyncCountAggregateInputType | true
    }

  export interface IntegrationSyncDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntegrationSync'], meta: { name: 'IntegrationSync' } }
    /**
     * Find zero or one IntegrationSync that matches the filter.
     * @param {IntegrationSyncFindUniqueArgs} args - Arguments to find a IntegrationSync
     * @example
     * // Get one IntegrationSync
     * const integrationSync = await prisma.integrationSync.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationSyncFindUniqueArgs>(args: SelectSubset<T, IntegrationSyncFindUniqueArgs<ExtArgs>>): Prisma__IntegrationSyncClient<$Result.GetResult<Prisma.$IntegrationSyncPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IntegrationSync that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntegrationSyncFindUniqueOrThrowArgs} args - Arguments to find a IntegrationSync
     * @example
     * // Get one IntegrationSync
     * const integrationSync = await prisma.integrationSync.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationSyncFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationSyncFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationSyncClient<$Result.GetResult<Prisma.$IntegrationSyncPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IntegrationSync that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSyncFindFirstArgs} args - Arguments to find a IntegrationSync
     * @example
     * // Get one IntegrationSync
     * const integrationSync = await prisma.integrationSync.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationSyncFindFirstArgs>(args?: SelectSubset<T, IntegrationSyncFindFirstArgs<ExtArgs>>): Prisma__IntegrationSyncClient<$Result.GetResult<Prisma.$IntegrationSyncPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IntegrationSync that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSyncFindFirstOrThrowArgs} args - Arguments to find a IntegrationSync
     * @example
     * // Get one IntegrationSync
     * const integrationSync = await prisma.integrationSync.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationSyncFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationSyncFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationSyncClient<$Result.GetResult<Prisma.$IntegrationSyncPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IntegrationSyncs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSyncFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntegrationSyncs
     * const integrationSyncs = await prisma.integrationSync.findMany()
     * 
     * // Get first 10 IntegrationSyncs
     * const integrationSyncs = await prisma.integrationSync.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationSyncWithIdOnly = await prisma.integrationSync.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationSyncFindManyArgs>(args?: SelectSubset<T, IntegrationSyncFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationSyncPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IntegrationSync.
     * @param {IntegrationSyncCreateArgs} args - Arguments to create a IntegrationSync.
     * @example
     * // Create one IntegrationSync
     * const IntegrationSync = await prisma.integrationSync.create({
     *   data: {
     *     // ... data to create a IntegrationSync
     *   }
     * })
     * 
     */
    create<T extends IntegrationSyncCreateArgs>(args: SelectSubset<T, IntegrationSyncCreateArgs<ExtArgs>>): Prisma__IntegrationSyncClient<$Result.GetResult<Prisma.$IntegrationSyncPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IntegrationSyncs.
     * @param {IntegrationSyncCreateManyArgs} args - Arguments to create many IntegrationSyncs.
     * @example
     * // Create many IntegrationSyncs
     * const integrationSync = await prisma.integrationSync.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationSyncCreateManyArgs>(args?: SelectSubset<T, IntegrationSyncCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntegrationSyncs and returns the data saved in the database.
     * @param {IntegrationSyncCreateManyAndReturnArgs} args - Arguments to create many IntegrationSyncs.
     * @example
     * // Create many IntegrationSyncs
     * const integrationSync = await prisma.integrationSync.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntegrationSyncs and only return the `id`
     * const integrationSyncWithIdOnly = await prisma.integrationSync.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationSyncCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationSyncCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationSyncPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IntegrationSync.
     * @param {IntegrationSyncDeleteArgs} args - Arguments to delete one IntegrationSync.
     * @example
     * // Delete one IntegrationSync
     * const IntegrationSync = await prisma.integrationSync.delete({
     *   where: {
     *     // ... filter to delete one IntegrationSync
     *   }
     * })
     * 
     */
    delete<T extends IntegrationSyncDeleteArgs>(args: SelectSubset<T, IntegrationSyncDeleteArgs<ExtArgs>>): Prisma__IntegrationSyncClient<$Result.GetResult<Prisma.$IntegrationSyncPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IntegrationSync.
     * @param {IntegrationSyncUpdateArgs} args - Arguments to update one IntegrationSync.
     * @example
     * // Update one IntegrationSync
     * const integrationSync = await prisma.integrationSync.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationSyncUpdateArgs>(args: SelectSubset<T, IntegrationSyncUpdateArgs<ExtArgs>>): Prisma__IntegrationSyncClient<$Result.GetResult<Prisma.$IntegrationSyncPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IntegrationSyncs.
     * @param {IntegrationSyncDeleteManyArgs} args - Arguments to filter IntegrationSyncs to delete.
     * @example
     * // Delete a few IntegrationSyncs
     * const { count } = await prisma.integrationSync.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationSyncDeleteManyArgs>(args?: SelectSubset<T, IntegrationSyncDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegrationSyncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSyncUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntegrationSyncs
     * const integrationSync = await prisma.integrationSync.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationSyncUpdateManyArgs>(args: SelectSubset<T, IntegrationSyncUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IntegrationSync.
     * @param {IntegrationSyncUpsertArgs} args - Arguments to update or create a IntegrationSync.
     * @example
     * // Update or create a IntegrationSync
     * const integrationSync = await prisma.integrationSync.upsert({
     *   create: {
     *     // ... data to create a IntegrationSync
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntegrationSync we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationSyncUpsertArgs>(args: SelectSubset<T, IntegrationSyncUpsertArgs<ExtArgs>>): Prisma__IntegrationSyncClient<$Result.GetResult<Prisma.$IntegrationSyncPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IntegrationSyncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSyncCountArgs} args - Arguments to filter IntegrationSyncs to count.
     * @example
     * // Count the number of IntegrationSyncs
     * const count = await prisma.integrationSync.count({
     *   where: {
     *     // ... the filter for the IntegrationSyncs we want to count
     *   }
     * })
    **/
    count<T extends IntegrationSyncCountArgs>(
      args?: Subset<T, IntegrationSyncCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationSyncCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntegrationSync.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSyncAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationSyncAggregateArgs>(args: Subset<T, IntegrationSyncAggregateArgs>): Prisma.PrismaPromise<GetIntegrationSyncAggregateType<T>>

    /**
     * Group by IntegrationSync.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSyncGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationSyncGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationSyncGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationSyncGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationSyncGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationSyncGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntegrationSync model
   */
  readonly fields: IntegrationSyncFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntegrationSync.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationSyncClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    integration<T extends IntegrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntegrationDefaultArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntegrationSync model
   */ 
  interface IntegrationSyncFieldRefs {
    readonly id: FieldRef<"IntegrationSync", 'String'>
    readonly integrationId: FieldRef<"IntegrationSync", 'String'>
    readonly type: FieldRef<"IntegrationSync", 'String'>
    readonly status: FieldRef<"IntegrationSync", 'String'>
    readonly recordsCount: FieldRef<"IntegrationSync", 'Int'>
    readonly errorMessage: FieldRef<"IntegrationSync", 'String'>
    readonly metadata: FieldRef<"IntegrationSync", 'Json'>
    readonly startedAt: FieldRef<"IntegrationSync", 'DateTime'>
    readonly completedAt: FieldRef<"IntegrationSync", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntegrationSync findUnique
   */
  export type IntegrationSyncFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSync
     */
    select?: IntegrationSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSyncInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationSync to fetch.
     */
    where: IntegrationSyncWhereUniqueInput
  }

  /**
   * IntegrationSync findUniqueOrThrow
   */
  export type IntegrationSyncFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSync
     */
    select?: IntegrationSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSyncInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationSync to fetch.
     */
    where: IntegrationSyncWhereUniqueInput
  }

  /**
   * IntegrationSync findFirst
   */
  export type IntegrationSyncFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSync
     */
    select?: IntegrationSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSyncInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationSync to fetch.
     */
    where?: IntegrationSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationSyncs to fetch.
     */
    orderBy?: IntegrationSyncOrderByWithRelationInput | IntegrationSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationSyncs.
     */
    cursor?: IntegrationSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationSyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationSyncs.
     */
    distinct?: IntegrationSyncScalarFieldEnum | IntegrationSyncScalarFieldEnum[]
  }

  /**
   * IntegrationSync findFirstOrThrow
   */
  export type IntegrationSyncFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSync
     */
    select?: IntegrationSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSyncInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationSync to fetch.
     */
    where?: IntegrationSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationSyncs to fetch.
     */
    orderBy?: IntegrationSyncOrderByWithRelationInput | IntegrationSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationSyncs.
     */
    cursor?: IntegrationSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationSyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationSyncs.
     */
    distinct?: IntegrationSyncScalarFieldEnum | IntegrationSyncScalarFieldEnum[]
  }

  /**
   * IntegrationSync findMany
   */
  export type IntegrationSyncFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSync
     */
    select?: IntegrationSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSyncInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationSyncs to fetch.
     */
    where?: IntegrationSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationSyncs to fetch.
     */
    orderBy?: IntegrationSyncOrderByWithRelationInput | IntegrationSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntegrationSyncs.
     */
    cursor?: IntegrationSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationSyncs.
     */
    skip?: number
    distinct?: IntegrationSyncScalarFieldEnum | IntegrationSyncScalarFieldEnum[]
  }

  /**
   * IntegrationSync create
   */
  export type IntegrationSyncCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSync
     */
    select?: IntegrationSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSyncInclude<ExtArgs> | null
    /**
     * The data needed to create a IntegrationSync.
     */
    data: XOR<IntegrationSyncCreateInput, IntegrationSyncUncheckedCreateInput>
  }

  /**
   * IntegrationSync createMany
   */
  export type IntegrationSyncCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntegrationSyncs.
     */
    data: IntegrationSyncCreateManyInput | IntegrationSyncCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntegrationSync createManyAndReturn
   */
  export type IntegrationSyncCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSync
     */
    select?: IntegrationSyncSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IntegrationSyncs.
     */
    data: IntegrationSyncCreateManyInput | IntegrationSyncCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSyncIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntegrationSync update
   */
  export type IntegrationSyncUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSync
     */
    select?: IntegrationSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSyncInclude<ExtArgs> | null
    /**
     * The data needed to update a IntegrationSync.
     */
    data: XOR<IntegrationSyncUpdateInput, IntegrationSyncUncheckedUpdateInput>
    /**
     * Choose, which IntegrationSync to update.
     */
    where: IntegrationSyncWhereUniqueInput
  }

  /**
   * IntegrationSync updateMany
   */
  export type IntegrationSyncUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntegrationSyncs.
     */
    data: XOR<IntegrationSyncUpdateManyMutationInput, IntegrationSyncUncheckedUpdateManyInput>
    /**
     * Filter which IntegrationSyncs to update
     */
    where?: IntegrationSyncWhereInput
  }

  /**
   * IntegrationSync upsert
   */
  export type IntegrationSyncUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSync
     */
    select?: IntegrationSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSyncInclude<ExtArgs> | null
    /**
     * The filter to search for the IntegrationSync to update in case it exists.
     */
    where: IntegrationSyncWhereUniqueInput
    /**
     * In case the IntegrationSync found by the `where` argument doesn't exist, create a new IntegrationSync with this data.
     */
    create: XOR<IntegrationSyncCreateInput, IntegrationSyncUncheckedCreateInput>
    /**
     * In case the IntegrationSync was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationSyncUpdateInput, IntegrationSyncUncheckedUpdateInput>
  }

  /**
   * IntegrationSync delete
   */
  export type IntegrationSyncDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSync
     */
    select?: IntegrationSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSyncInclude<ExtArgs> | null
    /**
     * Filter which IntegrationSync to delete.
     */
    where: IntegrationSyncWhereUniqueInput
  }

  /**
   * IntegrationSync deleteMany
   */
  export type IntegrationSyncDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationSyncs to delete
     */
    where?: IntegrationSyncWhereInput
  }

  /**
   * IntegrationSync without action
   */
  export type IntegrationSyncDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSync
     */
    select?: IntegrationSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSyncInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    severity: string | null
    tenantId: string | null
    userId: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    severity: string | null
    tenantId: string | null
    userId: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    severity: number
    tenantId: number
    userId: number
    entityType: number
    entityId: number
    details: number
    ipAddress: number
    userAgent: number
    metadata: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    severity?: true
    tenantId?: true
    userId?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    severity?: true
    tenantId?: true
    userId?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    severity?: true
    tenantId?: true
    userId?: true
    entityType?: true
    entityId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    metadata?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: string
    severity: string
    tenantId: string
    userId: string | null
    entityType: string | null
    entityId: string | null
    details: JsonValue
    ipAddress: string | null
    userAgent: string | null
    metadata: JsonValue | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    severity?: boolean
    tenantId?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    timestamp?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    severity?: boolean
    tenantId?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    timestamp?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    severity?: boolean
    tenantId?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    timestamp?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      severity: string
      tenantId: string
      userId: string | null
      entityType: string | null
      entityId: string | null
      details: Prisma.JsonValue
      ipAddress: string | null
      userAgent: string | null
      metadata: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly severity: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const TenantQuotaScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    maxUsers: 'maxUsers',
    maxContacts: 'maxContacts',
    maxCampaigns: 'maxCampaigns',
    maxConnections: 'maxConnections',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantQuotaScalarFieldEnum = (typeof TenantQuotaScalarFieldEnum)[keyof typeof TenantQuotaScalarFieldEnum]


  export const TenantSettingsScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    openaiApiKey: 'openaiApiKey',
    groqApiKey: 'groqApiKey',
    customBranding: 'customBranding',
    chatwootUrl: 'chatwootUrl',
    chatwootAccountId: 'chatwootAccountId',
    chatwootApiToken: 'chatwootApiToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantSettingsScalarFieldEnum = (typeof TenantSettingsScalarFieldEnum)[keyof typeof TenantSettingsScalarFieldEnum]


  export const UserTenantScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenantId: 'tenantId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserTenantScalarFieldEnum = (typeof UserTenantScalarFieldEnum)[keyof typeof UserTenantScalarFieldEnum]


  export const GlobalSettingsScalarFieldEnum: {
    id: 'id',
    singleton: 'singleton',
    wahaHost: 'wahaHost',
    wahaApiKey: 'wahaApiKey',
    evolutionHost: 'evolutionHost',
    evolutionApiKey: 'evolutionApiKey',
    quepasaUrl: 'quepasaUrl',
    quepasaLogin: 'quepasaLogin',
    quepasaPassword: 'quepasaPassword',
    logoUrl: 'logoUrl',
    faviconUrl: 'faviconUrl',
    iconUrl: 'iconUrl',
    companyName: 'companyName',
    pageTitle: 'pageTitle',
    primaryColor: 'primaryColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GlobalSettingsScalarFieldEnum = (typeof GlobalSettingsScalarFieldEnum)[keyof typeof GlobalSettingsScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    telefone: 'telefone',
    email: 'email',
    tags: 'tags',
    observacoes: 'observacoes',
    categoriaId: 'categoriaId',
    tenantId: 'tenantId',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    cor: 'cor',
    descricao: 'descricao',
    tenantId: 'tenantId',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const WhatsAppSessionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    status: 'status',
    config: 'config',
    meId: 'meId',
    mePushName: 'mePushName',
    meLid: 'meLid',
    meJid: 'meJid',
    qr: 'qr',
    qrExpiresAt: 'qrExpiresAt',
    assignedWorker: 'assignedWorker',
    tenantId: 'tenantId',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm',
    provider: 'provider',
    quepasaToken: 'quepasaToken'
  };

  export type WhatsAppSessionScalarFieldEnum = (typeof WhatsAppSessionScalarFieldEnum)[keyof typeof WhatsAppSessionScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    targetTags: 'targetTags',
    sessionName: 'sessionName',
    messageType: 'messageType',
    messageContent: 'messageContent',
    randomDelay: 'randomDelay',
    startImmediately: 'startImmediately',
    scheduledFor: 'scheduledFor',
    status: 'status',
    totalContacts: 'totalContacts',
    sentCount: 'sentCount',
    failedCount: 'failedCount',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    startTime: 'startTime',
    endTime: 'endTime',
    useTimeWindow: 'useTimeWindow',
    tenantId: 'tenantId',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm',
    sessionNames: 'sessionNames',
    createdBy: 'createdBy',
    createdByName: 'createdByName'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignMessageScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    contactId: 'contactId',
    contactPhone: 'contactPhone',
    contactName: 'contactName',
    status: 'status',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    readAt: 'readAt',
    errorMessage: 'errorMessage',
    messageId: 'messageId',
    selectedVariation: 'selectedVariation',
    tenantId: 'tenantId',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm',
    sessionName: 'sessionName'
  };

  export type CampaignMessageScalarFieldEnum = (typeof CampaignMessageScalarFieldEnum)[keyof typeof CampaignMessageScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    role: 'role',
    ativo: 'ativo',
    tenantId: 'tenantId',
    ultimoLogin: 'ultimoLogin',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    type: 'type',
    severity: 'severity',
    title: 'title',
    message: 'message',
    tenantId: 'tenantId',
    userId: 'userId',
    metadata: 'metadata',
    resolved: 'resolved',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    alertId: 'alertId',
    userId: 'userId',
    method: 'method',
    sent: 'sent',
    sentAt: 'sentAt',
    read: 'read',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const UserNotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    data: 'data',
    read: 'read',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserNotificationScalarFieldEnum = (typeof UserNotificationScalarFieldEnum)[keyof typeof UserNotificationScalarFieldEnum]


  export const MessageTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tenantId: 'tenantId',
    category: 'category',
    messageType: 'messageType',
    content: 'content',
    variables: 'variables',
    mediaUrl: 'mediaUrl',
    active: 'active',
    tags: 'tags',
    description: 'description',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageTemplateScalarFieldEnum = (typeof MessageTemplateScalarFieldEnum)[keyof typeof MessageTemplateScalarFieldEnum]


  export const AutomationFlowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    tenantId: 'tenantId',
    active: 'active',
    trigger: 'trigger',
    conditions: 'conditions',
    actions: 'actions',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AutomationFlowScalarFieldEnum = (typeof AutomationFlowScalarFieldEnum)[keyof typeof AutomationFlowScalarFieldEnum]


  export const AutomationExecutionScalarFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    status: 'status',
    executedAt: 'executedAt',
    context: 'context',
    error: 'error',
    duration: 'duration'
  };

  export type AutomationExecutionScalarFieldEnum = (typeof AutomationExecutionScalarFieldEnum)[keyof typeof AutomationExecutionScalarFieldEnum]


  export const IntegrationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    tenantId: 'tenantId',
    active: 'active',
    config: 'config',
    credentials: 'credentials',
    webhookUrl: 'webhookUrl',
    lastSyncAt: 'lastSyncAt',
    lastError: 'lastError',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


  export const IntegrationSyncScalarFieldEnum: {
    id: 'id',
    integrationId: 'integrationId',
    type: 'type',
    status: 'status',
    recordsCount: 'recordsCount',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type IntegrationSyncScalarFieldEnum = (typeof IntegrationSyncScalarFieldEnum)[keyof typeof IntegrationSyncScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    severity: 'severity',
    tenantId: 'tenantId',
    userId: 'userId',
    entityType: 'entityType',
    entityId: 'entityId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    metadata: 'metadata',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'AlertType'
   */
  export type EnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType'>
    


  /**
   * Reference to a field of type 'AlertType[]'
   */
  export type ListEnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType[]'>
    


  /**
   * Reference to a field of type 'AlertSeverity'
   */
  export type EnumAlertSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertSeverity'>
    


  /**
   * Reference to a field of type 'AlertSeverity[]'
   */
  export type ListEnumAlertSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertSeverity[]'>
    


  /**
   * Reference to a field of type 'NotificationMethod'
   */
  export type EnumNotificationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationMethod'>
    


  /**
   * Reference to a field of type 'NotificationMethod[]'
   */
  export type ListEnumNotificationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationMethod[]'>
    


  /**
   * Reference to a field of type 'UserNotificationType'
   */
  export type EnumUserNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserNotificationType'>
    


  /**
   * Reference to a field of type 'UserNotificationType[]'
   */
  export type ListEnumUserNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserNotificationType[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'IntegrationType'
   */
  export type EnumIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationType'>
    


  /**
   * Reference to a field of type 'IntegrationType[]'
   */
  export type ListEnumIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    slug?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    active?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    userTenants?: UserTenantListRelationFilter
    contacts?: ContactListRelationFilter
    categories?: CategoryListRelationFilter
    campaigns?: CampaignListRelationFilter
    campaignMessages?: CampaignMessageListRelationFilter
    whatsappSessions?: WhatsAppSessionListRelationFilter
    quotas?: XOR<TenantQuotaNullableRelationFilter, TenantQuotaWhereInput> | null
    settings?: XOR<TenantSettingsNullableRelationFilter, TenantSettingsWhereInput> | null
    alerts?: AlertListRelationFilter
    messageTemplates?: MessageTemplateListRelationFilter
    automationFlows?: AutomationFlowListRelationFilter
    integrations?: IntegrationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    userTenants?: UserTenantOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
    campaignMessages?: CampaignMessageOrderByRelationAggregateInput
    whatsappSessions?: WhatsAppSessionOrderByRelationAggregateInput
    quotas?: TenantQuotaOrderByWithRelationInput
    settings?: TenantSettingsOrderByWithRelationInput
    alerts?: AlertOrderByRelationAggregateInput
    messageTemplates?: MessageTemplateOrderByRelationAggregateInput
    automationFlows?: AutomationFlowOrderByRelationAggregateInput
    integrations?: IntegrationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    active?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    userTenants?: UserTenantListRelationFilter
    contacts?: ContactListRelationFilter
    categories?: CategoryListRelationFilter
    campaigns?: CampaignListRelationFilter
    campaignMessages?: CampaignMessageListRelationFilter
    whatsappSessions?: WhatsAppSessionListRelationFilter
    quotas?: XOR<TenantQuotaNullableRelationFilter, TenantQuotaWhereInput> | null
    settings?: XOR<TenantSettingsNullableRelationFilter, TenantSettingsWhereInput> | null
    alerts?: AlertListRelationFilter
    messageTemplates?: MessageTemplateListRelationFilter
    automationFlows?: AutomationFlowListRelationFilter
    integrations?: IntegrationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "slug">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    slug?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    active?: BoolWithAggregatesFilter<"Tenant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type TenantQuotaWhereInput = {
    AND?: TenantQuotaWhereInput | TenantQuotaWhereInput[]
    OR?: TenantQuotaWhereInput[]
    NOT?: TenantQuotaWhereInput | TenantQuotaWhereInput[]
    id?: StringFilter<"TenantQuota"> | string
    tenantId?: StringFilter<"TenantQuota"> | string
    maxUsers?: IntFilter<"TenantQuota"> | number
    maxContacts?: IntFilter<"TenantQuota"> | number
    maxCampaigns?: IntFilter<"TenantQuota"> | number
    maxConnections?: IntFilter<"TenantQuota"> | number
    createdAt?: DateTimeFilter<"TenantQuota"> | Date | string
    updatedAt?: DateTimeFilter<"TenantQuota"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type TenantQuotaOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    maxUsers?: SortOrder
    maxContacts?: SortOrder
    maxCampaigns?: SortOrder
    maxConnections?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantQuotaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: TenantQuotaWhereInput | TenantQuotaWhereInput[]
    OR?: TenantQuotaWhereInput[]
    NOT?: TenantQuotaWhereInput | TenantQuotaWhereInput[]
    maxUsers?: IntFilter<"TenantQuota"> | number
    maxContacts?: IntFilter<"TenantQuota"> | number
    maxCampaigns?: IntFilter<"TenantQuota"> | number
    maxConnections?: IntFilter<"TenantQuota"> | number
    createdAt?: DateTimeFilter<"TenantQuota"> | Date | string
    updatedAt?: DateTimeFilter<"TenantQuota"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "tenantId">

  export type TenantQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    maxUsers?: SortOrder
    maxContacts?: SortOrder
    maxCampaigns?: SortOrder
    maxConnections?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantQuotaCountOrderByAggregateInput
    _avg?: TenantQuotaAvgOrderByAggregateInput
    _max?: TenantQuotaMaxOrderByAggregateInput
    _min?: TenantQuotaMinOrderByAggregateInput
    _sum?: TenantQuotaSumOrderByAggregateInput
  }

  export type TenantQuotaScalarWhereWithAggregatesInput = {
    AND?: TenantQuotaScalarWhereWithAggregatesInput | TenantQuotaScalarWhereWithAggregatesInput[]
    OR?: TenantQuotaScalarWhereWithAggregatesInput[]
    NOT?: TenantQuotaScalarWhereWithAggregatesInput | TenantQuotaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantQuota"> | string
    tenantId?: StringWithAggregatesFilter<"TenantQuota"> | string
    maxUsers?: IntWithAggregatesFilter<"TenantQuota"> | number
    maxContacts?: IntWithAggregatesFilter<"TenantQuota"> | number
    maxCampaigns?: IntWithAggregatesFilter<"TenantQuota"> | number
    maxConnections?: IntWithAggregatesFilter<"TenantQuota"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TenantQuota"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantQuota"> | Date | string
  }

  export type TenantSettingsWhereInput = {
    AND?: TenantSettingsWhereInput | TenantSettingsWhereInput[]
    OR?: TenantSettingsWhereInput[]
    NOT?: TenantSettingsWhereInput | TenantSettingsWhereInput[]
    id?: StringFilter<"TenantSettings"> | string
    tenantId?: StringFilter<"TenantSettings"> | string
    openaiApiKey?: StringNullableFilter<"TenantSettings"> | string | null
    groqApiKey?: StringNullableFilter<"TenantSettings"> | string | null
    customBranding?: JsonNullableFilter<"TenantSettings">
    chatwootUrl?: StringNullableFilter<"TenantSettings"> | string | null
    chatwootAccountId?: StringNullableFilter<"TenantSettings"> | string | null
    chatwootApiToken?: StringNullableFilter<"TenantSettings"> | string | null
    createdAt?: DateTimeFilter<"TenantSettings"> | Date | string
    updatedAt?: DateTimeFilter<"TenantSettings"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type TenantSettingsOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    openaiApiKey?: SortOrderInput | SortOrder
    groqApiKey?: SortOrderInput | SortOrder
    customBranding?: SortOrderInput | SortOrder
    chatwootUrl?: SortOrderInput | SortOrder
    chatwootAccountId?: SortOrderInput | SortOrder
    chatwootApiToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: TenantSettingsWhereInput | TenantSettingsWhereInput[]
    OR?: TenantSettingsWhereInput[]
    NOT?: TenantSettingsWhereInput | TenantSettingsWhereInput[]
    openaiApiKey?: StringNullableFilter<"TenantSettings"> | string | null
    groqApiKey?: StringNullableFilter<"TenantSettings"> | string | null
    customBranding?: JsonNullableFilter<"TenantSettings">
    chatwootUrl?: StringNullableFilter<"TenantSettings"> | string | null
    chatwootAccountId?: StringNullableFilter<"TenantSettings"> | string | null
    chatwootApiToken?: StringNullableFilter<"TenantSettings"> | string | null
    createdAt?: DateTimeFilter<"TenantSettings"> | Date | string
    updatedAt?: DateTimeFilter<"TenantSettings"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "tenantId">

  export type TenantSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    openaiApiKey?: SortOrderInput | SortOrder
    groqApiKey?: SortOrderInput | SortOrder
    customBranding?: SortOrderInput | SortOrder
    chatwootUrl?: SortOrderInput | SortOrder
    chatwootAccountId?: SortOrderInput | SortOrder
    chatwootApiToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantSettingsCountOrderByAggregateInput
    _max?: TenantSettingsMaxOrderByAggregateInput
    _min?: TenantSettingsMinOrderByAggregateInput
  }

  export type TenantSettingsScalarWhereWithAggregatesInput = {
    AND?: TenantSettingsScalarWhereWithAggregatesInput | TenantSettingsScalarWhereWithAggregatesInput[]
    OR?: TenantSettingsScalarWhereWithAggregatesInput[]
    NOT?: TenantSettingsScalarWhereWithAggregatesInput | TenantSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantSettings"> | string
    tenantId?: StringWithAggregatesFilter<"TenantSettings"> | string
    openaiApiKey?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    groqApiKey?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    customBranding?: JsonNullableWithAggregatesFilter<"TenantSettings">
    chatwootUrl?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    chatwootAccountId?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    chatwootApiToken?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TenantSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantSettings"> | Date | string
  }

  export type UserTenantWhereInput = {
    AND?: UserTenantWhereInput | UserTenantWhereInput[]
    OR?: UserTenantWhereInput[]
    NOT?: UserTenantWhereInput | UserTenantWhereInput[]
    id?: StringFilter<"UserTenant"> | string
    userId?: StringFilter<"UserTenant"> | string
    tenantId?: StringFilter<"UserTenant"> | string
    role?: StringFilter<"UserTenant"> | string
    createdAt?: DateTimeFilter<"UserTenant"> | Date | string
    updatedAt?: DateTimeFilter<"UserTenant"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type UserTenantOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type UserTenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tenantId?: UserTenantUserIdTenantIdCompoundUniqueInput
    AND?: UserTenantWhereInput | UserTenantWhereInput[]
    OR?: UserTenantWhereInput[]
    NOT?: UserTenantWhereInput | UserTenantWhereInput[]
    userId?: StringFilter<"UserTenant"> | string
    tenantId?: StringFilter<"UserTenant"> | string
    role?: StringFilter<"UserTenant"> | string
    createdAt?: DateTimeFilter<"UserTenant"> | Date | string
    updatedAt?: DateTimeFilter<"UserTenant"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "userId_tenantId">

  export type UserTenantOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserTenantCountOrderByAggregateInput
    _max?: UserTenantMaxOrderByAggregateInput
    _min?: UserTenantMinOrderByAggregateInput
  }

  export type UserTenantScalarWhereWithAggregatesInput = {
    AND?: UserTenantScalarWhereWithAggregatesInput | UserTenantScalarWhereWithAggregatesInput[]
    OR?: UserTenantScalarWhereWithAggregatesInput[]
    NOT?: UserTenantScalarWhereWithAggregatesInput | UserTenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTenant"> | string
    userId?: StringWithAggregatesFilter<"UserTenant"> | string
    tenantId?: StringWithAggregatesFilter<"UserTenant"> | string
    role?: StringWithAggregatesFilter<"UserTenant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserTenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserTenant"> | Date | string
  }

  export type GlobalSettingsWhereInput = {
    AND?: GlobalSettingsWhereInput | GlobalSettingsWhereInput[]
    OR?: GlobalSettingsWhereInput[]
    NOT?: GlobalSettingsWhereInput | GlobalSettingsWhereInput[]
    id?: StringFilter<"GlobalSettings"> | string
    singleton?: BoolFilter<"GlobalSettings"> | boolean
    wahaHost?: StringFilter<"GlobalSettings"> | string
    wahaApiKey?: StringFilter<"GlobalSettings"> | string
    evolutionHost?: StringFilter<"GlobalSettings"> | string
    evolutionApiKey?: StringFilter<"GlobalSettings"> | string
    quepasaUrl?: StringFilter<"GlobalSettings"> | string
    quepasaLogin?: StringFilter<"GlobalSettings"> | string
    quepasaPassword?: StringFilter<"GlobalSettings"> | string
    logoUrl?: StringNullableFilter<"GlobalSettings"> | string | null
    faviconUrl?: StringNullableFilter<"GlobalSettings"> | string | null
    iconUrl?: StringNullableFilter<"GlobalSettings"> | string | null
    companyName?: StringNullableFilter<"GlobalSettings"> | string | null
    pageTitle?: StringNullableFilter<"GlobalSettings"> | string | null
    primaryColor?: StringNullableFilter<"GlobalSettings"> | string | null
    createdAt?: DateTimeFilter<"GlobalSettings"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalSettings"> | Date | string
  }

  export type GlobalSettingsOrderByWithRelationInput = {
    id?: SortOrder
    singleton?: SortOrder
    wahaHost?: SortOrder
    wahaApiKey?: SortOrder
    evolutionHost?: SortOrder
    evolutionApiKey?: SortOrder
    quepasaUrl?: SortOrder
    quepasaLogin?: SortOrder
    quepasaPassword?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    faviconUrl?: SortOrderInput | SortOrder
    iconUrl?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    pageTitle?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    singleton?: boolean
    AND?: GlobalSettingsWhereInput | GlobalSettingsWhereInput[]
    OR?: GlobalSettingsWhereInput[]
    NOT?: GlobalSettingsWhereInput | GlobalSettingsWhereInput[]
    wahaHost?: StringFilter<"GlobalSettings"> | string
    wahaApiKey?: StringFilter<"GlobalSettings"> | string
    evolutionHost?: StringFilter<"GlobalSettings"> | string
    evolutionApiKey?: StringFilter<"GlobalSettings"> | string
    quepasaUrl?: StringFilter<"GlobalSettings"> | string
    quepasaLogin?: StringFilter<"GlobalSettings"> | string
    quepasaPassword?: StringFilter<"GlobalSettings"> | string
    logoUrl?: StringNullableFilter<"GlobalSettings"> | string | null
    faviconUrl?: StringNullableFilter<"GlobalSettings"> | string | null
    iconUrl?: StringNullableFilter<"GlobalSettings"> | string | null
    companyName?: StringNullableFilter<"GlobalSettings"> | string | null
    pageTitle?: StringNullableFilter<"GlobalSettings"> | string | null
    primaryColor?: StringNullableFilter<"GlobalSettings"> | string | null
    createdAt?: DateTimeFilter<"GlobalSettings"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalSettings"> | Date | string
  }, "id" | "singleton">

  export type GlobalSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    singleton?: SortOrder
    wahaHost?: SortOrder
    wahaApiKey?: SortOrder
    evolutionHost?: SortOrder
    evolutionApiKey?: SortOrder
    quepasaUrl?: SortOrder
    quepasaLogin?: SortOrder
    quepasaPassword?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    faviconUrl?: SortOrderInput | SortOrder
    iconUrl?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    pageTitle?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GlobalSettingsCountOrderByAggregateInput
    _max?: GlobalSettingsMaxOrderByAggregateInput
    _min?: GlobalSettingsMinOrderByAggregateInput
  }

  export type GlobalSettingsScalarWhereWithAggregatesInput = {
    AND?: GlobalSettingsScalarWhereWithAggregatesInput | GlobalSettingsScalarWhereWithAggregatesInput[]
    OR?: GlobalSettingsScalarWhereWithAggregatesInput[]
    NOT?: GlobalSettingsScalarWhereWithAggregatesInput | GlobalSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GlobalSettings"> | string
    singleton?: BoolWithAggregatesFilter<"GlobalSettings"> | boolean
    wahaHost?: StringWithAggregatesFilter<"GlobalSettings"> | string
    wahaApiKey?: StringWithAggregatesFilter<"GlobalSettings"> | string
    evolutionHost?: StringWithAggregatesFilter<"GlobalSettings"> | string
    evolutionApiKey?: StringWithAggregatesFilter<"GlobalSettings"> | string
    quepasaUrl?: StringWithAggregatesFilter<"GlobalSettings"> | string
    quepasaLogin?: StringWithAggregatesFilter<"GlobalSettings"> | string
    quepasaPassword?: StringWithAggregatesFilter<"GlobalSettings"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"GlobalSettings"> | string | null
    faviconUrl?: StringNullableWithAggregatesFilter<"GlobalSettings"> | string | null
    iconUrl?: StringNullableWithAggregatesFilter<"GlobalSettings"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"GlobalSettings"> | string | null
    pageTitle?: StringNullableWithAggregatesFilter<"GlobalSettings"> | string | null
    primaryColor?: StringNullableWithAggregatesFilter<"GlobalSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GlobalSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GlobalSettings"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    nome?: StringFilter<"Contact"> | string
    telefone?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    tags?: StringNullableListFilter<"Contact">
    observacoes?: StringNullableFilter<"Contact"> | string | null
    categoriaId?: StringNullableFilter<"Contact"> | string | null
    tenantId?: StringNullableFilter<"Contact"> | string | null
    criadoEm?: DateTimeFilter<"Contact"> | Date | string
    atualizadoEm?: DateTimeFilter<"Contact"> | Date | string
    categoria?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    email?: SortOrderInput | SortOrder
    tags?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    categoriaId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    categoria?: CategoryOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    nome?: StringFilter<"Contact"> | string
    telefone?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    tags?: StringNullableListFilter<"Contact">
    observacoes?: StringNullableFilter<"Contact"> | string | null
    categoriaId?: StringNullableFilter<"Contact"> | string | null
    tenantId?: StringNullableFilter<"Contact"> | string | null
    criadoEm?: DateTimeFilter<"Contact"> | Date | string
    atualizadoEm?: DateTimeFilter<"Contact"> | Date | string
    categoria?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    email?: SortOrderInput | SortOrder
    tags?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    categoriaId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    nome?: StringWithAggregatesFilter<"Contact"> | string
    telefone?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    tags?: StringNullableListFilter<"Contact">
    observacoes?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    categoriaId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    criadoEm?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    nome?: StringFilter<"Category"> | string
    cor?: StringFilter<"Category"> | string
    descricao?: StringNullableFilter<"Category"> | string | null
    tenantId?: StringNullableFilter<"Category"> | string | null
    criadoEm?: DateTimeFilter<"Category"> | Date | string
    atualizadoEm?: DateTimeFilter<"Category"> | Date | string
    contacts?: ContactListRelationFilter
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    cor?: SortOrder
    descricao?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    contacts?: ContactOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    nome?: StringFilter<"Category"> | string
    cor?: StringFilter<"Category"> | string
    descricao?: StringNullableFilter<"Category"> | string | null
    tenantId?: StringNullableFilter<"Category"> | string | null
    criadoEm?: DateTimeFilter<"Category"> | Date | string
    atualizadoEm?: DateTimeFilter<"Category"> | Date | string
    contacts?: ContactListRelationFilter
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    cor?: SortOrder
    descricao?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    nome?: StringWithAggregatesFilter<"Category"> | string
    cor?: StringWithAggregatesFilter<"Category"> | string
    descricao?: StringNullableWithAggregatesFilter<"Category"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    criadoEm?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type WhatsAppSessionWhereInput = {
    AND?: WhatsAppSessionWhereInput | WhatsAppSessionWhereInput[]
    OR?: WhatsAppSessionWhereInput[]
    NOT?: WhatsAppSessionWhereInput | WhatsAppSessionWhereInput[]
    id?: StringFilter<"WhatsAppSession"> | string
    name?: StringFilter<"WhatsAppSession"> | string
    displayName?: StringNullableFilter<"WhatsAppSession"> | string | null
    status?: StringFilter<"WhatsAppSession"> | string
    config?: StringNullableFilter<"WhatsAppSession"> | string | null
    meId?: StringNullableFilter<"WhatsAppSession"> | string | null
    mePushName?: StringNullableFilter<"WhatsAppSession"> | string | null
    meLid?: StringNullableFilter<"WhatsAppSession"> | string | null
    meJid?: StringNullableFilter<"WhatsAppSession"> | string | null
    qr?: StringNullableFilter<"WhatsAppSession"> | string | null
    qrExpiresAt?: DateTimeNullableFilter<"WhatsAppSession"> | Date | string | null
    assignedWorker?: StringNullableFilter<"WhatsAppSession"> | string | null
    tenantId?: StringNullableFilter<"WhatsAppSession"> | string | null
    criadoEm?: DateTimeFilter<"WhatsAppSession"> | Date | string
    atualizadoEm?: DateTimeFilter<"WhatsAppSession"> | Date | string
    provider?: StringFilter<"WhatsAppSession"> | string
    quepasaToken?: StringNullableFilter<"WhatsAppSession"> | string | null
    campaigns?: CampaignListRelationFilter
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }

  export type WhatsAppSessionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrderInput | SortOrder
    status?: SortOrder
    config?: SortOrderInput | SortOrder
    meId?: SortOrderInput | SortOrder
    mePushName?: SortOrderInput | SortOrder
    meLid?: SortOrderInput | SortOrder
    meJid?: SortOrderInput | SortOrder
    qr?: SortOrderInput | SortOrder
    qrExpiresAt?: SortOrderInput | SortOrder
    assignedWorker?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    provider?: SortOrder
    quepasaToken?: SortOrderInput | SortOrder
    campaigns?: CampaignOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type WhatsAppSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: WhatsAppSessionWhereInput | WhatsAppSessionWhereInput[]
    OR?: WhatsAppSessionWhereInput[]
    NOT?: WhatsAppSessionWhereInput | WhatsAppSessionWhereInput[]
    displayName?: StringNullableFilter<"WhatsAppSession"> | string | null
    status?: StringFilter<"WhatsAppSession"> | string
    config?: StringNullableFilter<"WhatsAppSession"> | string | null
    meId?: StringNullableFilter<"WhatsAppSession"> | string | null
    mePushName?: StringNullableFilter<"WhatsAppSession"> | string | null
    meLid?: StringNullableFilter<"WhatsAppSession"> | string | null
    meJid?: StringNullableFilter<"WhatsAppSession"> | string | null
    qr?: StringNullableFilter<"WhatsAppSession"> | string | null
    qrExpiresAt?: DateTimeNullableFilter<"WhatsAppSession"> | Date | string | null
    assignedWorker?: StringNullableFilter<"WhatsAppSession"> | string | null
    tenantId?: StringNullableFilter<"WhatsAppSession"> | string | null
    criadoEm?: DateTimeFilter<"WhatsAppSession"> | Date | string
    atualizadoEm?: DateTimeFilter<"WhatsAppSession"> | Date | string
    provider?: StringFilter<"WhatsAppSession"> | string
    quepasaToken?: StringNullableFilter<"WhatsAppSession"> | string | null
    campaigns?: CampaignListRelationFilter
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }, "id" | "name">

  export type WhatsAppSessionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrderInput | SortOrder
    status?: SortOrder
    config?: SortOrderInput | SortOrder
    meId?: SortOrderInput | SortOrder
    mePushName?: SortOrderInput | SortOrder
    meLid?: SortOrderInput | SortOrder
    meJid?: SortOrderInput | SortOrder
    qr?: SortOrderInput | SortOrder
    qrExpiresAt?: SortOrderInput | SortOrder
    assignedWorker?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    provider?: SortOrder
    quepasaToken?: SortOrderInput | SortOrder
    _count?: WhatsAppSessionCountOrderByAggregateInput
    _max?: WhatsAppSessionMaxOrderByAggregateInput
    _min?: WhatsAppSessionMinOrderByAggregateInput
  }

  export type WhatsAppSessionScalarWhereWithAggregatesInput = {
    AND?: WhatsAppSessionScalarWhereWithAggregatesInput | WhatsAppSessionScalarWhereWithAggregatesInput[]
    OR?: WhatsAppSessionScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppSessionScalarWhereWithAggregatesInput | WhatsAppSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    name?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    displayName?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    status?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    config?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    meId?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    mePushName?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    meLid?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    meJid?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    qr?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    qrExpiresAt?: DateTimeNullableWithAggregatesFilter<"WhatsAppSession"> | Date | string | null
    assignedWorker?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    criadoEm?: DateTimeWithAggregatesFilter<"WhatsAppSession"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"WhatsAppSession"> | Date | string
    provider?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    quepasaToken?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    nome?: StringFilter<"Campaign"> | string
    targetTags?: StringFilter<"Campaign"> | string
    sessionName?: StringNullableFilter<"Campaign"> | string | null
    messageType?: StringFilter<"Campaign"> | string
    messageContent?: StringFilter<"Campaign"> | string
    randomDelay?: IntFilter<"Campaign"> | number
    startImmediately?: BoolFilter<"Campaign"> | boolean
    scheduledFor?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    status?: StringFilter<"Campaign"> | string
    totalContacts?: IntFilter<"Campaign"> | number
    sentCount?: IntFilter<"Campaign"> | number
    failedCount?: IntFilter<"Campaign"> | number
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    startTime?: StringNullableFilter<"Campaign"> | string | null
    endTime?: StringNullableFilter<"Campaign"> | string | null
    useTimeWindow?: BoolFilter<"Campaign"> | boolean
    tenantId?: StringNullableFilter<"Campaign"> | string | null
    criadoEm?: DateTimeFilter<"Campaign"> | Date | string
    atualizadoEm?: DateTimeFilter<"Campaign"> | Date | string
    sessionNames?: StringNullableFilter<"Campaign"> | string | null
    createdBy?: StringNullableFilter<"Campaign"> | string | null
    createdByName?: StringNullableFilter<"Campaign"> | string | null
    messages?: CampaignMessageListRelationFilter
    session?: XOR<WhatsAppSessionNullableRelationFilter, WhatsAppSessionWhereInput> | null
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    targetTags?: SortOrder
    sessionName?: SortOrderInput | SortOrder
    messageType?: SortOrder
    messageContent?: SortOrder
    randomDelay?: SortOrder
    startImmediately?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    status?: SortOrder
    totalContacts?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    useTimeWindow?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessionNames?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdByName?: SortOrderInput | SortOrder
    messages?: CampaignMessageOrderByRelationAggregateInput
    session?: WhatsAppSessionOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    nome?: StringFilter<"Campaign"> | string
    targetTags?: StringFilter<"Campaign"> | string
    sessionName?: StringNullableFilter<"Campaign"> | string | null
    messageType?: StringFilter<"Campaign"> | string
    messageContent?: StringFilter<"Campaign"> | string
    randomDelay?: IntFilter<"Campaign"> | number
    startImmediately?: BoolFilter<"Campaign"> | boolean
    scheduledFor?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    status?: StringFilter<"Campaign"> | string
    totalContacts?: IntFilter<"Campaign"> | number
    sentCount?: IntFilter<"Campaign"> | number
    failedCount?: IntFilter<"Campaign"> | number
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    startTime?: StringNullableFilter<"Campaign"> | string | null
    endTime?: StringNullableFilter<"Campaign"> | string | null
    useTimeWindow?: BoolFilter<"Campaign"> | boolean
    tenantId?: StringNullableFilter<"Campaign"> | string | null
    criadoEm?: DateTimeFilter<"Campaign"> | Date | string
    atualizadoEm?: DateTimeFilter<"Campaign"> | Date | string
    sessionNames?: StringNullableFilter<"Campaign"> | string | null
    createdBy?: StringNullableFilter<"Campaign"> | string | null
    createdByName?: StringNullableFilter<"Campaign"> | string | null
    messages?: CampaignMessageListRelationFilter
    session?: XOR<WhatsAppSessionNullableRelationFilter, WhatsAppSessionWhereInput> | null
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    targetTags?: SortOrder
    sessionName?: SortOrderInput | SortOrder
    messageType?: SortOrder
    messageContent?: SortOrder
    randomDelay?: SortOrder
    startImmediately?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    status?: SortOrder
    totalContacts?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    useTimeWindow?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessionNames?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdByName?: SortOrderInput | SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    nome?: StringWithAggregatesFilter<"Campaign"> | string
    targetTags?: StringWithAggregatesFilter<"Campaign"> | string
    sessionName?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    messageType?: StringWithAggregatesFilter<"Campaign"> | string
    messageContent?: StringWithAggregatesFilter<"Campaign"> | string
    randomDelay?: IntWithAggregatesFilter<"Campaign"> | number
    startImmediately?: BoolWithAggregatesFilter<"Campaign"> | boolean
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    status?: StringWithAggregatesFilter<"Campaign"> | string
    totalContacts?: IntWithAggregatesFilter<"Campaign"> | number
    sentCount?: IntWithAggregatesFilter<"Campaign"> | number
    failedCount?: IntWithAggregatesFilter<"Campaign"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    startTime?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    useTimeWindow?: BoolWithAggregatesFilter<"Campaign"> | boolean
    tenantId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    criadoEm?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    sessionNames?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    createdByName?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
  }

  export type CampaignMessageWhereInput = {
    AND?: CampaignMessageWhereInput | CampaignMessageWhereInput[]
    OR?: CampaignMessageWhereInput[]
    NOT?: CampaignMessageWhereInput | CampaignMessageWhereInput[]
    id?: StringFilter<"CampaignMessage"> | string
    campaignId?: StringFilter<"CampaignMessage"> | string
    contactId?: StringFilter<"CampaignMessage"> | string
    contactPhone?: StringFilter<"CampaignMessage"> | string
    contactName?: StringFilter<"CampaignMessage"> | string
    status?: StringFilter<"CampaignMessage"> | string
    sentAt?: DateTimeNullableFilter<"CampaignMessage"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"CampaignMessage"> | Date | string | null
    readAt?: DateTimeNullableFilter<"CampaignMessage"> | Date | string | null
    errorMessage?: StringNullableFilter<"CampaignMessage"> | string | null
    messageId?: StringNullableFilter<"CampaignMessage"> | string | null
    selectedVariation?: StringNullableFilter<"CampaignMessage"> | string | null
    tenantId?: StringNullableFilter<"CampaignMessage"> | string | null
    criadoEm?: DateTimeFilter<"CampaignMessage"> | Date | string
    atualizadoEm?: DateTimeFilter<"CampaignMessage"> | Date | string
    sessionName?: StringNullableFilter<"CampaignMessage"> | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }

  export type CampaignMessageOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    contactPhone?: SortOrder
    contactName?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    selectedVariation?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessionName?: SortOrderInput | SortOrder
    campaign?: CampaignOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type CampaignMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignMessageWhereInput | CampaignMessageWhereInput[]
    OR?: CampaignMessageWhereInput[]
    NOT?: CampaignMessageWhereInput | CampaignMessageWhereInput[]
    campaignId?: StringFilter<"CampaignMessage"> | string
    contactId?: StringFilter<"CampaignMessage"> | string
    contactPhone?: StringFilter<"CampaignMessage"> | string
    contactName?: StringFilter<"CampaignMessage"> | string
    status?: StringFilter<"CampaignMessage"> | string
    sentAt?: DateTimeNullableFilter<"CampaignMessage"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"CampaignMessage"> | Date | string | null
    readAt?: DateTimeNullableFilter<"CampaignMessage"> | Date | string | null
    errorMessage?: StringNullableFilter<"CampaignMessage"> | string | null
    messageId?: StringNullableFilter<"CampaignMessage"> | string | null
    selectedVariation?: StringNullableFilter<"CampaignMessage"> | string | null
    tenantId?: StringNullableFilter<"CampaignMessage"> | string | null
    criadoEm?: DateTimeFilter<"CampaignMessage"> | Date | string
    atualizadoEm?: DateTimeFilter<"CampaignMessage"> | Date | string
    sessionName?: StringNullableFilter<"CampaignMessage"> | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }, "id">

  export type CampaignMessageOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    contactPhone?: SortOrder
    contactName?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    selectedVariation?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessionName?: SortOrderInput | SortOrder
    _count?: CampaignMessageCountOrderByAggregateInput
    _max?: CampaignMessageMaxOrderByAggregateInput
    _min?: CampaignMessageMinOrderByAggregateInput
  }

  export type CampaignMessageScalarWhereWithAggregatesInput = {
    AND?: CampaignMessageScalarWhereWithAggregatesInput | CampaignMessageScalarWhereWithAggregatesInput[]
    OR?: CampaignMessageScalarWhereWithAggregatesInput[]
    NOT?: CampaignMessageScalarWhereWithAggregatesInput | CampaignMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignMessage"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignMessage"> | string
    contactId?: StringWithAggregatesFilter<"CampaignMessage"> | string
    contactPhone?: StringWithAggregatesFilter<"CampaignMessage"> | string
    contactName?: StringWithAggregatesFilter<"CampaignMessage"> | string
    status?: StringWithAggregatesFilter<"CampaignMessage"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"CampaignMessage"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"CampaignMessage"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"CampaignMessage"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"CampaignMessage"> | string | null
    messageId?: StringNullableWithAggregatesFilter<"CampaignMessage"> | string | null
    selectedVariation?: StringNullableWithAggregatesFilter<"CampaignMessage"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"CampaignMessage"> | string | null
    criadoEm?: DateTimeWithAggregatesFilter<"CampaignMessage"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"CampaignMessage"> | Date | string
    sessionName?: StringNullableWithAggregatesFilter<"CampaignMessage"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    nome?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    senha?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    ativo?: BoolFilter<"User"> | boolean
    tenantId?: StringNullableFilter<"User"> | string | null
    ultimoLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    criadoEm?: DateTimeFilter<"User"> | Date | string
    atualizadoEm?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    tenants?: UserTenantListRelationFilter
    alerts?: AlertListRelationFilter
    notifications?: NotificationListRelationFilter
    userNotifications?: UserNotificationListRelationFilter
    createdTemplates?: MessageTemplateListRelationFilter
    createdFlows?: AutomationFlowListRelationFilter
    createdIntegrations?: IntegrationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    role?: SortOrder
    ativo?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    ultimoLogin?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    tenants?: UserTenantOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    userNotifications?: UserNotificationOrderByRelationAggregateInput
    createdTemplates?: MessageTemplateOrderByRelationAggregateInput
    createdFlows?: AutomationFlowOrderByRelationAggregateInput
    createdIntegrations?: IntegrationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    nome?: StringFilter<"User"> | string
    senha?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    ativo?: BoolFilter<"User"> | boolean
    tenantId?: StringNullableFilter<"User"> | string | null
    ultimoLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    criadoEm?: DateTimeFilter<"User"> | Date | string
    atualizadoEm?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    tenants?: UserTenantListRelationFilter
    alerts?: AlertListRelationFilter
    notifications?: NotificationListRelationFilter
    userNotifications?: UserNotificationListRelationFilter
    createdTemplates?: MessageTemplateListRelationFilter
    createdFlows?: AutomationFlowListRelationFilter
    createdIntegrations?: IntegrationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    role?: SortOrder
    ativo?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    ultimoLogin?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    nome?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    senha?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    ativo?: BoolWithAggregatesFilter<"User"> | boolean
    tenantId?: StringNullableWithAggregatesFilter<"User"> | string | null
    ultimoLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    criadoEm?: DateTimeWithAggregatesFilter<"User"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    severity?: EnumAlertSeverityFilter<"Alert"> | $Enums.AlertSeverity
    title?: StringFilter<"Alert"> | string
    message?: StringFilter<"Alert"> | string
    tenantId?: StringNullableFilter<"Alert"> | string | null
    userId?: StringNullableFilter<"Alert"> | string | null
    metadata?: JsonNullableFilter<"Alert">
    resolved?: BoolFilter<"Alert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    resolvedBy?: StringNullableFilter<"Alert"> | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    notifications?: NotificationListRelationFilter
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    message?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    severity?: EnumAlertSeverityFilter<"Alert"> | $Enums.AlertSeverity
    title?: StringFilter<"Alert"> | string
    message?: StringFilter<"Alert"> | string
    tenantId?: StringNullableFilter<"Alert"> | string | null
    userId?: StringNullableFilter<"Alert"> | string | null
    metadata?: JsonNullableFilter<"Alert">
    resolved?: BoolFilter<"Alert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    resolvedBy?: StringNullableFilter<"Alert"> | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    notifications?: NotificationListRelationFilter
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    message?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    type?: EnumAlertTypeWithAggregatesFilter<"Alert"> | $Enums.AlertType
    severity?: EnumAlertSeverityWithAggregatesFilter<"Alert"> | $Enums.AlertSeverity
    title?: StringWithAggregatesFilter<"Alert"> | string
    message?: StringWithAggregatesFilter<"Alert"> | string
    tenantId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Alert">
    resolved?: BoolWithAggregatesFilter<"Alert"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    alertId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    method?: EnumNotificationMethodFilter<"Notification"> | $Enums.NotificationMethod
    sent?: BoolFilter<"Notification"> | boolean
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    alert?: XOR<AlertRelationFilter, AlertWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    alertId?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    alert?: AlertOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    alertId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    method?: EnumNotificationMethodFilter<"Notification"> | $Enums.NotificationMethod
    sent?: BoolFilter<"Notification"> | boolean
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    alert?: XOR<AlertRelationFilter, AlertWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    alertId?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    alertId?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    method?: EnumNotificationMethodWithAggregatesFilter<"Notification"> | $Enums.NotificationMethod
    sent?: BoolWithAggregatesFilter<"Notification"> | boolean
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type UserNotificationWhereInput = {
    AND?: UserNotificationWhereInput | UserNotificationWhereInput[]
    OR?: UserNotificationWhereInput[]
    NOT?: UserNotificationWhereInput | UserNotificationWhereInput[]
    id?: StringFilter<"UserNotification"> | string
    userId?: StringFilter<"UserNotification"> | string
    title?: StringFilter<"UserNotification"> | string
    message?: StringFilter<"UserNotification"> | string
    type?: EnumUserNotificationTypeFilter<"UserNotification"> | $Enums.UserNotificationType
    data?: JsonNullableFilter<"UserNotification">
    read?: BoolFilter<"UserNotification"> | boolean
    readAt?: DateTimeNullableFilter<"UserNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"UserNotification"> | Date | string
    updatedAt?: DateTimeFilter<"UserNotification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserNotificationWhereInput | UserNotificationWhereInput[]
    OR?: UserNotificationWhereInput[]
    NOT?: UserNotificationWhereInput | UserNotificationWhereInput[]
    userId?: StringFilter<"UserNotification"> | string
    title?: StringFilter<"UserNotification"> | string
    message?: StringFilter<"UserNotification"> | string
    type?: EnumUserNotificationTypeFilter<"UserNotification"> | $Enums.UserNotificationType
    data?: JsonNullableFilter<"UserNotification">
    read?: BoolFilter<"UserNotification"> | boolean
    readAt?: DateTimeNullableFilter<"UserNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"UserNotification"> | Date | string
    updatedAt?: DateTimeFilter<"UserNotification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserNotificationCountOrderByAggregateInput
    _max?: UserNotificationMaxOrderByAggregateInput
    _min?: UserNotificationMinOrderByAggregateInput
  }

  export type UserNotificationScalarWhereWithAggregatesInput = {
    AND?: UserNotificationScalarWhereWithAggregatesInput | UserNotificationScalarWhereWithAggregatesInput[]
    OR?: UserNotificationScalarWhereWithAggregatesInput[]
    NOT?: UserNotificationScalarWhereWithAggregatesInput | UserNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserNotification"> | string
    userId?: StringWithAggregatesFilter<"UserNotification"> | string
    title?: StringWithAggregatesFilter<"UserNotification"> | string
    message?: StringWithAggregatesFilter<"UserNotification"> | string
    type?: EnumUserNotificationTypeWithAggregatesFilter<"UserNotification"> | $Enums.UserNotificationType
    data?: JsonNullableWithAggregatesFilter<"UserNotification">
    read?: BoolWithAggregatesFilter<"UserNotification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"UserNotification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserNotification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserNotification"> | Date | string
  }

  export type MessageTemplateWhereInput = {
    AND?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    OR?: MessageTemplateWhereInput[]
    NOT?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    id?: StringFilter<"MessageTemplate"> | string
    name?: StringFilter<"MessageTemplate"> | string
    tenantId?: StringFilter<"MessageTemplate"> | string
    category?: StringFilter<"MessageTemplate"> | string
    messageType?: EnumMessageTypeFilter<"MessageTemplate"> | $Enums.MessageType
    content?: StringFilter<"MessageTemplate"> | string
    variables?: StringNullableListFilter<"MessageTemplate">
    mediaUrl?: StringNullableFilter<"MessageTemplate"> | string | null
    active?: BoolFilter<"MessageTemplate"> | boolean
    tags?: StringNullableListFilter<"MessageTemplate">
    description?: StringNullableFilter<"MessageTemplate"> | string | null
    createdBy?: StringFilter<"MessageTemplate"> | string
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    active?: SortOrder
    tags?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type MessageTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    OR?: MessageTemplateWhereInput[]
    NOT?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    name?: StringFilter<"MessageTemplate"> | string
    tenantId?: StringFilter<"MessageTemplate"> | string
    category?: StringFilter<"MessageTemplate"> | string
    messageType?: EnumMessageTypeFilter<"MessageTemplate"> | $Enums.MessageType
    content?: StringFilter<"MessageTemplate"> | string
    variables?: StringNullableListFilter<"MessageTemplate">
    mediaUrl?: StringNullableFilter<"MessageTemplate"> | string | null
    active?: BoolFilter<"MessageTemplate"> | boolean
    tags?: StringNullableListFilter<"MessageTemplate">
    description?: StringNullableFilter<"MessageTemplate"> | string | null
    createdBy?: StringFilter<"MessageTemplate"> | string
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    active?: SortOrder
    tags?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageTemplateCountOrderByAggregateInput
    _max?: MessageTemplateMaxOrderByAggregateInput
    _min?: MessageTemplateMinOrderByAggregateInput
  }

  export type MessageTemplateScalarWhereWithAggregatesInput = {
    AND?: MessageTemplateScalarWhereWithAggregatesInput | MessageTemplateScalarWhereWithAggregatesInput[]
    OR?: MessageTemplateScalarWhereWithAggregatesInput[]
    NOT?: MessageTemplateScalarWhereWithAggregatesInput | MessageTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageTemplate"> | string
    name?: StringWithAggregatesFilter<"MessageTemplate"> | string
    tenantId?: StringWithAggregatesFilter<"MessageTemplate"> | string
    category?: StringWithAggregatesFilter<"MessageTemplate"> | string
    messageType?: EnumMessageTypeWithAggregatesFilter<"MessageTemplate"> | $Enums.MessageType
    content?: StringWithAggregatesFilter<"MessageTemplate"> | string
    variables?: StringNullableListFilter<"MessageTemplate">
    mediaUrl?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    active?: BoolWithAggregatesFilter<"MessageTemplate"> | boolean
    tags?: StringNullableListFilter<"MessageTemplate">
    description?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    createdBy?: StringWithAggregatesFilter<"MessageTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageTemplate"> | Date | string
  }

  export type AutomationFlowWhereInput = {
    AND?: AutomationFlowWhereInput | AutomationFlowWhereInput[]
    OR?: AutomationFlowWhereInput[]
    NOT?: AutomationFlowWhereInput | AutomationFlowWhereInput[]
    id?: StringFilter<"AutomationFlow"> | string
    name?: StringFilter<"AutomationFlow"> | string
    description?: StringNullableFilter<"AutomationFlow"> | string | null
    tenantId?: StringFilter<"AutomationFlow"> | string
    active?: BoolFilter<"AutomationFlow"> | boolean
    trigger?: JsonFilter<"AutomationFlow">
    conditions?: JsonNullableFilter<"AutomationFlow">
    actions?: JsonFilter<"AutomationFlow">
    createdBy?: StringFilter<"AutomationFlow"> | string
    createdAt?: DateTimeFilter<"AutomationFlow"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationFlow"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    executions?: AutomationExecutionListRelationFilter
  }

  export type AutomationFlowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    active?: SortOrder
    trigger?: SortOrder
    conditions?: SortOrderInput | SortOrder
    actions?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    executions?: AutomationExecutionOrderByRelationAggregateInput
  }

  export type AutomationFlowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationFlowWhereInput | AutomationFlowWhereInput[]
    OR?: AutomationFlowWhereInput[]
    NOT?: AutomationFlowWhereInput | AutomationFlowWhereInput[]
    name?: StringFilter<"AutomationFlow"> | string
    description?: StringNullableFilter<"AutomationFlow"> | string | null
    tenantId?: StringFilter<"AutomationFlow"> | string
    active?: BoolFilter<"AutomationFlow"> | boolean
    trigger?: JsonFilter<"AutomationFlow">
    conditions?: JsonNullableFilter<"AutomationFlow">
    actions?: JsonFilter<"AutomationFlow">
    createdBy?: StringFilter<"AutomationFlow"> | string
    createdAt?: DateTimeFilter<"AutomationFlow"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationFlow"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    executions?: AutomationExecutionListRelationFilter
  }, "id">

  export type AutomationFlowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    active?: SortOrder
    trigger?: SortOrder
    conditions?: SortOrderInput | SortOrder
    actions?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AutomationFlowCountOrderByAggregateInput
    _max?: AutomationFlowMaxOrderByAggregateInput
    _min?: AutomationFlowMinOrderByAggregateInput
  }

  export type AutomationFlowScalarWhereWithAggregatesInput = {
    AND?: AutomationFlowScalarWhereWithAggregatesInput | AutomationFlowScalarWhereWithAggregatesInput[]
    OR?: AutomationFlowScalarWhereWithAggregatesInput[]
    NOT?: AutomationFlowScalarWhereWithAggregatesInput | AutomationFlowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationFlow"> | string
    name?: StringWithAggregatesFilter<"AutomationFlow"> | string
    description?: StringNullableWithAggregatesFilter<"AutomationFlow"> | string | null
    tenantId?: StringWithAggregatesFilter<"AutomationFlow"> | string
    active?: BoolWithAggregatesFilter<"AutomationFlow"> | boolean
    trigger?: JsonWithAggregatesFilter<"AutomationFlow">
    conditions?: JsonNullableWithAggregatesFilter<"AutomationFlow">
    actions?: JsonWithAggregatesFilter<"AutomationFlow">
    createdBy?: StringWithAggregatesFilter<"AutomationFlow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AutomationFlow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutomationFlow"> | Date | string
  }

  export type AutomationExecutionWhereInput = {
    AND?: AutomationExecutionWhereInput | AutomationExecutionWhereInput[]
    OR?: AutomationExecutionWhereInput[]
    NOT?: AutomationExecutionWhereInput | AutomationExecutionWhereInput[]
    id?: StringFilter<"AutomationExecution"> | string
    flowId?: StringFilter<"AutomationExecution"> | string
    status?: StringFilter<"AutomationExecution"> | string
    executedAt?: DateTimeFilter<"AutomationExecution"> | Date | string
    context?: JsonNullableFilter<"AutomationExecution">
    error?: StringNullableFilter<"AutomationExecution"> | string | null
    duration?: IntNullableFilter<"AutomationExecution"> | number | null
    flow?: XOR<AutomationFlowRelationFilter, AutomationFlowWhereInput>
  }

  export type AutomationExecutionOrderByWithRelationInput = {
    id?: SortOrder
    flowId?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    context?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    flow?: AutomationFlowOrderByWithRelationInput
  }

  export type AutomationExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationExecutionWhereInput | AutomationExecutionWhereInput[]
    OR?: AutomationExecutionWhereInput[]
    NOT?: AutomationExecutionWhereInput | AutomationExecutionWhereInput[]
    flowId?: StringFilter<"AutomationExecution"> | string
    status?: StringFilter<"AutomationExecution"> | string
    executedAt?: DateTimeFilter<"AutomationExecution"> | Date | string
    context?: JsonNullableFilter<"AutomationExecution">
    error?: StringNullableFilter<"AutomationExecution"> | string | null
    duration?: IntNullableFilter<"AutomationExecution"> | number | null
    flow?: XOR<AutomationFlowRelationFilter, AutomationFlowWhereInput>
  }, "id">

  export type AutomationExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    flowId?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    context?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    _count?: AutomationExecutionCountOrderByAggregateInput
    _avg?: AutomationExecutionAvgOrderByAggregateInput
    _max?: AutomationExecutionMaxOrderByAggregateInput
    _min?: AutomationExecutionMinOrderByAggregateInput
    _sum?: AutomationExecutionSumOrderByAggregateInput
  }

  export type AutomationExecutionScalarWhereWithAggregatesInput = {
    AND?: AutomationExecutionScalarWhereWithAggregatesInput | AutomationExecutionScalarWhereWithAggregatesInput[]
    OR?: AutomationExecutionScalarWhereWithAggregatesInput[]
    NOT?: AutomationExecutionScalarWhereWithAggregatesInput | AutomationExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationExecution"> | string
    flowId?: StringWithAggregatesFilter<"AutomationExecution"> | string
    status?: StringWithAggregatesFilter<"AutomationExecution"> | string
    executedAt?: DateTimeWithAggregatesFilter<"AutomationExecution"> | Date | string
    context?: JsonNullableWithAggregatesFilter<"AutomationExecution">
    error?: StringNullableWithAggregatesFilter<"AutomationExecution"> | string | null
    duration?: IntNullableWithAggregatesFilter<"AutomationExecution"> | number | null
  }

  export type IntegrationWhereInput = {
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    id?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    type?: EnumIntegrationTypeFilter<"Integration"> | $Enums.IntegrationType
    tenantId?: StringFilter<"Integration"> | string
    active?: BoolFilter<"Integration"> | boolean
    config?: JsonFilter<"Integration">
    credentials?: JsonNullableFilter<"Integration">
    webhookUrl?: StringNullableFilter<"Integration"> | string | null
    lastSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    lastError?: StringNullableFilter<"Integration"> | string | null
    createdBy?: StringFilter<"Integration"> | string
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    syncLogs?: IntegrationSyncListRelationFilter
  }

  export type IntegrationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tenantId?: SortOrder
    active?: SortOrder
    config?: SortOrder
    credentials?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    syncLogs?: IntegrationSyncOrderByRelationAggregateInput
  }

  export type IntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    name?: StringFilter<"Integration"> | string
    type?: EnumIntegrationTypeFilter<"Integration"> | $Enums.IntegrationType
    tenantId?: StringFilter<"Integration"> | string
    active?: BoolFilter<"Integration"> | boolean
    config?: JsonFilter<"Integration">
    credentials?: JsonNullableFilter<"Integration">
    webhookUrl?: StringNullableFilter<"Integration"> | string | null
    lastSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    lastError?: StringNullableFilter<"Integration"> | string | null
    createdBy?: StringFilter<"Integration"> | string
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    syncLogs?: IntegrationSyncListRelationFilter
  }, "id">

  export type IntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tenantId?: SortOrder
    active?: SortOrder
    config?: SortOrder
    credentials?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegrationCountOrderByAggregateInput
    _max?: IntegrationMaxOrderByAggregateInput
    _min?: IntegrationMinOrderByAggregateInput
  }

  export type IntegrationScalarWhereWithAggregatesInput = {
    AND?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    OR?: IntegrationScalarWhereWithAggregatesInput[]
    NOT?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Integration"> | string
    name?: StringWithAggregatesFilter<"Integration"> | string
    type?: EnumIntegrationTypeWithAggregatesFilter<"Integration"> | $Enums.IntegrationType
    tenantId?: StringWithAggregatesFilter<"Integration"> | string
    active?: BoolWithAggregatesFilter<"Integration"> | boolean
    config?: JsonWithAggregatesFilter<"Integration">
    credentials?: JsonNullableWithAggregatesFilter<"Integration">
    webhookUrl?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"Integration"> | Date | string | null
    lastError?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    createdBy?: StringWithAggregatesFilter<"Integration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
  }

  export type IntegrationSyncWhereInput = {
    AND?: IntegrationSyncWhereInput | IntegrationSyncWhereInput[]
    OR?: IntegrationSyncWhereInput[]
    NOT?: IntegrationSyncWhereInput | IntegrationSyncWhereInput[]
    id?: StringFilter<"IntegrationSync"> | string
    integrationId?: StringFilter<"IntegrationSync"> | string
    type?: StringFilter<"IntegrationSync"> | string
    status?: StringFilter<"IntegrationSync"> | string
    recordsCount?: IntNullableFilter<"IntegrationSync"> | number | null
    errorMessage?: StringNullableFilter<"IntegrationSync"> | string | null
    metadata?: JsonNullableFilter<"IntegrationSync">
    startedAt?: DateTimeFilter<"IntegrationSync"> | Date | string
    completedAt?: DateTimeNullableFilter<"IntegrationSync"> | Date | string | null
    integration?: XOR<IntegrationRelationFilter, IntegrationWhereInput>
  }

  export type IntegrationSyncOrderByWithRelationInput = {
    id?: SortOrder
    integrationId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recordsCount?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    integration?: IntegrationOrderByWithRelationInput
  }

  export type IntegrationSyncWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntegrationSyncWhereInput | IntegrationSyncWhereInput[]
    OR?: IntegrationSyncWhereInput[]
    NOT?: IntegrationSyncWhereInput | IntegrationSyncWhereInput[]
    integrationId?: StringFilter<"IntegrationSync"> | string
    type?: StringFilter<"IntegrationSync"> | string
    status?: StringFilter<"IntegrationSync"> | string
    recordsCount?: IntNullableFilter<"IntegrationSync"> | number | null
    errorMessage?: StringNullableFilter<"IntegrationSync"> | string | null
    metadata?: JsonNullableFilter<"IntegrationSync">
    startedAt?: DateTimeFilter<"IntegrationSync"> | Date | string
    completedAt?: DateTimeNullableFilter<"IntegrationSync"> | Date | string | null
    integration?: XOR<IntegrationRelationFilter, IntegrationWhereInput>
  }, "id">

  export type IntegrationSyncOrderByWithAggregationInput = {
    id?: SortOrder
    integrationId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recordsCount?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: IntegrationSyncCountOrderByAggregateInput
    _avg?: IntegrationSyncAvgOrderByAggregateInput
    _max?: IntegrationSyncMaxOrderByAggregateInput
    _min?: IntegrationSyncMinOrderByAggregateInput
    _sum?: IntegrationSyncSumOrderByAggregateInput
  }

  export type IntegrationSyncScalarWhereWithAggregatesInput = {
    AND?: IntegrationSyncScalarWhereWithAggregatesInput | IntegrationSyncScalarWhereWithAggregatesInput[]
    OR?: IntegrationSyncScalarWhereWithAggregatesInput[]
    NOT?: IntegrationSyncScalarWhereWithAggregatesInput | IntegrationSyncScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntegrationSync"> | string
    integrationId?: StringWithAggregatesFilter<"IntegrationSync"> | string
    type?: StringWithAggregatesFilter<"IntegrationSync"> | string
    status?: StringWithAggregatesFilter<"IntegrationSync"> | string
    recordsCount?: IntNullableWithAggregatesFilter<"IntegrationSync"> | number | null
    errorMessage?: StringNullableWithAggregatesFilter<"IntegrationSync"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"IntegrationSync">
    startedAt?: DateTimeWithAggregatesFilter<"IntegrationSync"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"IntegrationSync"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    severity?: StringFilter<"AuditLog"> | string
    tenantId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    severity?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    details?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: StringFilter<"AuditLog"> | string
    severity?: StringFilter<"AuditLog"> | string
    tenantId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    severity?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    details?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    severity?: StringWithAggregatesFilter<"AuditLog"> | string
    tenantId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    entityType?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantQuotaCreateInput = {
    id?: string
    maxUsers?: number
    maxContacts?: number
    maxCampaigns?: number
    maxConnections?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutQuotasInput
  }

  export type TenantQuotaUncheckedCreateInput = {
    id?: string
    tenantId: string
    maxUsers?: number
    maxContacts?: number
    maxCampaigns?: number
    maxConnections?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantQuotaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxContacts?: IntFieldUpdateOperationsInput | number
    maxCampaigns?: IntFieldUpdateOperationsInput | number
    maxConnections?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutQuotasNestedInput
  }

  export type TenantQuotaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxContacts?: IntFieldUpdateOperationsInput | number
    maxCampaigns?: IntFieldUpdateOperationsInput | number
    maxConnections?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantQuotaCreateManyInput = {
    id?: string
    tenantId: string
    maxUsers?: number
    maxContacts?: number
    maxCampaigns?: number
    maxConnections?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantQuotaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxContacts?: IntFieldUpdateOperationsInput | number
    maxCampaigns?: IntFieldUpdateOperationsInput | number
    maxConnections?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantQuotaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxContacts?: IntFieldUpdateOperationsInput | number
    maxCampaigns?: IntFieldUpdateOperationsInput | number
    maxConnections?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsCreateInput = {
    id?: string
    openaiApiKey?: string | null
    groqApiKey?: string | null
    customBranding?: NullableJsonNullValueInput | InputJsonValue
    chatwootUrl?: string | null
    chatwootAccountId?: string | null
    chatwootApiToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSettingsInput
  }

  export type TenantSettingsUncheckedCreateInput = {
    id?: string
    tenantId: string
    openaiApiKey?: string | null
    groqApiKey?: string | null
    customBranding?: NullableJsonNullValueInput | InputJsonValue
    chatwootUrl?: string | null
    chatwootAccountId?: string | null
    chatwootApiToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    customBranding?: NullableJsonNullValueInput | InputJsonValue
    chatwootUrl?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type TenantSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    customBranding?: NullableJsonNullValueInput | InputJsonValue
    chatwootUrl?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsCreateManyInput = {
    id?: string
    tenantId: string
    openaiApiKey?: string | null
    groqApiKey?: string | null
    customBranding?: NullableJsonNullValueInput | InputJsonValue
    chatwootUrl?: string | null
    chatwootAccountId?: string | null
    chatwootApiToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    customBranding?: NullableJsonNullValueInput | InputJsonValue
    chatwootUrl?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    customBranding?: NullableJsonNullValueInput | InputJsonValue
    chatwootUrl?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTenantCreateInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTenantsInput
    tenant: TenantCreateNestedOneWithoutUserTenantsInput
  }

  export type UserTenantUncheckedCreateInput = {
    id?: string
    userId: string
    tenantId: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTenantsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUserTenantsNestedInput
  }

  export type UserTenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTenantCreateManyInput = {
    id?: string
    userId: string
    tenantId: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalSettingsCreateInput = {
    id?: string
    singleton?: boolean
    wahaHost?: string
    wahaApiKey?: string
    evolutionHost?: string
    evolutionApiKey?: string
    quepasaUrl?: string
    quepasaLogin?: string
    quepasaPassword?: string
    logoUrl?: string | null
    faviconUrl?: string | null
    iconUrl?: string | null
    companyName?: string | null
    pageTitle?: string | null
    primaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalSettingsUncheckedCreateInput = {
    id?: string
    singleton?: boolean
    wahaHost?: string
    wahaApiKey?: string
    evolutionHost?: string
    evolutionApiKey?: string
    quepasaUrl?: string
    quepasaLogin?: string
    quepasaPassword?: string
    logoUrl?: string | null
    faviconUrl?: string | null
    iconUrl?: string | null
    companyName?: string | null
    pageTitle?: string | null
    primaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    singleton?: BoolFieldUpdateOperationsInput | boolean
    wahaHost?: StringFieldUpdateOperationsInput | string
    wahaApiKey?: StringFieldUpdateOperationsInput | string
    evolutionHost?: StringFieldUpdateOperationsInput | string
    evolutionApiKey?: StringFieldUpdateOperationsInput | string
    quepasaUrl?: StringFieldUpdateOperationsInput | string
    quepasaLogin?: StringFieldUpdateOperationsInput | string
    quepasaPassword?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    pageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    singleton?: BoolFieldUpdateOperationsInput | boolean
    wahaHost?: StringFieldUpdateOperationsInput | string
    wahaApiKey?: StringFieldUpdateOperationsInput | string
    evolutionHost?: StringFieldUpdateOperationsInput | string
    evolutionApiKey?: StringFieldUpdateOperationsInput | string
    quepasaUrl?: StringFieldUpdateOperationsInput | string
    quepasaLogin?: StringFieldUpdateOperationsInput | string
    quepasaPassword?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    pageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalSettingsCreateManyInput = {
    id?: string
    singleton?: boolean
    wahaHost?: string
    wahaApiKey?: string
    evolutionHost?: string
    evolutionApiKey?: string
    quepasaUrl?: string
    quepasaLogin?: string
    quepasaPassword?: string
    logoUrl?: string | null
    faviconUrl?: string | null
    iconUrl?: string | null
    companyName?: string | null
    pageTitle?: string | null
    primaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    singleton?: BoolFieldUpdateOperationsInput | boolean
    wahaHost?: StringFieldUpdateOperationsInput | string
    wahaApiKey?: StringFieldUpdateOperationsInput | string
    evolutionHost?: StringFieldUpdateOperationsInput | string
    evolutionApiKey?: StringFieldUpdateOperationsInput | string
    quepasaUrl?: StringFieldUpdateOperationsInput | string
    quepasaLogin?: StringFieldUpdateOperationsInput | string
    quepasaPassword?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    pageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    singleton?: BoolFieldUpdateOperationsInput | boolean
    wahaHost?: StringFieldUpdateOperationsInput | string
    wahaApiKey?: StringFieldUpdateOperationsInput | string
    evolutionHost?: StringFieldUpdateOperationsInput | string
    evolutionApiKey?: StringFieldUpdateOperationsInput | string
    quepasaUrl?: StringFieldUpdateOperationsInput | string
    quepasaLogin?: StringFieldUpdateOperationsInput | string
    quepasaPassword?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    pageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    tags?: ContactCreatetagsInput | string[]
    observacoes?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    categoria?: CategoryCreateNestedOneWithoutContactsInput
    tenant?: TenantCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    tags?: ContactCreatetagsInput | string[]
    observacoes?: string | null
    categoriaId?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    categoria?: CategoryUpdateOneWithoutContactsNestedInput
    tenant?: TenantUpdateOneWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    categoriaId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    tags?: ContactCreatetagsInput | string[]
    observacoes?: string | null
    categoriaId?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    categoriaId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    nome: string
    cor: string
    descricao?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    contacts?: ContactCreateNestedManyWithoutCategoriaInput
    tenant?: TenantCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    nome: string
    cor: string
    descricao?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCategoriaNestedInput
    tenant?: TenantUpdateOneWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    nome: string
    cor: string
    descricao?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppSessionCreateInput = {
    id?: string
    name: string
    displayName?: string | null
    status: string
    config?: string | null
    meId?: string | null
    mePushName?: string | null
    meLid?: string | null
    meJid?: string | null
    qr?: string | null
    qrExpiresAt?: Date | string | null
    assignedWorker?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    provider?: string
    quepasaToken?: string | null
    campaigns?: CampaignCreateNestedManyWithoutSessionInput
    tenant?: TenantCreateNestedOneWithoutWhatsappSessionsInput
  }

  export type WhatsAppSessionUncheckedCreateInput = {
    id?: string
    name: string
    displayName?: string | null
    status: string
    config?: string | null
    meId?: string | null
    mePushName?: string | null
    meLid?: string | null
    meJid?: string | null
    qr?: string | null
    qrExpiresAt?: Date | string | null
    assignedWorker?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    provider?: string
    quepasaToken?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: NullableStringFieldUpdateOperationsInput | string | null
    meId?: NullableStringFieldUpdateOperationsInput | string | null
    mePushName?: NullableStringFieldUpdateOperationsInput | string | null
    meLid?: NullableStringFieldUpdateOperationsInput | string | null
    meJid?: NullableStringFieldUpdateOperationsInput | string | null
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedWorker?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    quepasaToken?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUpdateManyWithoutSessionNestedInput
    tenant?: TenantUpdateOneWithoutWhatsappSessionsNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: NullableStringFieldUpdateOperationsInput | string | null
    meId?: NullableStringFieldUpdateOperationsInput | string | null
    mePushName?: NullableStringFieldUpdateOperationsInput | string | null
    meLid?: NullableStringFieldUpdateOperationsInput | string | null
    meJid?: NullableStringFieldUpdateOperationsInput | string | null
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedWorker?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    quepasaToken?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionCreateManyInput = {
    id?: string
    name: string
    displayName?: string | null
    status: string
    config?: string | null
    meId?: string | null
    mePushName?: string | null
    meLid?: string | null
    meJid?: string | null
    qr?: string | null
    qrExpiresAt?: Date | string | null
    assignedWorker?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    provider?: string
    quepasaToken?: string | null
  }

  export type WhatsAppSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: NullableStringFieldUpdateOperationsInput | string | null
    meId?: NullableStringFieldUpdateOperationsInput | string | null
    mePushName?: NullableStringFieldUpdateOperationsInput | string | null
    meLid?: NullableStringFieldUpdateOperationsInput | string | null
    meJid?: NullableStringFieldUpdateOperationsInput | string | null
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedWorker?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    quepasaToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsAppSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: NullableStringFieldUpdateOperationsInput | string | null
    meId?: NullableStringFieldUpdateOperationsInput | string | null
    mePushName?: NullableStringFieldUpdateOperationsInput | string | null
    meLid?: NullableStringFieldUpdateOperationsInput | string | null
    meJid?: NullableStringFieldUpdateOperationsInput | string | null
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedWorker?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    quepasaToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignCreateInput = {
    id?: string
    nome: string
    targetTags: string
    messageType: string
    messageContent: string
    randomDelay: number
    startImmediately: boolean
    scheduledFor?: Date | string | null
    status?: string
    totalContacts?: number
    sentCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    useTimeWindow?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionNames?: string | null
    createdBy?: string | null
    createdByName?: string | null
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    session?: WhatsAppSessionCreateNestedOneWithoutCampaignsInput
    tenant?: TenantCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    nome: string
    targetTags: string
    sessionName?: string | null
    messageType: string
    messageContent: string
    randomDelay: number
    startImmediately: boolean
    scheduledFor?: Date | string | null
    status?: string
    totalContacts?: number
    sentCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    useTimeWindow?: boolean
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionNames?: string | null
    createdBy?: string | null
    createdByName?: string | null
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    targetTags?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    randomDelay?: IntFieldUpdateOperationsInput | number
    startImmediately?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalContacts?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    useTimeWindow?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionNames?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    session?: WhatsAppSessionUpdateOneWithoutCampaignsNestedInput
    tenant?: TenantUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    targetTags?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    randomDelay?: IntFieldUpdateOperationsInput | number
    startImmediately?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalContacts?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    useTimeWindow?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionNames?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    nome: string
    targetTags: string
    sessionName?: string | null
    messageType: string
    messageContent: string
    randomDelay: number
    startImmediately: boolean
    scheduledFor?: Date | string | null
    status?: string
    totalContacts?: number
    sentCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    useTimeWindow?: boolean
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionNames?: string | null
    createdBy?: string | null
    createdByName?: string | null
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    targetTags?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    randomDelay?: IntFieldUpdateOperationsInput | number
    startImmediately?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalContacts?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    useTimeWindow?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionNames?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    targetTags?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    randomDelay?: IntFieldUpdateOperationsInput | number
    startImmediately?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalContacts?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    useTimeWindow?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionNames?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignMessageCreateInput = {
    id?: string
    contactId: string
    contactPhone: string
    contactName: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    errorMessage?: string | null
    messageId?: string | null
    selectedVariation?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionName?: string | null
    campaign: CampaignCreateNestedOneWithoutMessagesInput
    tenant?: TenantCreateNestedOneWithoutCampaignMessagesInput
  }

  export type CampaignMessageUncheckedCreateInput = {
    id?: string
    campaignId: string
    contactId: string
    contactPhone: string
    contactName: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    errorMessage?: string | null
    messageId?: string | null
    selectedVariation?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionName?: string | null
  }

  export type CampaignMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedVariation?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: CampaignUpdateOneRequiredWithoutMessagesNestedInput
    tenant?: TenantUpdateOneWithoutCampaignMessagesNestedInput
  }

  export type CampaignMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedVariation?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignMessageCreateManyInput = {
    id?: string
    campaignId: string
    contactId: string
    contactPhone: string
    contactName: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    errorMessage?: string | null
    messageId?: string | null
    selectedVariation?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionName?: string | null
  }

  export type CampaignMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedVariation?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedVariation?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    tenants?: UserTenantCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    tenantId?: string | null
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenants?: UserTenantUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    tenants?: UserTenantUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: UserTenantUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    tenantId?: string | null
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateInput = {
    id?: string
    type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    title: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutAlertsInput
    user?: UserCreateNestedOneWithoutAlertsInput
    notifications?: NotificationCreateNestedManyWithoutAlertInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    title: string
    message: string
    tenantId?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutAlertInput
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutAlertsNestedInput
    user?: UserUpdateOneWithoutAlertsNestedInput
    notifications?: NotificationUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type AlertCreateManyInput = {
    id?: string
    type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    title: string
    message: string
    tenantId?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    method: $Enums.NotificationMethod
    sent?: boolean
    sentAt?: Date | string | null
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alert: AlertCreateNestedOneWithoutNotificationsInput
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    alertId: string
    userId: string
    method: $Enums.NotificationMethod
    sent?: boolean
    sentAt?: Date | string | null
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumNotificationMethodFieldUpdateOperationsInput | $Enums.NotificationMethod
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alert?: AlertUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    method?: EnumNotificationMethodFieldUpdateOperationsInput | $Enums.NotificationMethod
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    alertId: string
    userId: string
    method: $Enums.NotificationMethod
    sent?: boolean
    sentAt?: Date | string | null
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumNotificationMethodFieldUpdateOperationsInput | $Enums.NotificationMethod
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    method?: EnumNotificationMethodFieldUpdateOperationsInput | $Enums.NotificationMethod
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserNotificationsInput
  }

  export type UserNotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumUserNotificationTypeFieldUpdateOperationsInput | $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserNotificationsNestedInput
  }

  export type UserNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumUserNotificationTypeFieldUpdateOperationsInput | $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumUserNotificationTypeFieldUpdateOperationsInput | $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumUserNotificationTypeFieldUpdateOperationsInput | $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateCreateInput = {
    id?: string
    name: string
    category: string
    messageType: $Enums.MessageType
    content: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    active?: boolean
    tags?: MessageTemplateCreatetagsInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMessageTemplatesInput
    creator: UserCreateNestedOneWithoutCreatedTemplatesInput
  }

  export type MessageTemplateUncheckedCreateInput = {
    id?: string
    name: string
    tenantId: string
    category: string
    messageType: $Enums.MessageType
    content: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    active?: boolean
    tags?: MessageTemplateCreatetagsInput | string[]
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    tags?: MessageTemplateUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMessageTemplatesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTemplatesNestedInput
  }

  export type MessageTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    tags?: MessageTemplateUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateCreateManyInput = {
    id?: string
    name: string
    tenantId: string
    category: string
    messageType: $Enums.MessageType
    content: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    active?: boolean
    tags?: MessageTemplateCreatetagsInput | string[]
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    tags?: MessageTemplateUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    tags?: MessageTemplateUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationFlowCreateInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean
    trigger: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAutomationFlowsInput
    creator: UserCreateNestedOneWithoutCreatedFlowsInput
    executions?: AutomationExecutionCreateNestedManyWithoutFlowInput
  }

  export type AutomationFlowUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    active?: boolean
    trigger: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: AutomationExecutionUncheckedCreateNestedManyWithoutFlowInput
  }

  export type AutomationFlowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    trigger?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAutomationFlowsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedFlowsNestedInput
    executions?: AutomationExecutionUpdateManyWithoutFlowNestedInput
  }

  export type AutomationFlowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    trigger?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: AutomationExecutionUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type AutomationFlowCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    active?: boolean
    trigger: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationFlowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    trigger?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationFlowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    trigger?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationExecutionCreateInput = {
    id?: string
    status: string
    executedAt: Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    duration?: number | null
    flow: AutomationFlowCreateNestedOneWithoutExecutionsInput
  }

  export type AutomationExecutionUncheckedCreateInput = {
    id?: string
    flowId: string
    status: string
    executedAt: Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    duration?: number | null
  }

  export type AutomationExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    flow?: AutomationFlowUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type AutomationExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationExecutionCreateManyInput = {
    id?: string
    flowId: string
    status: string
    executedAt: Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    duration?: number | null
  }

  export type AutomationExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flowId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntegrationCreateInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    active?: boolean
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    lastSyncAt?: Date | string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutIntegrationsInput
    creator: UserCreateNestedOneWithoutCreatedIntegrationsInput
    syncLogs?: IntegrationSyncCreateNestedManyWithoutIntegrationInput
  }

  export type IntegrationUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    tenantId: string
    active?: boolean
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    lastSyncAt?: Date | string | null
    lastError?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncLogs?: IntegrationSyncUncheckedCreateNestedManyWithoutIntegrationInput
  }

  export type IntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    active?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutIntegrationsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedIntegrationsNestedInput
    syncLogs?: IntegrationSyncUpdateManyWithoutIntegrationNestedInput
  }

  export type IntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    tenantId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncLogs?: IntegrationSyncUncheckedUpdateManyWithoutIntegrationNestedInput
  }

  export type IntegrationCreateManyInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    tenantId: string
    active?: boolean
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    lastSyncAt?: Date | string | null
    lastError?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    active?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    tenantId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationSyncCreateInput = {
    id?: string
    type: string
    status: string
    recordsCount?: number | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt: Date | string
    completedAt?: Date | string | null
    integration: IntegrationCreateNestedOneWithoutSyncLogsInput
  }

  export type IntegrationSyncUncheckedCreateInput = {
    id?: string
    integrationId: string
    type: string
    status: string
    recordsCount?: number | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt: Date | string
    completedAt?: Date | string | null
  }

  export type IntegrationSyncUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recordsCount?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integration?: IntegrationUpdateOneRequiredWithoutSyncLogsNestedInput
  }

  export type IntegrationSyncUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recordsCount?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntegrationSyncCreateManyInput = {
    id?: string
    integrationId: string
    type: string
    status: string
    recordsCount?: number | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt: Date | string
    completedAt?: Date | string | null
  }

  export type IntegrationSyncUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recordsCount?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntegrationSyncUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recordsCount?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    severity: string
    entityType?: string | null
    entityId?: string | null
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: string
    severity: string
    tenantId: string
    userId?: string | null
    entityType?: string | null
    entityId?: string | null
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: string
    severity: string
    tenantId: string
    userId?: string | null
    entityType?: string | null
    entityId?: string | null
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserTenantListRelationFilter = {
    every?: UserTenantWhereInput
    some?: UserTenantWhereInput
    none?: UserTenantWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type CampaignMessageListRelationFilter = {
    every?: CampaignMessageWhereInput
    some?: CampaignMessageWhereInput
    none?: CampaignMessageWhereInput
  }

  export type WhatsAppSessionListRelationFilter = {
    every?: WhatsAppSessionWhereInput
    some?: WhatsAppSessionWhereInput
    none?: WhatsAppSessionWhereInput
  }

  export type TenantQuotaNullableRelationFilter = {
    is?: TenantQuotaWhereInput | null
    isNot?: TenantQuotaWhereInput | null
  }

  export type TenantSettingsNullableRelationFilter = {
    is?: TenantSettingsWhereInput | null
    isNot?: TenantSettingsWhereInput | null
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type MessageTemplateListRelationFilter = {
    every?: MessageTemplateWhereInput
    some?: MessageTemplateWhereInput
    none?: MessageTemplateWhereInput
  }

  export type AutomationFlowListRelationFilter = {
    every?: AutomationFlowWhereInput
    some?: AutomationFlowWhereInput
    none?: AutomationFlowWhereInput
  }

  export type IntegrationListRelationFilter = {
    every?: IntegrationWhereInput
    some?: IntegrationWhereInput
    none?: IntegrationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTenantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationFlowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type TenantQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    maxUsers?: SortOrder
    maxContacts?: SortOrder
    maxCampaigns?: SortOrder
    maxConnections?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantQuotaAvgOrderByAggregateInput = {
    maxUsers?: SortOrder
    maxContacts?: SortOrder
    maxCampaigns?: SortOrder
    maxConnections?: SortOrder
  }

  export type TenantQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    maxUsers?: SortOrder
    maxContacts?: SortOrder
    maxCampaigns?: SortOrder
    maxConnections?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    maxUsers?: SortOrder
    maxContacts?: SortOrder
    maxCampaigns?: SortOrder
    maxConnections?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantQuotaSumOrderByAggregateInput = {
    maxUsers?: SortOrder
    maxContacts?: SortOrder
    maxCampaigns?: SortOrder
    maxConnections?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TenantSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    openaiApiKey?: SortOrder
    groqApiKey?: SortOrder
    customBranding?: SortOrder
    chatwootUrl?: SortOrder
    chatwootAccountId?: SortOrder
    chatwootApiToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    openaiApiKey?: SortOrder
    groqApiKey?: SortOrder
    chatwootUrl?: SortOrder
    chatwootAccountId?: SortOrder
    chatwootApiToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    openaiApiKey?: SortOrder
    groqApiKey?: SortOrder
    chatwootUrl?: SortOrder
    chatwootAccountId?: SortOrder
    chatwootApiToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserTenantUserIdTenantIdCompoundUniqueInput = {
    userId: string
    tenantId: string
  }

  export type UserTenantCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTenantMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTenantMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    singleton?: SortOrder
    wahaHost?: SortOrder
    wahaApiKey?: SortOrder
    evolutionHost?: SortOrder
    evolutionApiKey?: SortOrder
    quepasaUrl?: SortOrder
    quepasaLogin?: SortOrder
    quepasaPassword?: SortOrder
    logoUrl?: SortOrder
    faviconUrl?: SortOrder
    iconUrl?: SortOrder
    companyName?: SortOrder
    pageTitle?: SortOrder
    primaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    singleton?: SortOrder
    wahaHost?: SortOrder
    wahaApiKey?: SortOrder
    evolutionHost?: SortOrder
    evolutionApiKey?: SortOrder
    quepasaUrl?: SortOrder
    quepasaLogin?: SortOrder
    quepasaPassword?: SortOrder
    logoUrl?: SortOrder
    faviconUrl?: SortOrder
    iconUrl?: SortOrder
    companyName?: SortOrder
    pageTitle?: SortOrder
    primaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    singleton?: SortOrder
    wahaHost?: SortOrder
    wahaApiKey?: SortOrder
    evolutionHost?: SortOrder
    evolutionApiKey?: SortOrder
    quepasaUrl?: SortOrder
    quepasaLogin?: SortOrder
    quepasaPassword?: SortOrder
    logoUrl?: SortOrder
    faviconUrl?: SortOrder
    iconUrl?: SortOrder
    companyName?: SortOrder
    pageTitle?: SortOrder
    primaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type TenantNullableRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    tags?: SortOrder
    observacoes?: SortOrder
    categoriaId?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    observacoes?: SortOrder
    categoriaId?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    observacoes?: SortOrder
    categoriaId?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cor?: SortOrder
    descricao?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cor?: SortOrder
    descricao?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cor?: SortOrder
    descricao?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type WhatsAppSessionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    status?: SortOrder
    config?: SortOrder
    meId?: SortOrder
    mePushName?: SortOrder
    meLid?: SortOrder
    meJid?: SortOrder
    qr?: SortOrder
    qrExpiresAt?: SortOrder
    assignedWorker?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    provider?: SortOrder
    quepasaToken?: SortOrder
  }

  export type WhatsAppSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    status?: SortOrder
    config?: SortOrder
    meId?: SortOrder
    mePushName?: SortOrder
    meLid?: SortOrder
    meJid?: SortOrder
    qr?: SortOrder
    qrExpiresAt?: SortOrder
    assignedWorker?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    provider?: SortOrder
    quepasaToken?: SortOrder
  }

  export type WhatsAppSessionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    status?: SortOrder
    config?: SortOrder
    meId?: SortOrder
    mePushName?: SortOrder
    meLid?: SortOrder
    meJid?: SortOrder
    qr?: SortOrder
    qrExpiresAt?: SortOrder
    assignedWorker?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    provider?: SortOrder
    quepasaToken?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type WhatsAppSessionNullableRelationFilter = {
    is?: WhatsAppSessionWhereInput | null
    isNot?: WhatsAppSessionWhereInput | null
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    targetTags?: SortOrder
    sessionName?: SortOrder
    messageType?: SortOrder
    messageContent?: SortOrder
    randomDelay?: SortOrder
    startImmediately?: SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    totalContacts?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    useTimeWindow?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessionNames?: SortOrder
    createdBy?: SortOrder
    createdByName?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    randomDelay?: SortOrder
    totalContacts?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    targetTags?: SortOrder
    sessionName?: SortOrder
    messageType?: SortOrder
    messageContent?: SortOrder
    randomDelay?: SortOrder
    startImmediately?: SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    totalContacts?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    useTimeWindow?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessionNames?: SortOrder
    createdBy?: SortOrder
    createdByName?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    targetTags?: SortOrder
    sessionName?: SortOrder
    messageType?: SortOrder
    messageContent?: SortOrder
    randomDelay?: SortOrder
    startImmediately?: SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    totalContacts?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    useTimeWindow?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessionNames?: SortOrder
    createdBy?: SortOrder
    createdByName?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    randomDelay?: SortOrder
    totalContacts?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignMessageCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    contactPhone?: SortOrder
    contactName?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    errorMessage?: SortOrder
    messageId?: SortOrder
    selectedVariation?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessionName?: SortOrder
  }

  export type CampaignMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    contactPhone?: SortOrder
    contactName?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    errorMessage?: SortOrder
    messageId?: SortOrder
    selectedVariation?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessionName?: SortOrder
  }

  export type CampaignMessageMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contactId?: SortOrder
    contactPhone?: SortOrder
    contactName?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    errorMessage?: SortOrder
    messageId?: SortOrder
    selectedVariation?: SortOrder
    tenantId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessionName?: SortOrder
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type UserNotificationListRelationFilter = {
    every?: UserNotificationWhereInput
    some?: UserNotificationWhereInput
    none?: UserNotificationWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    role?: SortOrder
    ativo?: SortOrder
    tenantId?: SortOrder
    ultimoLogin?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    role?: SortOrder
    ativo?: SortOrder
    tenantId?: SortOrder
    ultimoLogin?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    role?: SortOrder
    ativo?: SortOrder
    tenantId?: SortOrder
    ultimoLogin?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type EnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type EnumAlertSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertSeverityFilter<$PrismaModel> | $Enums.AlertSeverity
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    message?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    metadata?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    message?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    message?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type EnumAlertSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel> | $Enums.AlertSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertSeverityFilter<$PrismaModel>
    _max?: NestedEnumAlertSeverityFilter<$PrismaModel>
  }

  export type EnumNotificationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationMethod | EnumNotificationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationMethod[] | ListEnumNotificationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationMethod[] | ListEnumNotificationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationMethodFilter<$PrismaModel> | $Enums.NotificationMethod
  }

  export type AlertRelationFilter = {
    is?: AlertWhereInput
    isNot?: AlertWhereInput
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationMethod | EnumNotificationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationMethod[] | ListEnumNotificationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationMethod[] | ListEnumNotificationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationMethodWithAggregatesFilter<$PrismaModel> | $Enums.NotificationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationMethodFilter<$PrismaModel>
    _max?: NestedEnumNotificationMethodFilter<$PrismaModel>
  }

  export type EnumUserNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserNotificationType | EnumUserNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserNotificationType[] | ListEnumUserNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserNotificationType[] | ListEnumUserNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserNotificationTypeFilter<$PrismaModel> | $Enums.UserNotificationType
  }

  export type UserNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    data?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserNotificationType | EnumUserNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserNotificationType[] | ListEnumUserNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserNotificationType[] | ListEnumUserNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserNotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumUserNotificationTypeFilter<$PrismaModel>
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type MessageTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    mediaUrl?: SortOrder
    active?: SortOrder
    tags?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    active?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    active?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AutomationExecutionListRelationFilter = {
    every?: AutomationExecutionWhereInput
    some?: AutomationExecutionWhereInput
    none?: AutomationExecutionWhereInput
  }

  export type AutomationExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationFlowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    active?: SortOrder
    trigger?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationFlowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    active?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationFlowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    active?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AutomationFlowRelationFilter = {
    is?: AutomationFlowWhereInput
    isNot?: AutomationFlowWhereInput
  }

  export type AutomationExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    context?: SortOrder
    error?: SortOrder
    duration?: SortOrder
  }

  export type AutomationExecutionAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type AutomationExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    error?: SortOrder
    duration?: SortOrder
  }

  export type AutomationExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    error?: SortOrder
    duration?: SortOrder
  }

  export type AutomationExecutionSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeFilter<$PrismaModel> | $Enums.IntegrationType
  }

  export type IntegrationSyncListRelationFilter = {
    every?: IntegrationSyncWhereInput
    some?: IntegrationSyncWhereInput
    none?: IntegrationSyncWhereInput
  }

  export type IntegrationSyncOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tenantId?: SortOrder
    active?: SortOrder
    config?: SortOrder
    credentials?: SortOrder
    webhookUrl?: SortOrder
    lastSyncAt?: SortOrder
    lastError?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tenantId?: SortOrder
    active?: SortOrder
    webhookUrl?: SortOrder
    lastSyncAt?: SortOrder
    lastError?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tenantId?: SortOrder
    active?: SortOrder
    webhookUrl?: SortOrder
    lastSyncAt?: SortOrder
    lastError?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumIntegrationTypeFilter<$PrismaModel>
  }

  export type IntegrationRelationFilter = {
    is?: IntegrationWhereInput
    isNot?: IntegrationWhereInput
  }

  export type IntegrationSyncCountOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recordsCount?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type IntegrationSyncAvgOrderByAggregateInput = {
    recordsCount?: SortOrder
  }

  export type IntegrationSyncMaxOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recordsCount?: SortOrder
    errorMessage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type IntegrationSyncMinOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recordsCount?: SortOrder
    errorMessage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type IntegrationSyncSumOrderByAggregateInput = {
    recordsCount?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    severity?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    severity?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    severity?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserTenantCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserTenantCreateWithoutTenantInput, UserTenantUncheckedCreateWithoutTenantInput> | UserTenantCreateWithoutTenantInput[] | UserTenantUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserTenantCreateOrConnectWithoutTenantInput | UserTenantCreateOrConnectWithoutTenantInput[]
    createMany?: UserTenantCreateManyTenantInputEnvelope
    connect?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutTenantInput = {
    create?: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput> | ContactCreateWithoutTenantInput[] | ContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenantInput | ContactCreateOrConnectWithoutTenantInput[]
    createMany?: ContactCreateManyTenantInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutTenantInput = {
    create?: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput> | CategoryCreateWithoutTenantInput[] | CategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTenantInput | CategoryCreateOrConnectWithoutTenantInput[]
    createMany?: CategoryCreateManyTenantInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutTenantInput = {
    create?: XOR<CampaignCreateWithoutTenantInput, CampaignUncheckedCreateWithoutTenantInput> | CampaignCreateWithoutTenantInput[] | CampaignUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTenantInput | CampaignCreateOrConnectWithoutTenantInput[]
    createMany?: CampaignCreateManyTenantInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignMessageCreateNestedManyWithoutTenantInput = {
    create?: XOR<CampaignMessageCreateWithoutTenantInput, CampaignMessageUncheckedCreateWithoutTenantInput> | CampaignMessageCreateWithoutTenantInput[] | CampaignMessageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutTenantInput | CampaignMessageCreateOrConnectWithoutTenantInput[]
    createMany?: CampaignMessageCreateManyTenantInputEnvelope
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
  }

  export type WhatsAppSessionCreateNestedManyWithoutTenantInput = {
    create?: XOR<WhatsAppSessionCreateWithoutTenantInput, WhatsAppSessionUncheckedCreateWithoutTenantInput> | WhatsAppSessionCreateWithoutTenantInput[] | WhatsAppSessionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutTenantInput | WhatsAppSessionCreateOrConnectWithoutTenantInput[]
    createMany?: WhatsAppSessionCreateManyTenantInputEnvelope
    connect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
  }

  export type TenantQuotaCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantQuotaCreateWithoutTenantInput, TenantQuotaUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantQuotaCreateOrConnectWithoutTenantInput
    connect?: TenantQuotaWhereUniqueInput
  }

  export type TenantSettingsCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantSettingsCreateWithoutTenantInput, TenantSettingsUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantSettingsCreateOrConnectWithoutTenantInput
    connect?: TenantSettingsWhereUniqueInput
  }

  export type AlertCreateNestedManyWithoutTenantInput = {
    create?: XOR<AlertCreateWithoutTenantInput, AlertUncheckedCreateWithoutTenantInput> | AlertCreateWithoutTenantInput[] | AlertUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutTenantInput | AlertCreateOrConnectWithoutTenantInput[]
    createMany?: AlertCreateManyTenantInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type MessageTemplateCreateNestedManyWithoutTenantInput = {
    create?: XOR<MessageTemplateCreateWithoutTenantInput, MessageTemplateUncheckedCreateWithoutTenantInput> | MessageTemplateCreateWithoutTenantInput[] | MessageTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutTenantInput | MessageTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: MessageTemplateCreateManyTenantInputEnvelope
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
  }

  export type AutomationFlowCreateNestedManyWithoutTenantInput = {
    create?: XOR<AutomationFlowCreateWithoutTenantInput, AutomationFlowUncheckedCreateWithoutTenantInput> | AutomationFlowCreateWithoutTenantInput[] | AutomationFlowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationFlowCreateOrConnectWithoutTenantInput | AutomationFlowCreateOrConnectWithoutTenantInput[]
    createMany?: AutomationFlowCreateManyTenantInputEnvelope
    connect?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
  }

  export type IntegrationCreateNestedManyWithoutTenantInput = {
    create?: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput> | IntegrationCreateWithoutTenantInput[] | IntegrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutTenantInput | IntegrationCreateOrConnectWithoutTenantInput[]
    createMany?: IntegrationCreateManyTenantInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserTenantUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserTenantCreateWithoutTenantInput, UserTenantUncheckedCreateWithoutTenantInput> | UserTenantCreateWithoutTenantInput[] | UserTenantUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserTenantCreateOrConnectWithoutTenantInput | UserTenantCreateOrConnectWithoutTenantInput[]
    createMany?: UserTenantCreateManyTenantInputEnvelope
    connect?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput> | ContactCreateWithoutTenantInput[] | ContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenantInput | ContactCreateOrConnectWithoutTenantInput[]
    createMany?: ContactCreateManyTenantInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput> | CategoryCreateWithoutTenantInput[] | CategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTenantInput | CategoryCreateOrConnectWithoutTenantInput[]
    createMany?: CategoryCreateManyTenantInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CampaignCreateWithoutTenantInput, CampaignUncheckedCreateWithoutTenantInput> | CampaignCreateWithoutTenantInput[] | CampaignUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTenantInput | CampaignCreateOrConnectWithoutTenantInput[]
    createMany?: CampaignCreateManyTenantInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignMessageUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CampaignMessageCreateWithoutTenantInput, CampaignMessageUncheckedCreateWithoutTenantInput> | CampaignMessageCreateWithoutTenantInput[] | CampaignMessageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutTenantInput | CampaignMessageCreateOrConnectWithoutTenantInput[]
    createMany?: CampaignMessageCreateManyTenantInputEnvelope
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
  }

  export type WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WhatsAppSessionCreateWithoutTenantInput, WhatsAppSessionUncheckedCreateWithoutTenantInput> | WhatsAppSessionCreateWithoutTenantInput[] | WhatsAppSessionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutTenantInput | WhatsAppSessionCreateOrConnectWithoutTenantInput[]
    createMany?: WhatsAppSessionCreateManyTenantInputEnvelope
    connect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
  }

  export type TenantQuotaUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantQuotaCreateWithoutTenantInput, TenantQuotaUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantQuotaCreateOrConnectWithoutTenantInput
    connect?: TenantQuotaWhereUniqueInput
  }

  export type TenantSettingsUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantSettingsCreateWithoutTenantInput, TenantSettingsUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantSettingsCreateOrConnectWithoutTenantInput
    connect?: TenantSettingsWhereUniqueInput
  }

  export type AlertUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AlertCreateWithoutTenantInput, AlertUncheckedCreateWithoutTenantInput> | AlertCreateWithoutTenantInput[] | AlertUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutTenantInput | AlertCreateOrConnectWithoutTenantInput[]
    createMany?: AlertCreateManyTenantInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type MessageTemplateUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<MessageTemplateCreateWithoutTenantInput, MessageTemplateUncheckedCreateWithoutTenantInput> | MessageTemplateCreateWithoutTenantInput[] | MessageTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutTenantInput | MessageTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: MessageTemplateCreateManyTenantInputEnvelope
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
  }

  export type AutomationFlowUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AutomationFlowCreateWithoutTenantInput, AutomationFlowUncheckedCreateWithoutTenantInput> | AutomationFlowCreateWithoutTenantInput[] | AutomationFlowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationFlowCreateOrConnectWithoutTenantInput | AutomationFlowCreateOrConnectWithoutTenantInput[]
    createMany?: AutomationFlowCreateManyTenantInputEnvelope
    connect?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
  }

  export type IntegrationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput> | IntegrationCreateWithoutTenantInput[] | IntegrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutTenantInput | IntegrationCreateOrConnectWithoutTenantInput[]
    createMany?: IntegrationCreateManyTenantInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserTenantUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserTenantCreateWithoutTenantInput, UserTenantUncheckedCreateWithoutTenantInput> | UserTenantCreateWithoutTenantInput[] | UserTenantUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserTenantCreateOrConnectWithoutTenantInput | UserTenantCreateOrConnectWithoutTenantInput[]
    upsert?: UserTenantUpsertWithWhereUniqueWithoutTenantInput | UserTenantUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserTenantCreateManyTenantInputEnvelope
    set?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    disconnect?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    delete?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    connect?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    update?: UserTenantUpdateWithWhereUniqueWithoutTenantInput | UserTenantUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserTenantUpdateManyWithWhereWithoutTenantInput | UserTenantUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserTenantScalarWhereInput | UserTenantScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput> | ContactCreateWithoutTenantInput[] | ContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenantInput | ContactCreateOrConnectWithoutTenantInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutTenantInput | ContactUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ContactCreateManyTenantInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutTenantInput | ContactUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutTenantInput | ContactUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput> | CategoryCreateWithoutTenantInput[] | CategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTenantInput | CategoryCreateOrConnectWithoutTenantInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutTenantInput | CategoryUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CategoryCreateManyTenantInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutTenantInput | CategoryUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutTenantInput | CategoryUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CampaignCreateWithoutTenantInput, CampaignUncheckedCreateWithoutTenantInput> | CampaignCreateWithoutTenantInput[] | CampaignUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTenantInput | CampaignCreateOrConnectWithoutTenantInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTenantInput | CampaignUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CampaignCreateManyTenantInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTenantInput | CampaignUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTenantInput | CampaignUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignMessageUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CampaignMessageCreateWithoutTenantInput, CampaignMessageUncheckedCreateWithoutTenantInput> | CampaignMessageCreateWithoutTenantInput[] | CampaignMessageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutTenantInput | CampaignMessageCreateOrConnectWithoutTenantInput[]
    upsert?: CampaignMessageUpsertWithWhereUniqueWithoutTenantInput | CampaignMessageUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CampaignMessageCreateManyTenantInputEnvelope
    set?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    disconnect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    delete?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    update?: CampaignMessageUpdateWithWhereUniqueWithoutTenantInput | CampaignMessageUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CampaignMessageUpdateManyWithWhereWithoutTenantInput | CampaignMessageUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
  }

  export type WhatsAppSessionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WhatsAppSessionCreateWithoutTenantInput, WhatsAppSessionUncheckedCreateWithoutTenantInput> | WhatsAppSessionCreateWithoutTenantInput[] | WhatsAppSessionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutTenantInput | WhatsAppSessionCreateOrConnectWithoutTenantInput[]
    upsert?: WhatsAppSessionUpsertWithWhereUniqueWithoutTenantInput | WhatsAppSessionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WhatsAppSessionCreateManyTenantInputEnvelope
    set?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    disconnect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    delete?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    connect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    update?: WhatsAppSessionUpdateWithWhereUniqueWithoutTenantInput | WhatsAppSessionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WhatsAppSessionUpdateManyWithWhereWithoutTenantInput | WhatsAppSessionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WhatsAppSessionScalarWhereInput | WhatsAppSessionScalarWhereInput[]
  }

  export type TenantQuotaUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantQuotaCreateWithoutTenantInput, TenantQuotaUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantQuotaCreateOrConnectWithoutTenantInput
    upsert?: TenantQuotaUpsertWithoutTenantInput
    disconnect?: TenantQuotaWhereInput | boolean
    delete?: TenantQuotaWhereInput | boolean
    connect?: TenantQuotaWhereUniqueInput
    update?: XOR<XOR<TenantQuotaUpdateToOneWithWhereWithoutTenantInput, TenantQuotaUpdateWithoutTenantInput>, TenantQuotaUncheckedUpdateWithoutTenantInput>
  }

  export type TenantSettingsUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantSettingsCreateWithoutTenantInput, TenantSettingsUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantSettingsCreateOrConnectWithoutTenantInput
    upsert?: TenantSettingsUpsertWithoutTenantInput
    disconnect?: TenantSettingsWhereInput | boolean
    delete?: TenantSettingsWhereInput | boolean
    connect?: TenantSettingsWhereUniqueInput
    update?: XOR<XOR<TenantSettingsUpdateToOneWithWhereWithoutTenantInput, TenantSettingsUpdateWithoutTenantInput>, TenantSettingsUncheckedUpdateWithoutTenantInput>
  }

  export type AlertUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AlertCreateWithoutTenantInput, AlertUncheckedCreateWithoutTenantInput> | AlertCreateWithoutTenantInput[] | AlertUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutTenantInput | AlertCreateOrConnectWithoutTenantInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutTenantInput | AlertUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AlertCreateManyTenantInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutTenantInput | AlertUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutTenantInput | AlertUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type MessageTemplateUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MessageTemplateCreateWithoutTenantInput, MessageTemplateUncheckedCreateWithoutTenantInput> | MessageTemplateCreateWithoutTenantInput[] | MessageTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutTenantInput | MessageTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: MessageTemplateUpsertWithWhereUniqueWithoutTenantInput | MessageTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MessageTemplateCreateManyTenantInputEnvelope
    set?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    disconnect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    delete?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    update?: MessageTemplateUpdateWithWhereUniqueWithoutTenantInput | MessageTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MessageTemplateUpdateManyWithWhereWithoutTenantInput | MessageTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
  }

  export type AutomationFlowUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AutomationFlowCreateWithoutTenantInput, AutomationFlowUncheckedCreateWithoutTenantInput> | AutomationFlowCreateWithoutTenantInput[] | AutomationFlowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationFlowCreateOrConnectWithoutTenantInput | AutomationFlowCreateOrConnectWithoutTenantInput[]
    upsert?: AutomationFlowUpsertWithWhereUniqueWithoutTenantInput | AutomationFlowUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AutomationFlowCreateManyTenantInputEnvelope
    set?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    disconnect?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    delete?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    connect?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    update?: AutomationFlowUpdateWithWhereUniqueWithoutTenantInput | AutomationFlowUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AutomationFlowUpdateManyWithWhereWithoutTenantInput | AutomationFlowUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AutomationFlowScalarWhereInput | AutomationFlowScalarWhereInput[]
  }

  export type IntegrationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput> | IntegrationCreateWithoutTenantInput[] | IntegrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutTenantInput | IntegrationCreateOrConnectWithoutTenantInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutTenantInput | IntegrationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IntegrationCreateManyTenantInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutTenantInput | IntegrationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutTenantInput | IntegrationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserTenantUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserTenantCreateWithoutTenantInput, UserTenantUncheckedCreateWithoutTenantInput> | UserTenantCreateWithoutTenantInput[] | UserTenantUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserTenantCreateOrConnectWithoutTenantInput | UserTenantCreateOrConnectWithoutTenantInput[]
    upsert?: UserTenantUpsertWithWhereUniqueWithoutTenantInput | UserTenantUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserTenantCreateManyTenantInputEnvelope
    set?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    disconnect?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    delete?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    connect?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    update?: UserTenantUpdateWithWhereUniqueWithoutTenantInput | UserTenantUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserTenantUpdateManyWithWhereWithoutTenantInput | UserTenantUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserTenantScalarWhereInput | UserTenantScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput> | ContactCreateWithoutTenantInput[] | ContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenantInput | ContactCreateOrConnectWithoutTenantInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutTenantInput | ContactUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ContactCreateManyTenantInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutTenantInput | ContactUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutTenantInput | ContactUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput> | CategoryCreateWithoutTenantInput[] | CategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTenantInput | CategoryCreateOrConnectWithoutTenantInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutTenantInput | CategoryUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CategoryCreateManyTenantInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutTenantInput | CategoryUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutTenantInput | CategoryUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CampaignCreateWithoutTenantInput, CampaignUncheckedCreateWithoutTenantInput> | CampaignCreateWithoutTenantInput[] | CampaignUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTenantInput | CampaignCreateOrConnectWithoutTenantInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTenantInput | CampaignUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CampaignCreateManyTenantInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTenantInput | CampaignUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTenantInput | CampaignUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CampaignMessageCreateWithoutTenantInput, CampaignMessageUncheckedCreateWithoutTenantInput> | CampaignMessageCreateWithoutTenantInput[] | CampaignMessageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutTenantInput | CampaignMessageCreateOrConnectWithoutTenantInput[]
    upsert?: CampaignMessageUpsertWithWhereUniqueWithoutTenantInput | CampaignMessageUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CampaignMessageCreateManyTenantInputEnvelope
    set?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    disconnect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    delete?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    update?: CampaignMessageUpdateWithWhereUniqueWithoutTenantInput | CampaignMessageUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CampaignMessageUpdateManyWithWhereWithoutTenantInput | CampaignMessageUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
  }

  export type WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WhatsAppSessionCreateWithoutTenantInput, WhatsAppSessionUncheckedCreateWithoutTenantInput> | WhatsAppSessionCreateWithoutTenantInput[] | WhatsAppSessionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutTenantInput | WhatsAppSessionCreateOrConnectWithoutTenantInput[]
    upsert?: WhatsAppSessionUpsertWithWhereUniqueWithoutTenantInput | WhatsAppSessionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WhatsAppSessionCreateManyTenantInputEnvelope
    set?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    disconnect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    delete?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    connect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    update?: WhatsAppSessionUpdateWithWhereUniqueWithoutTenantInput | WhatsAppSessionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WhatsAppSessionUpdateManyWithWhereWithoutTenantInput | WhatsAppSessionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WhatsAppSessionScalarWhereInput | WhatsAppSessionScalarWhereInput[]
  }

  export type TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantQuotaCreateWithoutTenantInput, TenantQuotaUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantQuotaCreateOrConnectWithoutTenantInput
    upsert?: TenantQuotaUpsertWithoutTenantInput
    disconnect?: TenantQuotaWhereInput | boolean
    delete?: TenantQuotaWhereInput | boolean
    connect?: TenantQuotaWhereUniqueInput
    update?: XOR<XOR<TenantQuotaUpdateToOneWithWhereWithoutTenantInput, TenantQuotaUpdateWithoutTenantInput>, TenantQuotaUncheckedUpdateWithoutTenantInput>
  }

  export type TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantSettingsCreateWithoutTenantInput, TenantSettingsUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantSettingsCreateOrConnectWithoutTenantInput
    upsert?: TenantSettingsUpsertWithoutTenantInput
    disconnect?: TenantSettingsWhereInput | boolean
    delete?: TenantSettingsWhereInput | boolean
    connect?: TenantSettingsWhereUniqueInput
    update?: XOR<XOR<TenantSettingsUpdateToOneWithWhereWithoutTenantInput, TenantSettingsUpdateWithoutTenantInput>, TenantSettingsUncheckedUpdateWithoutTenantInput>
  }

  export type AlertUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AlertCreateWithoutTenantInput, AlertUncheckedCreateWithoutTenantInput> | AlertCreateWithoutTenantInput[] | AlertUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutTenantInput | AlertCreateOrConnectWithoutTenantInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutTenantInput | AlertUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AlertCreateManyTenantInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutTenantInput | AlertUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutTenantInput | AlertUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MessageTemplateCreateWithoutTenantInput, MessageTemplateUncheckedCreateWithoutTenantInput> | MessageTemplateCreateWithoutTenantInput[] | MessageTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutTenantInput | MessageTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: MessageTemplateUpsertWithWhereUniqueWithoutTenantInput | MessageTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MessageTemplateCreateManyTenantInputEnvelope
    set?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    disconnect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    delete?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    update?: MessageTemplateUpdateWithWhereUniqueWithoutTenantInput | MessageTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MessageTemplateUpdateManyWithWhereWithoutTenantInput | MessageTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
  }

  export type AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AutomationFlowCreateWithoutTenantInput, AutomationFlowUncheckedCreateWithoutTenantInput> | AutomationFlowCreateWithoutTenantInput[] | AutomationFlowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationFlowCreateOrConnectWithoutTenantInput | AutomationFlowCreateOrConnectWithoutTenantInput[]
    upsert?: AutomationFlowUpsertWithWhereUniqueWithoutTenantInput | AutomationFlowUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AutomationFlowCreateManyTenantInputEnvelope
    set?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    disconnect?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    delete?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    connect?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    update?: AutomationFlowUpdateWithWhereUniqueWithoutTenantInput | AutomationFlowUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AutomationFlowUpdateManyWithWhereWithoutTenantInput | AutomationFlowUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AutomationFlowScalarWhereInput | AutomationFlowScalarWhereInput[]
  }

  export type IntegrationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput> | IntegrationCreateWithoutTenantInput[] | IntegrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutTenantInput | IntegrationCreateOrConnectWithoutTenantInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutTenantInput | IntegrationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IntegrationCreateManyTenantInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutTenantInput | IntegrationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutTenantInput | IntegrationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutQuotasInput = {
    create?: XOR<TenantCreateWithoutQuotasInput, TenantUncheckedCreateWithoutQuotasInput>
    connectOrCreate?: TenantCreateOrConnectWithoutQuotasInput
    connect?: TenantWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutQuotasNestedInput = {
    create?: XOR<TenantCreateWithoutQuotasInput, TenantUncheckedCreateWithoutQuotasInput>
    connectOrCreate?: TenantCreateOrConnectWithoutQuotasInput
    upsert?: TenantUpsertWithoutQuotasInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutQuotasInput, TenantUpdateWithoutQuotasInput>, TenantUncheckedUpdateWithoutQuotasInput>
  }

  export type TenantCreateNestedOneWithoutSettingsInput = {
    create?: XOR<TenantCreateWithoutSettingsInput, TenantUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSettingsInput
    connect?: TenantWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type TenantUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<TenantCreateWithoutSettingsInput, TenantUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSettingsInput
    upsert?: TenantUpsertWithoutSettingsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSettingsInput, TenantUpdateWithoutSettingsInput>, TenantUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutTenantsInput = {
    create?: XOR<UserCreateWithoutTenantsInput, UserUncheckedCreateWithoutTenantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutUserTenantsInput = {
    create?: XOR<TenantCreateWithoutUserTenantsInput, TenantUncheckedCreateWithoutUserTenantsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUserTenantsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTenantsNestedInput = {
    create?: XOR<UserCreateWithoutTenantsInput, UserUncheckedCreateWithoutTenantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantsInput
    upsert?: UserUpsertWithoutTenantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTenantsInput, UserUpdateWithoutTenantsInput>, UserUncheckedUpdateWithoutTenantsInput>
  }

  export type TenantUpdateOneRequiredWithoutUserTenantsNestedInput = {
    create?: XOR<TenantCreateWithoutUserTenantsInput, TenantUncheckedCreateWithoutUserTenantsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUserTenantsInput
    upsert?: TenantUpsertWithoutUserTenantsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUserTenantsInput, TenantUpdateWithoutUserTenantsInput>, TenantUncheckedUpdateWithoutUserTenantsInput>
  }

  export type ContactCreatetagsInput = {
    set: string[]
  }

  export type CategoryCreateNestedOneWithoutContactsInput = {
    create?: XOR<CategoryCreateWithoutContactsInput, CategoryUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutContactsInput
    connect?: CategoryWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutContactsInput = {
    create?: XOR<TenantCreateWithoutContactsInput, TenantUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutContactsInput
    connect?: TenantWhereUniqueInput
  }

  export type ContactUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CategoryUpdateOneWithoutContactsNestedInput = {
    create?: XOR<CategoryCreateWithoutContactsInput, CategoryUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutContactsInput
    upsert?: CategoryUpsertWithoutContactsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutContactsInput, CategoryUpdateWithoutContactsInput>, CategoryUncheckedUpdateWithoutContactsInput>
  }

  export type TenantUpdateOneWithoutContactsNestedInput = {
    create?: XOR<TenantCreateWithoutContactsInput, TenantUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutContactsInput
    upsert?: TenantUpsertWithoutContactsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutContactsInput, TenantUpdateWithoutContactsInput>, TenantUncheckedUpdateWithoutContactsInput>
  }

  export type ContactCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<ContactCreateWithoutCategoriaInput, ContactUncheckedCreateWithoutCategoriaInput> | ContactCreateWithoutCategoriaInput[] | ContactUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCategoriaInput | ContactCreateOrConnectWithoutCategoriaInput[]
    createMany?: ContactCreateManyCategoriaInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<TenantCreateWithoutCategoriesInput, TenantUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCategoriesInput
    connect?: TenantWhereUniqueInput
  }

  export type ContactUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<ContactCreateWithoutCategoriaInput, ContactUncheckedCreateWithoutCategoriaInput> | ContactCreateWithoutCategoriaInput[] | ContactUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCategoriaInput | ContactCreateOrConnectWithoutCategoriaInput[]
    createMany?: ContactCreateManyCategoriaInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ContactUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<ContactCreateWithoutCategoriaInput, ContactUncheckedCreateWithoutCategoriaInput> | ContactCreateWithoutCategoriaInput[] | ContactUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCategoriaInput | ContactCreateOrConnectWithoutCategoriaInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCategoriaInput | ContactUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: ContactCreateManyCategoriaInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCategoriaInput | ContactUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCategoriaInput | ContactUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type TenantUpdateOneWithoutCategoriesNestedInput = {
    create?: XOR<TenantCreateWithoutCategoriesInput, TenantUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCategoriesInput
    upsert?: TenantUpsertWithoutCategoriesInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCategoriesInput, TenantUpdateWithoutCategoriesInput>, TenantUncheckedUpdateWithoutCategoriesInput>
  }

  export type ContactUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<ContactCreateWithoutCategoriaInput, ContactUncheckedCreateWithoutCategoriaInput> | ContactCreateWithoutCategoriaInput[] | ContactUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCategoriaInput | ContactCreateOrConnectWithoutCategoriaInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCategoriaInput | ContactUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: ContactCreateManyCategoriaInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCategoriaInput | ContactUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCategoriaInput | ContactUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CampaignCreateNestedManyWithoutSessionInput = {
    create?: XOR<CampaignCreateWithoutSessionInput, CampaignUncheckedCreateWithoutSessionInput> | CampaignCreateWithoutSessionInput[] | CampaignUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSessionInput | CampaignCreateOrConnectWithoutSessionInput[]
    createMany?: CampaignCreateManySessionInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutWhatsappSessionsInput = {
    create?: XOR<TenantCreateWithoutWhatsappSessionsInput, TenantUncheckedCreateWithoutWhatsappSessionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWhatsappSessionsInput
    connect?: TenantWhereUniqueInput
  }

  export type CampaignUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CampaignCreateWithoutSessionInput, CampaignUncheckedCreateWithoutSessionInput> | CampaignCreateWithoutSessionInput[] | CampaignUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSessionInput | CampaignCreateOrConnectWithoutSessionInput[]
    createMany?: CampaignCreateManySessionInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CampaignUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CampaignCreateWithoutSessionInput, CampaignUncheckedCreateWithoutSessionInput> | CampaignCreateWithoutSessionInput[] | CampaignUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSessionInput | CampaignCreateOrConnectWithoutSessionInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutSessionInput | CampaignUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CampaignCreateManySessionInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutSessionInput | CampaignUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutSessionInput | CampaignUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type TenantUpdateOneWithoutWhatsappSessionsNestedInput = {
    create?: XOR<TenantCreateWithoutWhatsappSessionsInput, TenantUncheckedCreateWithoutWhatsappSessionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWhatsappSessionsInput
    upsert?: TenantUpsertWithoutWhatsappSessionsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWhatsappSessionsInput, TenantUpdateWithoutWhatsappSessionsInput>, TenantUncheckedUpdateWithoutWhatsappSessionsInput>
  }

  export type CampaignUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CampaignCreateWithoutSessionInput, CampaignUncheckedCreateWithoutSessionInput> | CampaignCreateWithoutSessionInput[] | CampaignUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSessionInput | CampaignCreateOrConnectWithoutSessionInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutSessionInput | CampaignUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CampaignCreateManySessionInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutSessionInput | CampaignUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutSessionInput | CampaignUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignMessageCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput> | CampaignMessageCreateWithoutCampaignInput[] | CampaignMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutCampaignInput | CampaignMessageCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignMessageCreateManyCampaignInputEnvelope
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
  }

  export type WhatsAppSessionCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<WhatsAppSessionCreateWithoutCampaignsInput, WhatsAppSessionUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutCampaignsInput
    connect?: WhatsAppSessionWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<TenantCreateWithoutCampaignsInput, TenantUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCampaignsInput
    connect?: TenantWhereUniqueInput
  }

  export type CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput> | CampaignMessageCreateWithoutCampaignInput[] | CampaignMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutCampaignInput | CampaignMessageCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignMessageCreateManyCampaignInputEnvelope
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
  }

  export type CampaignMessageUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput> | CampaignMessageCreateWithoutCampaignInput[] | CampaignMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutCampaignInput | CampaignMessageCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput | CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignMessageCreateManyCampaignInputEnvelope
    set?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    disconnect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    delete?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    update?: CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput | CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignMessageUpdateManyWithWhereWithoutCampaignInput | CampaignMessageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
  }

  export type WhatsAppSessionUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<WhatsAppSessionCreateWithoutCampaignsInput, WhatsAppSessionUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutCampaignsInput
    upsert?: WhatsAppSessionUpsertWithoutCampaignsInput
    disconnect?: WhatsAppSessionWhereInput | boolean
    delete?: WhatsAppSessionWhereInput | boolean
    connect?: WhatsAppSessionWhereUniqueInput
    update?: XOR<XOR<WhatsAppSessionUpdateToOneWithWhereWithoutCampaignsInput, WhatsAppSessionUpdateWithoutCampaignsInput>, WhatsAppSessionUncheckedUpdateWithoutCampaignsInput>
  }

  export type TenantUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<TenantCreateWithoutCampaignsInput, TenantUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCampaignsInput
    upsert?: TenantUpsertWithoutCampaignsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCampaignsInput, TenantUpdateWithoutCampaignsInput>, TenantUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput> | CampaignMessageCreateWithoutCampaignInput[] | CampaignMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutCampaignInput | CampaignMessageCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput | CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignMessageCreateManyCampaignInputEnvelope
    set?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    disconnect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    delete?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    update?: CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput | CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignMessageUpdateManyWithWhereWithoutCampaignInput | CampaignMessageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutMessagesInput = {
    create?: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessagesInput
    connect?: CampaignWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutCampaignMessagesInput = {
    create?: XOR<TenantCreateWithoutCampaignMessagesInput, TenantUncheckedCreateWithoutCampaignMessagesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCampaignMessagesInput
    connect?: TenantWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessagesInput
    upsert?: CampaignUpsertWithoutMessagesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMessagesInput, CampaignUpdateWithoutMessagesInput>, CampaignUncheckedUpdateWithoutMessagesInput>
  }

  export type TenantUpdateOneWithoutCampaignMessagesNestedInput = {
    create?: XOR<TenantCreateWithoutCampaignMessagesInput, TenantUncheckedCreateWithoutCampaignMessagesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCampaignMessagesInput
    upsert?: TenantUpsertWithoutCampaignMessagesInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCampaignMessagesInput, TenantUpdateWithoutCampaignMessagesInput>, TenantUncheckedUpdateWithoutCampaignMessagesInput>
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type UserTenantCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTenantCreateWithoutUserInput, UserTenantUncheckedCreateWithoutUserInput> | UserTenantCreateWithoutUserInput[] | UserTenantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTenantCreateOrConnectWithoutUserInput | UserTenantCreateOrConnectWithoutUserInput[]
    createMany?: UserTenantCreateManyUserInputEnvelope
    connect?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
  }

  export type AlertCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<UserNotificationCreateWithoutUserInput, UserNotificationUncheckedCreateWithoutUserInput> | UserNotificationCreateWithoutUserInput[] | UserNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNotificationCreateOrConnectWithoutUserInput | UserNotificationCreateOrConnectWithoutUserInput[]
    createMany?: UserNotificationCreateManyUserInputEnvelope
    connect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
  }

  export type MessageTemplateCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MessageTemplateCreateWithoutCreatorInput, MessageTemplateUncheckedCreateWithoutCreatorInput> | MessageTemplateCreateWithoutCreatorInput[] | MessageTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutCreatorInput | MessageTemplateCreateOrConnectWithoutCreatorInput[]
    createMany?: MessageTemplateCreateManyCreatorInputEnvelope
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
  }

  export type AutomationFlowCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AutomationFlowCreateWithoutCreatorInput, AutomationFlowUncheckedCreateWithoutCreatorInput> | AutomationFlowCreateWithoutCreatorInput[] | AutomationFlowUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AutomationFlowCreateOrConnectWithoutCreatorInput | AutomationFlowCreateOrConnectWithoutCreatorInput[]
    createMany?: AutomationFlowCreateManyCreatorInputEnvelope
    connect?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
  }

  export type IntegrationCreateNestedManyWithoutCreatorInput = {
    create?: XOR<IntegrationCreateWithoutCreatorInput, IntegrationUncheckedCreateWithoutCreatorInput> | IntegrationCreateWithoutCreatorInput[] | IntegrationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutCreatorInput | IntegrationCreateOrConnectWithoutCreatorInput[]
    createMany?: IntegrationCreateManyCreatorInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserTenantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTenantCreateWithoutUserInput, UserTenantUncheckedCreateWithoutUserInput> | UserTenantCreateWithoutUserInput[] | UserTenantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTenantCreateOrConnectWithoutUserInput | UserTenantCreateOrConnectWithoutUserInput[]
    createMany?: UserTenantCreateManyUserInputEnvelope
    connect?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserNotificationCreateWithoutUserInput, UserNotificationUncheckedCreateWithoutUserInput> | UserNotificationCreateWithoutUserInput[] | UserNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNotificationCreateOrConnectWithoutUserInput | UserNotificationCreateOrConnectWithoutUserInput[]
    createMany?: UserNotificationCreateManyUserInputEnvelope
    connect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
  }

  export type MessageTemplateUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MessageTemplateCreateWithoutCreatorInput, MessageTemplateUncheckedCreateWithoutCreatorInput> | MessageTemplateCreateWithoutCreatorInput[] | MessageTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutCreatorInput | MessageTemplateCreateOrConnectWithoutCreatorInput[]
    createMany?: MessageTemplateCreateManyCreatorInputEnvelope
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
  }

  export type AutomationFlowUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AutomationFlowCreateWithoutCreatorInput, AutomationFlowUncheckedCreateWithoutCreatorInput> | AutomationFlowCreateWithoutCreatorInput[] | AutomationFlowUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AutomationFlowCreateOrConnectWithoutCreatorInput | AutomationFlowCreateOrConnectWithoutCreatorInput[]
    createMany?: AutomationFlowCreateManyCreatorInputEnvelope
    connect?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
  }

  export type IntegrationUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<IntegrationCreateWithoutCreatorInput, IntegrationUncheckedCreateWithoutCreatorInput> | IntegrationCreateWithoutCreatorInput[] | IntegrationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutCreatorInput | IntegrationCreateOrConnectWithoutCreatorInput[]
    createMany?: IntegrationCreateManyCreatorInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type TenantUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type UserTenantUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTenantCreateWithoutUserInput, UserTenantUncheckedCreateWithoutUserInput> | UserTenantCreateWithoutUserInput[] | UserTenantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTenantCreateOrConnectWithoutUserInput | UserTenantCreateOrConnectWithoutUserInput[]
    upsert?: UserTenantUpsertWithWhereUniqueWithoutUserInput | UserTenantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTenantCreateManyUserInputEnvelope
    set?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    disconnect?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    delete?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    connect?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    update?: UserTenantUpdateWithWhereUniqueWithoutUserInput | UserTenantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTenantUpdateManyWithWhereWithoutUserInput | UserTenantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTenantScalarWhereInput | UserTenantScalarWhereInput[]
  }

  export type AlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutUserInput | AlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutUserInput | AlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutUserInput | AlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserNotificationCreateWithoutUserInput, UserNotificationUncheckedCreateWithoutUserInput> | UserNotificationCreateWithoutUserInput[] | UserNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNotificationCreateOrConnectWithoutUserInput | UserNotificationCreateOrConnectWithoutUserInput[]
    upsert?: UserNotificationUpsertWithWhereUniqueWithoutUserInput | UserNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserNotificationCreateManyUserInputEnvelope
    set?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    disconnect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    delete?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    connect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    update?: UserNotificationUpdateWithWhereUniqueWithoutUserInput | UserNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserNotificationUpdateManyWithWhereWithoutUserInput | UserNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserNotificationScalarWhereInput | UserNotificationScalarWhereInput[]
  }

  export type MessageTemplateUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MessageTemplateCreateWithoutCreatorInput, MessageTemplateUncheckedCreateWithoutCreatorInput> | MessageTemplateCreateWithoutCreatorInput[] | MessageTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutCreatorInput | MessageTemplateCreateOrConnectWithoutCreatorInput[]
    upsert?: MessageTemplateUpsertWithWhereUniqueWithoutCreatorInput | MessageTemplateUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MessageTemplateCreateManyCreatorInputEnvelope
    set?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    disconnect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    delete?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    update?: MessageTemplateUpdateWithWhereUniqueWithoutCreatorInput | MessageTemplateUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MessageTemplateUpdateManyWithWhereWithoutCreatorInput | MessageTemplateUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
  }

  export type AutomationFlowUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AutomationFlowCreateWithoutCreatorInput, AutomationFlowUncheckedCreateWithoutCreatorInput> | AutomationFlowCreateWithoutCreatorInput[] | AutomationFlowUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AutomationFlowCreateOrConnectWithoutCreatorInput | AutomationFlowCreateOrConnectWithoutCreatorInput[]
    upsert?: AutomationFlowUpsertWithWhereUniqueWithoutCreatorInput | AutomationFlowUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AutomationFlowCreateManyCreatorInputEnvelope
    set?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    disconnect?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    delete?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    connect?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    update?: AutomationFlowUpdateWithWhereUniqueWithoutCreatorInput | AutomationFlowUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AutomationFlowUpdateManyWithWhereWithoutCreatorInput | AutomationFlowUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AutomationFlowScalarWhereInput | AutomationFlowScalarWhereInput[]
  }

  export type IntegrationUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<IntegrationCreateWithoutCreatorInput, IntegrationUncheckedCreateWithoutCreatorInput> | IntegrationCreateWithoutCreatorInput[] | IntegrationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutCreatorInput | IntegrationCreateOrConnectWithoutCreatorInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutCreatorInput | IntegrationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: IntegrationCreateManyCreatorInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutCreatorInput | IntegrationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutCreatorInput | IntegrationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserTenantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTenantCreateWithoutUserInput, UserTenantUncheckedCreateWithoutUserInput> | UserTenantCreateWithoutUserInput[] | UserTenantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTenantCreateOrConnectWithoutUserInput | UserTenantCreateOrConnectWithoutUserInput[]
    upsert?: UserTenantUpsertWithWhereUniqueWithoutUserInput | UserTenantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTenantCreateManyUserInputEnvelope
    set?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    disconnect?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    delete?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    connect?: UserTenantWhereUniqueInput | UserTenantWhereUniqueInput[]
    update?: UserTenantUpdateWithWhereUniqueWithoutUserInput | UserTenantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTenantUpdateManyWithWhereWithoutUserInput | UserTenantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTenantScalarWhereInput | UserTenantScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutUserInput | AlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutUserInput | AlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutUserInput | AlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserNotificationCreateWithoutUserInput, UserNotificationUncheckedCreateWithoutUserInput> | UserNotificationCreateWithoutUserInput[] | UserNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNotificationCreateOrConnectWithoutUserInput | UserNotificationCreateOrConnectWithoutUserInput[]
    upsert?: UserNotificationUpsertWithWhereUniqueWithoutUserInput | UserNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserNotificationCreateManyUserInputEnvelope
    set?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    disconnect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    delete?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    connect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    update?: UserNotificationUpdateWithWhereUniqueWithoutUserInput | UserNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserNotificationUpdateManyWithWhereWithoutUserInput | UserNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserNotificationScalarWhereInput | UserNotificationScalarWhereInput[]
  }

  export type MessageTemplateUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MessageTemplateCreateWithoutCreatorInput, MessageTemplateUncheckedCreateWithoutCreatorInput> | MessageTemplateCreateWithoutCreatorInput[] | MessageTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MessageTemplateCreateOrConnectWithoutCreatorInput | MessageTemplateCreateOrConnectWithoutCreatorInput[]
    upsert?: MessageTemplateUpsertWithWhereUniqueWithoutCreatorInput | MessageTemplateUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MessageTemplateCreateManyCreatorInputEnvelope
    set?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    disconnect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    delete?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    connect?: MessageTemplateWhereUniqueInput | MessageTemplateWhereUniqueInput[]
    update?: MessageTemplateUpdateWithWhereUniqueWithoutCreatorInput | MessageTemplateUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MessageTemplateUpdateManyWithWhereWithoutCreatorInput | MessageTemplateUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
  }

  export type AutomationFlowUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AutomationFlowCreateWithoutCreatorInput, AutomationFlowUncheckedCreateWithoutCreatorInput> | AutomationFlowCreateWithoutCreatorInput[] | AutomationFlowUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AutomationFlowCreateOrConnectWithoutCreatorInput | AutomationFlowCreateOrConnectWithoutCreatorInput[]
    upsert?: AutomationFlowUpsertWithWhereUniqueWithoutCreatorInput | AutomationFlowUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AutomationFlowCreateManyCreatorInputEnvelope
    set?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    disconnect?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    delete?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    connect?: AutomationFlowWhereUniqueInput | AutomationFlowWhereUniqueInput[]
    update?: AutomationFlowUpdateWithWhereUniqueWithoutCreatorInput | AutomationFlowUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AutomationFlowUpdateManyWithWhereWithoutCreatorInput | AutomationFlowUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AutomationFlowScalarWhereInput | AutomationFlowScalarWhereInput[]
  }

  export type IntegrationUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<IntegrationCreateWithoutCreatorInput, IntegrationUncheckedCreateWithoutCreatorInput> | IntegrationCreateWithoutCreatorInput[] | IntegrationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutCreatorInput | IntegrationCreateOrConnectWithoutCreatorInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutCreatorInput | IntegrationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: IntegrationCreateManyCreatorInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutCreatorInput | IntegrationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutCreatorInput | IntegrationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutAlertsInput = {
    create?: XOR<TenantCreateWithoutAlertsInput, TenantUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAlertsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAlertsInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutAlertInput = {
    create?: XOR<NotificationCreateWithoutAlertInput, NotificationUncheckedCreateWithoutAlertInput> | NotificationCreateWithoutAlertInput[] | NotificationUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAlertInput | NotificationCreateOrConnectWithoutAlertInput[]
    createMany?: NotificationCreateManyAlertInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutAlertInput = {
    create?: XOR<NotificationCreateWithoutAlertInput, NotificationUncheckedCreateWithoutAlertInput> | NotificationCreateWithoutAlertInput[] | NotificationUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAlertInput | NotificationCreateOrConnectWithoutAlertInput[]
    createMany?: NotificationCreateManyAlertInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumAlertTypeFieldUpdateOperationsInput = {
    set?: $Enums.AlertType
  }

  export type EnumAlertSeverityFieldUpdateOperationsInput = {
    set?: $Enums.AlertSeverity
  }

  export type TenantUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<TenantCreateWithoutAlertsInput, TenantUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAlertsInput
    upsert?: TenantUpsertWithoutAlertsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAlertsInput, TenantUpdateWithoutAlertsInput>, TenantUncheckedUpdateWithoutAlertsInput>
  }

  export type UserUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    upsert?: UserUpsertWithoutAlertsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlertsInput, UserUpdateWithoutAlertsInput>, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type NotificationUpdateManyWithoutAlertNestedInput = {
    create?: XOR<NotificationCreateWithoutAlertInput, NotificationUncheckedCreateWithoutAlertInput> | NotificationCreateWithoutAlertInput[] | NotificationUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAlertInput | NotificationCreateOrConnectWithoutAlertInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAlertInput | NotificationUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: NotificationCreateManyAlertInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAlertInput | NotificationUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAlertInput | NotificationUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutAlertNestedInput = {
    create?: XOR<NotificationCreateWithoutAlertInput, NotificationUncheckedCreateWithoutAlertInput> | NotificationCreateWithoutAlertInput[] | NotificationUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAlertInput | NotificationCreateOrConnectWithoutAlertInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAlertInput | NotificationUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: NotificationCreateManyAlertInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAlertInput | NotificationUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAlertInput | NotificationUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AlertCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<AlertCreateWithoutNotificationsInput, AlertUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AlertCreateOrConnectWithoutNotificationsInput
    connect?: AlertWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationMethodFieldUpdateOperationsInput = {
    set?: $Enums.NotificationMethod
  }

  export type AlertUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<AlertCreateWithoutNotificationsInput, AlertUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AlertCreateOrConnectWithoutNotificationsInput
    upsert?: AlertUpsertWithoutNotificationsInput
    connect?: AlertWhereUniqueInput
    update?: XOR<XOR<AlertUpdateToOneWithWhereWithoutNotificationsInput, AlertUpdateWithoutNotificationsInput>, AlertUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutUserNotificationsInput = {
    create?: XOR<UserCreateWithoutUserNotificationsInput, UserUncheckedCreateWithoutUserNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumUserNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserNotificationType
  }

  export type UserUpdateOneRequiredWithoutUserNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutUserNotificationsInput, UserUncheckedCreateWithoutUserNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserNotificationsInput
    upsert?: UserUpsertWithoutUserNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserNotificationsInput, UserUpdateWithoutUserNotificationsInput>, UserUncheckedUpdateWithoutUserNotificationsInput>
  }

  export type MessageTemplateCreatevariablesInput = {
    set: string[]
  }

  export type MessageTemplateCreatetagsInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutMessageTemplatesInput = {
    create?: XOR<TenantCreateWithoutMessageTemplatesInput, TenantUncheckedCreateWithoutMessageTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMessageTemplatesInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTemplatesInput = {
    create?: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type MessageTemplateUpdatevariablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MessageTemplateUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TenantUpdateOneRequiredWithoutMessageTemplatesNestedInput = {
    create?: XOR<TenantCreateWithoutMessageTemplatesInput, TenantUncheckedCreateWithoutMessageTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMessageTemplatesInput
    upsert?: TenantUpsertWithoutMessageTemplatesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutMessageTemplatesInput, TenantUpdateWithoutMessageTemplatesInput>, TenantUncheckedUpdateWithoutMessageTemplatesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTemplatesInput
    upsert?: UserUpsertWithoutCreatedTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTemplatesInput, UserUpdateWithoutCreatedTemplatesInput>, UserUncheckedUpdateWithoutCreatedTemplatesInput>
  }

  export type TenantCreateNestedOneWithoutAutomationFlowsInput = {
    create?: XOR<TenantCreateWithoutAutomationFlowsInput, TenantUncheckedCreateWithoutAutomationFlowsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAutomationFlowsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedFlowsInput = {
    create?: XOR<UserCreateWithoutCreatedFlowsInput, UserUncheckedCreateWithoutCreatedFlowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFlowsInput
    connect?: UserWhereUniqueInput
  }

  export type AutomationExecutionCreateNestedManyWithoutFlowInput = {
    create?: XOR<AutomationExecutionCreateWithoutFlowInput, AutomationExecutionUncheckedCreateWithoutFlowInput> | AutomationExecutionCreateWithoutFlowInput[] | AutomationExecutionUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutFlowInput | AutomationExecutionCreateOrConnectWithoutFlowInput[]
    createMany?: AutomationExecutionCreateManyFlowInputEnvelope
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
  }

  export type AutomationExecutionUncheckedCreateNestedManyWithoutFlowInput = {
    create?: XOR<AutomationExecutionCreateWithoutFlowInput, AutomationExecutionUncheckedCreateWithoutFlowInput> | AutomationExecutionCreateWithoutFlowInput[] | AutomationExecutionUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutFlowInput | AutomationExecutionCreateOrConnectWithoutFlowInput[]
    createMany?: AutomationExecutionCreateManyFlowInputEnvelope
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutAutomationFlowsNestedInput = {
    create?: XOR<TenantCreateWithoutAutomationFlowsInput, TenantUncheckedCreateWithoutAutomationFlowsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAutomationFlowsInput
    upsert?: TenantUpsertWithoutAutomationFlowsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAutomationFlowsInput, TenantUpdateWithoutAutomationFlowsInput>, TenantUncheckedUpdateWithoutAutomationFlowsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedFlowsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedFlowsInput, UserUncheckedCreateWithoutCreatedFlowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFlowsInput
    upsert?: UserUpsertWithoutCreatedFlowsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedFlowsInput, UserUpdateWithoutCreatedFlowsInput>, UserUncheckedUpdateWithoutCreatedFlowsInput>
  }

  export type AutomationExecutionUpdateManyWithoutFlowNestedInput = {
    create?: XOR<AutomationExecutionCreateWithoutFlowInput, AutomationExecutionUncheckedCreateWithoutFlowInput> | AutomationExecutionCreateWithoutFlowInput[] | AutomationExecutionUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutFlowInput | AutomationExecutionCreateOrConnectWithoutFlowInput[]
    upsert?: AutomationExecutionUpsertWithWhereUniqueWithoutFlowInput | AutomationExecutionUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: AutomationExecutionCreateManyFlowInputEnvelope
    set?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    disconnect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    delete?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    update?: AutomationExecutionUpdateWithWhereUniqueWithoutFlowInput | AutomationExecutionUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: AutomationExecutionUpdateManyWithWhereWithoutFlowInput | AutomationExecutionUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
  }

  export type AutomationExecutionUncheckedUpdateManyWithoutFlowNestedInput = {
    create?: XOR<AutomationExecutionCreateWithoutFlowInput, AutomationExecutionUncheckedCreateWithoutFlowInput> | AutomationExecutionCreateWithoutFlowInput[] | AutomationExecutionUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutFlowInput | AutomationExecutionCreateOrConnectWithoutFlowInput[]
    upsert?: AutomationExecutionUpsertWithWhereUniqueWithoutFlowInput | AutomationExecutionUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: AutomationExecutionCreateManyFlowInputEnvelope
    set?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    disconnect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    delete?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    update?: AutomationExecutionUpdateWithWhereUniqueWithoutFlowInput | AutomationExecutionUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: AutomationExecutionUpdateManyWithWhereWithoutFlowInput | AutomationExecutionUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
  }

  export type AutomationFlowCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<AutomationFlowCreateWithoutExecutionsInput, AutomationFlowUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: AutomationFlowCreateOrConnectWithoutExecutionsInput
    connect?: AutomationFlowWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AutomationFlowUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<AutomationFlowCreateWithoutExecutionsInput, AutomationFlowUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: AutomationFlowCreateOrConnectWithoutExecutionsInput
    upsert?: AutomationFlowUpsertWithoutExecutionsInput
    connect?: AutomationFlowWhereUniqueInput
    update?: XOR<XOR<AutomationFlowUpdateToOneWithWhereWithoutExecutionsInput, AutomationFlowUpdateWithoutExecutionsInput>, AutomationFlowUncheckedUpdateWithoutExecutionsInput>
  }

  export type TenantCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<TenantCreateWithoutIntegrationsInput, TenantUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIntegrationsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedIntegrationsInput = {
    create?: XOR<UserCreateWithoutCreatedIntegrationsInput, UserUncheckedCreateWithoutCreatedIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedIntegrationsInput
    connect?: UserWhereUniqueInput
  }

  export type IntegrationSyncCreateNestedManyWithoutIntegrationInput = {
    create?: XOR<IntegrationSyncCreateWithoutIntegrationInput, IntegrationSyncUncheckedCreateWithoutIntegrationInput> | IntegrationSyncCreateWithoutIntegrationInput[] | IntegrationSyncUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: IntegrationSyncCreateOrConnectWithoutIntegrationInput | IntegrationSyncCreateOrConnectWithoutIntegrationInput[]
    createMany?: IntegrationSyncCreateManyIntegrationInputEnvelope
    connect?: IntegrationSyncWhereUniqueInput | IntegrationSyncWhereUniqueInput[]
  }

  export type IntegrationSyncUncheckedCreateNestedManyWithoutIntegrationInput = {
    create?: XOR<IntegrationSyncCreateWithoutIntegrationInput, IntegrationSyncUncheckedCreateWithoutIntegrationInput> | IntegrationSyncCreateWithoutIntegrationInput[] | IntegrationSyncUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: IntegrationSyncCreateOrConnectWithoutIntegrationInput | IntegrationSyncCreateOrConnectWithoutIntegrationInput[]
    createMany?: IntegrationSyncCreateManyIntegrationInputEnvelope
    connect?: IntegrationSyncWhereUniqueInput | IntegrationSyncWhereUniqueInput[]
  }

  export type EnumIntegrationTypeFieldUpdateOperationsInput = {
    set?: $Enums.IntegrationType
  }

  export type TenantUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<TenantCreateWithoutIntegrationsInput, TenantUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIntegrationsInput
    upsert?: TenantUpsertWithoutIntegrationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutIntegrationsInput, TenantUpdateWithoutIntegrationsInput>, TenantUncheckedUpdateWithoutIntegrationsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedIntegrationsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedIntegrationsInput, UserUncheckedCreateWithoutCreatedIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedIntegrationsInput
    upsert?: UserUpsertWithoutCreatedIntegrationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedIntegrationsInput, UserUpdateWithoutCreatedIntegrationsInput>, UserUncheckedUpdateWithoutCreatedIntegrationsInput>
  }

  export type IntegrationSyncUpdateManyWithoutIntegrationNestedInput = {
    create?: XOR<IntegrationSyncCreateWithoutIntegrationInput, IntegrationSyncUncheckedCreateWithoutIntegrationInput> | IntegrationSyncCreateWithoutIntegrationInput[] | IntegrationSyncUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: IntegrationSyncCreateOrConnectWithoutIntegrationInput | IntegrationSyncCreateOrConnectWithoutIntegrationInput[]
    upsert?: IntegrationSyncUpsertWithWhereUniqueWithoutIntegrationInput | IntegrationSyncUpsertWithWhereUniqueWithoutIntegrationInput[]
    createMany?: IntegrationSyncCreateManyIntegrationInputEnvelope
    set?: IntegrationSyncWhereUniqueInput | IntegrationSyncWhereUniqueInput[]
    disconnect?: IntegrationSyncWhereUniqueInput | IntegrationSyncWhereUniqueInput[]
    delete?: IntegrationSyncWhereUniqueInput | IntegrationSyncWhereUniqueInput[]
    connect?: IntegrationSyncWhereUniqueInput | IntegrationSyncWhereUniqueInput[]
    update?: IntegrationSyncUpdateWithWhereUniqueWithoutIntegrationInput | IntegrationSyncUpdateWithWhereUniqueWithoutIntegrationInput[]
    updateMany?: IntegrationSyncUpdateManyWithWhereWithoutIntegrationInput | IntegrationSyncUpdateManyWithWhereWithoutIntegrationInput[]
    deleteMany?: IntegrationSyncScalarWhereInput | IntegrationSyncScalarWhereInput[]
  }

  export type IntegrationSyncUncheckedUpdateManyWithoutIntegrationNestedInput = {
    create?: XOR<IntegrationSyncCreateWithoutIntegrationInput, IntegrationSyncUncheckedCreateWithoutIntegrationInput> | IntegrationSyncCreateWithoutIntegrationInput[] | IntegrationSyncUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: IntegrationSyncCreateOrConnectWithoutIntegrationInput | IntegrationSyncCreateOrConnectWithoutIntegrationInput[]
    upsert?: IntegrationSyncUpsertWithWhereUniqueWithoutIntegrationInput | IntegrationSyncUpsertWithWhereUniqueWithoutIntegrationInput[]
    createMany?: IntegrationSyncCreateManyIntegrationInputEnvelope
    set?: IntegrationSyncWhereUniqueInput | IntegrationSyncWhereUniqueInput[]
    disconnect?: IntegrationSyncWhereUniqueInput | IntegrationSyncWhereUniqueInput[]
    delete?: IntegrationSyncWhereUniqueInput | IntegrationSyncWhereUniqueInput[]
    connect?: IntegrationSyncWhereUniqueInput | IntegrationSyncWhereUniqueInput[]
    update?: IntegrationSyncUpdateWithWhereUniqueWithoutIntegrationInput | IntegrationSyncUpdateWithWhereUniqueWithoutIntegrationInput[]
    updateMany?: IntegrationSyncUpdateManyWithWhereWithoutIntegrationInput | IntegrationSyncUpdateManyWithWhereWithoutIntegrationInput[]
    deleteMany?: IntegrationSyncScalarWhereInput | IntegrationSyncScalarWhereInput[]
  }

  export type IntegrationCreateNestedOneWithoutSyncLogsInput = {
    create?: XOR<IntegrationCreateWithoutSyncLogsInput, IntegrationUncheckedCreateWithoutSyncLogsInput>
    connectOrCreate?: IntegrationCreateOrConnectWithoutSyncLogsInput
    connect?: IntegrationWhereUniqueInput
  }

  export type IntegrationUpdateOneRequiredWithoutSyncLogsNestedInput = {
    create?: XOR<IntegrationCreateWithoutSyncLogsInput, IntegrationUncheckedCreateWithoutSyncLogsInput>
    connectOrCreate?: IntegrationCreateOrConnectWithoutSyncLogsInput
    upsert?: IntegrationUpsertWithoutSyncLogsInput
    connect?: IntegrationWhereUniqueInput
    update?: XOR<XOR<IntegrationUpdateToOneWithWhereWithoutSyncLogsInput, IntegrationUpdateWithoutSyncLogsInput>, IntegrationUncheckedUpdateWithoutSyncLogsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    upsert?: TenantUpsertWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditLogsInput, TenantUpdateWithoutAuditLogsInput>, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type NestedEnumAlertSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertSeverityFilter<$PrismaModel> | $Enums.AlertSeverity
  }

  export type NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel> | $Enums.AlertSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertSeverityFilter<$PrismaModel>
    _max?: NestedEnumAlertSeverityFilter<$PrismaModel>
  }

  export type NestedEnumNotificationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationMethod | EnumNotificationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationMethod[] | ListEnumNotificationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationMethod[] | ListEnumNotificationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationMethodFilter<$PrismaModel> | $Enums.NotificationMethod
  }

  export type NestedEnumNotificationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationMethod | EnumNotificationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationMethod[] | ListEnumNotificationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationMethod[] | ListEnumNotificationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationMethodWithAggregatesFilter<$PrismaModel> | $Enums.NotificationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationMethodFilter<$PrismaModel>
    _max?: NestedEnumNotificationMethodFilter<$PrismaModel>
  }

  export type NestedEnumUserNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserNotificationType | EnumUserNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserNotificationType[] | ListEnumUserNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserNotificationType[] | ListEnumUserNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserNotificationTypeFilter<$PrismaModel> | $Enums.UserNotificationType
  }

  export type NestedEnumUserNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserNotificationType | EnumUserNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserNotificationType[] | ListEnumUserNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserNotificationType[] | ListEnumUserNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserNotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumUserNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeFilter<$PrismaModel> | $Enums.IntegrationType
  }

  export type NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumIntegrationTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenants?: UserTenantCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenants?: UserTenantUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserTenantCreateWithoutTenantInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTenantsInput
  }

  export type UserTenantUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTenantCreateOrConnectWithoutTenantInput = {
    where: UserTenantWhereUniqueInput
    create: XOR<UserTenantCreateWithoutTenantInput, UserTenantUncheckedCreateWithoutTenantInput>
  }

  export type UserTenantCreateManyTenantInputEnvelope = {
    data: UserTenantCreateManyTenantInput | UserTenantCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutTenantInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    tags?: ContactCreatetagsInput | string[]
    observacoes?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    categoria?: CategoryCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutTenantInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    tags?: ContactCreatetagsInput | string[]
    observacoes?: string | null
    categoriaId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type ContactCreateOrConnectWithoutTenantInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput>
  }

  export type ContactCreateManyTenantInputEnvelope = {
    data: ContactCreateManyTenantInput | ContactCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutTenantInput = {
    id?: string
    nome: string
    cor: string
    descricao?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    contacts?: ContactCreateNestedManyWithoutCategoriaInput
  }

  export type CategoryUncheckedCreateWithoutTenantInput = {
    id?: string
    nome: string
    cor: string
    descricao?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoryCreateOrConnectWithoutTenantInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput>
  }

  export type CategoryCreateManyTenantInputEnvelope = {
    data: CategoryCreateManyTenantInput | CategoryCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutTenantInput = {
    id?: string
    nome: string
    targetTags: string
    messageType: string
    messageContent: string
    randomDelay: number
    startImmediately: boolean
    scheduledFor?: Date | string | null
    status?: string
    totalContacts?: number
    sentCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    useTimeWindow?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionNames?: string | null
    createdBy?: string | null
    createdByName?: string | null
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    session?: WhatsAppSessionCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutTenantInput = {
    id?: string
    nome: string
    targetTags: string
    sessionName?: string | null
    messageType: string
    messageContent: string
    randomDelay: number
    startImmediately: boolean
    scheduledFor?: Date | string | null
    status?: string
    totalContacts?: number
    sentCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    useTimeWindow?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionNames?: string | null
    createdBy?: string | null
    createdByName?: string | null
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTenantInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTenantInput, CampaignUncheckedCreateWithoutTenantInput>
  }

  export type CampaignCreateManyTenantInputEnvelope = {
    data: CampaignCreateManyTenantInput | CampaignCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CampaignMessageCreateWithoutTenantInput = {
    id?: string
    contactId: string
    contactPhone: string
    contactName: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    errorMessage?: string | null
    messageId?: string | null
    selectedVariation?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionName?: string | null
    campaign: CampaignCreateNestedOneWithoutMessagesInput
  }

  export type CampaignMessageUncheckedCreateWithoutTenantInput = {
    id?: string
    campaignId: string
    contactId: string
    contactPhone: string
    contactName: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    errorMessage?: string | null
    messageId?: string | null
    selectedVariation?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionName?: string | null
  }

  export type CampaignMessageCreateOrConnectWithoutTenantInput = {
    where: CampaignMessageWhereUniqueInput
    create: XOR<CampaignMessageCreateWithoutTenantInput, CampaignMessageUncheckedCreateWithoutTenantInput>
  }

  export type CampaignMessageCreateManyTenantInputEnvelope = {
    data: CampaignMessageCreateManyTenantInput | CampaignMessageCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppSessionCreateWithoutTenantInput = {
    id?: string
    name: string
    displayName?: string | null
    status: string
    config?: string | null
    meId?: string | null
    mePushName?: string | null
    meLid?: string | null
    meJid?: string | null
    qr?: string | null
    qrExpiresAt?: Date | string | null
    assignedWorker?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    provider?: string
    quepasaToken?: string | null
    campaigns?: CampaignCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    displayName?: string | null
    status: string
    config?: string | null
    meId?: string | null
    mePushName?: string | null
    meLid?: string | null
    meJid?: string | null
    qr?: string | null
    qrExpiresAt?: Date | string | null
    assignedWorker?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    provider?: string
    quepasaToken?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionCreateOrConnectWithoutTenantInput = {
    where: WhatsAppSessionWhereUniqueInput
    create: XOR<WhatsAppSessionCreateWithoutTenantInput, WhatsAppSessionUncheckedCreateWithoutTenantInput>
  }

  export type WhatsAppSessionCreateManyTenantInputEnvelope = {
    data: WhatsAppSessionCreateManyTenantInput | WhatsAppSessionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantQuotaCreateWithoutTenantInput = {
    id?: string
    maxUsers?: number
    maxContacts?: number
    maxCampaigns?: number
    maxConnections?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantQuotaUncheckedCreateWithoutTenantInput = {
    id?: string
    maxUsers?: number
    maxContacts?: number
    maxCampaigns?: number
    maxConnections?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantQuotaCreateOrConnectWithoutTenantInput = {
    where: TenantQuotaWhereUniqueInput
    create: XOR<TenantQuotaCreateWithoutTenantInput, TenantQuotaUncheckedCreateWithoutTenantInput>
  }

  export type TenantSettingsCreateWithoutTenantInput = {
    id?: string
    openaiApiKey?: string | null
    groqApiKey?: string | null
    customBranding?: NullableJsonNullValueInput | InputJsonValue
    chatwootUrl?: string | null
    chatwootAccountId?: string | null
    chatwootApiToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantSettingsUncheckedCreateWithoutTenantInput = {
    id?: string
    openaiApiKey?: string | null
    groqApiKey?: string | null
    customBranding?: NullableJsonNullValueInput | InputJsonValue
    chatwootUrl?: string | null
    chatwootAccountId?: string | null
    chatwootApiToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantSettingsCreateOrConnectWithoutTenantInput = {
    where: TenantSettingsWhereUniqueInput
    create: XOR<TenantSettingsCreateWithoutTenantInput, TenantSettingsUncheckedCreateWithoutTenantInput>
  }

  export type AlertCreateWithoutTenantInput = {
    id?: string
    type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    title: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAlertsInput
    notifications?: NotificationCreateNestedManyWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutTenantInput = {
    id?: string
    type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    title: string
    message: string
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutAlertInput
  }

  export type AlertCreateOrConnectWithoutTenantInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutTenantInput, AlertUncheckedCreateWithoutTenantInput>
  }

  export type AlertCreateManyTenantInputEnvelope = {
    data: AlertCreateManyTenantInput | AlertCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type MessageTemplateCreateWithoutTenantInput = {
    id?: string
    name: string
    category: string
    messageType: $Enums.MessageType
    content: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    active?: boolean
    tags?: MessageTemplateCreatetagsInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedTemplatesInput
  }

  export type MessageTemplateUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    category: string
    messageType: $Enums.MessageType
    content: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    active?: boolean
    tags?: MessageTemplateCreatetagsInput | string[]
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateCreateOrConnectWithoutTenantInput = {
    where: MessageTemplateWhereUniqueInput
    create: XOR<MessageTemplateCreateWithoutTenantInput, MessageTemplateUncheckedCreateWithoutTenantInput>
  }

  export type MessageTemplateCreateManyTenantInputEnvelope = {
    data: MessageTemplateCreateManyTenantInput | MessageTemplateCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AutomationFlowCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean
    trigger: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedFlowsInput
    executions?: AutomationExecutionCreateNestedManyWithoutFlowInput
  }

  export type AutomationFlowUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean
    trigger: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: AutomationExecutionUncheckedCreateNestedManyWithoutFlowInput
  }

  export type AutomationFlowCreateOrConnectWithoutTenantInput = {
    where: AutomationFlowWhereUniqueInput
    create: XOR<AutomationFlowCreateWithoutTenantInput, AutomationFlowUncheckedCreateWithoutTenantInput>
  }

  export type AutomationFlowCreateManyTenantInputEnvelope = {
    data: AutomationFlowCreateManyTenantInput | AutomationFlowCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type IntegrationCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    active?: boolean
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    lastSyncAt?: Date | string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedIntegrationsInput
    syncLogs?: IntegrationSyncCreateNestedManyWithoutIntegrationInput
  }

  export type IntegrationUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    active?: boolean
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    lastSyncAt?: Date | string | null
    lastError?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncLogs?: IntegrationSyncUncheckedCreateNestedManyWithoutIntegrationInput
  }

  export type IntegrationCreateOrConnectWithoutTenantInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput>
  }

  export type IntegrationCreateManyTenantInputEnvelope = {
    data: IntegrationCreateManyTenantInput | IntegrationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutTenantInput = {
    id?: string
    action: string
    severity: string
    entityType?: string | null
    entityId?: string | null
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutTenantInput = {
    id?: string
    action: string
    severity: string
    userId?: string | null
    entityType?: string | null
    entityId?: string | null
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogCreateManyTenantInputEnvelope = {
    data: AuditLogCreateManyTenantInput | AuditLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    nome?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    senha?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    ativo?: BoolFilter<"User"> | boolean
    tenantId?: StringNullableFilter<"User"> | string | null
    ultimoLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    criadoEm?: DateTimeFilter<"User"> | Date | string
    atualizadoEm?: DateTimeFilter<"User"> | Date | string
  }

  export type UserTenantUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserTenantWhereUniqueInput
    update: XOR<UserTenantUpdateWithoutTenantInput, UserTenantUncheckedUpdateWithoutTenantInput>
    create: XOR<UserTenantCreateWithoutTenantInput, UserTenantUncheckedCreateWithoutTenantInput>
  }

  export type UserTenantUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserTenantWhereUniqueInput
    data: XOR<UserTenantUpdateWithoutTenantInput, UserTenantUncheckedUpdateWithoutTenantInput>
  }

  export type UserTenantUpdateManyWithWhereWithoutTenantInput = {
    where: UserTenantScalarWhereInput
    data: XOR<UserTenantUpdateManyMutationInput, UserTenantUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserTenantScalarWhereInput = {
    AND?: UserTenantScalarWhereInput | UserTenantScalarWhereInput[]
    OR?: UserTenantScalarWhereInput[]
    NOT?: UserTenantScalarWhereInput | UserTenantScalarWhereInput[]
    id?: StringFilter<"UserTenant"> | string
    userId?: StringFilter<"UserTenant"> | string
    tenantId?: StringFilter<"UserTenant"> | string
    role?: StringFilter<"UserTenant"> | string
    createdAt?: DateTimeFilter<"UserTenant"> | Date | string
    updatedAt?: DateTimeFilter<"UserTenant"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutTenantInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutTenantInput, ContactUncheckedUpdateWithoutTenantInput>
    create: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutTenantInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutTenantInput, ContactUncheckedUpdateWithoutTenantInput>
  }

  export type ContactUpdateManyWithWhereWithoutTenantInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutTenantInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    nome?: StringFilter<"Contact"> | string
    telefone?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    tags?: StringNullableListFilter<"Contact">
    observacoes?: StringNullableFilter<"Contact"> | string | null
    categoriaId?: StringNullableFilter<"Contact"> | string | null
    tenantId?: StringNullableFilter<"Contact"> | string | null
    criadoEm?: DateTimeFilter<"Contact"> | Date | string
    atualizadoEm?: DateTimeFilter<"Contact"> | Date | string
  }

  export type CategoryUpsertWithWhereUniqueWithoutTenantInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutTenantInput, CategoryUncheckedUpdateWithoutTenantInput>
    create: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutTenantInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutTenantInput, CategoryUncheckedUpdateWithoutTenantInput>
  }

  export type CategoryUpdateManyWithWhereWithoutTenantInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutTenantInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    nome?: StringFilter<"Category"> | string
    cor?: StringFilter<"Category"> | string
    descricao?: StringNullableFilter<"Category"> | string | null
    tenantId?: StringNullableFilter<"Category"> | string | null
    criadoEm?: DateTimeFilter<"Category"> | Date | string
    atualizadoEm?: DateTimeFilter<"Category"> | Date | string
  }

  export type CampaignUpsertWithWhereUniqueWithoutTenantInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutTenantInput, CampaignUncheckedUpdateWithoutTenantInput>
    create: XOR<CampaignCreateWithoutTenantInput, CampaignUncheckedCreateWithoutTenantInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutTenantInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutTenantInput, CampaignUncheckedUpdateWithoutTenantInput>
  }

  export type CampaignUpdateManyWithWhereWithoutTenantInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutTenantInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    nome?: StringFilter<"Campaign"> | string
    targetTags?: StringFilter<"Campaign"> | string
    sessionName?: StringNullableFilter<"Campaign"> | string | null
    messageType?: StringFilter<"Campaign"> | string
    messageContent?: StringFilter<"Campaign"> | string
    randomDelay?: IntFilter<"Campaign"> | number
    startImmediately?: BoolFilter<"Campaign"> | boolean
    scheduledFor?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    status?: StringFilter<"Campaign"> | string
    totalContacts?: IntFilter<"Campaign"> | number
    sentCount?: IntFilter<"Campaign"> | number
    failedCount?: IntFilter<"Campaign"> | number
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    startTime?: StringNullableFilter<"Campaign"> | string | null
    endTime?: StringNullableFilter<"Campaign"> | string | null
    useTimeWindow?: BoolFilter<"Campaign"> | boolean
    tenantId?: StringNullableFilter<"Campaign"> | string | null
    criadoEm?: DateTimeFilter<"Campaign"> | Date | string
    atualizadoEm?: DateTimeFilter<"Campaign"> | Date | string
    sessionNames?: StringNullableFilter<"Campaign"> | string | null
    createdBy?: StringNullableFilter<"Campaign"> | string | null
    createdByName?: StringNullableFilter<"Campaign"> | string | null
  }

  export type CampaignMessageUpsertWithWhereUniqueWithoutTenantInput = {
    where: CampaignMessageWhereUniqueInput
    update: XOR<CampaignMessageUpdateWithoutTenantInput, CampaignMessageUncheckedUpdateWithoutTenantInput>
    create: XOR<CampaignMessageCreateWithoutTenantInput, CampaignMessageUncheckedCreateWithoutTenantInput>
  }

  export type CampaignMessageUpdateWithWhereUniqueWithoutTenantInput = {
    where: CampaignMessageWhereUniqueInput
    data: XOR<CampaignMessageUpdateWithoutTenantInput, CampaignMessageUncheckedUpdateWithoutTenantInput>
  }

  export type CampaignMessageUpdateManyWithWhereWithoutTenantInput = {
    where: CampaignMessageScalarWhereInput
    data: XOR<CampaignMessageUpdateManyMutationInput, CampaignMessageUncheckedUpdateManyWithoutTenantInput>
  }

  export type CampaignMessageScalarWhereInput = {
    AND?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
    OR?: CampaignMessageScalarWhereInput[]
    NOT?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
    id?: StringFilter<"CampaignMessage"> | string
    campaignId?: StringFilter<"CampaignMessage"> | string
    contactId?: StringFilter<"CampaignMessage"> | string
    contactPhone?: StringFilter<"CampaignMessage"> | string
    contactName?: StringFilter<"CampaignMessage"> | string
    status?: StringFilter<"CampaignMessage"> | string
    sentAt?: DateTimeNullableFilter<"CampaignMessage"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"CampaignMessage"> | Date | string | null
    readAt?: DateTimeNullableFilter<"CampaignMessage"> | Date | string | null
    errorMessage?: StringNullableFilter<"CampaignMessage"> | string | null
    messageId?: StringNullableFilter<"CampaignMessage"> | string | null
    selectedVariation?: StringNullableFilter<"CampaignMessage"> | string | null
    tenantId?: StringNullableFilter<"CampaignMessage"> | string | null
    criadoEm?: DateTimeFilter<"CampaignMessage"> | Date | string
    atualizadoEm?: DateTimeFilter<"CampaignMessage"> | Date | string
    sessionName?: StringNullableFilter<"CampaignMessage"> | string | null
  }

  export type WhatsAppSessionUpsertWithWhereUniqueWithoutTenantInput = {
    where: WhatsAppSessionWhereUniqueInput
    update: XOR<WhatsAppSessionUpdateWithoutTenantInput, WhatsAppSessionUncheckedUpdateWithoutTenantInput>
    create: XOR<WhatsAppSessionCreateWithoutTenantInput, WhatsAppSessionUncheckedCreateWithoutTenantInput>
  }

  export type WhatsAppSessionUpdateWithWhereUniqueWithoutTenantInput = {
    where: WhatsAppSessionWhereUniqueInput
    data: XOR<WhatsAppSessionUpdateWithoutTenantInput, WhatsAppSessionUncheckedUpdateWithoutTenantInput>
  }

  export type WhatsAppSessionUpdateManyWithWhereWithoutTenantInput = {
    where: WhatsAppSessionScalarWhereInput
    data: XOR<WhatsAppSessionUpdateManyMutationInput, WhatsAppSessionUncheckedUpdateManyWithoutTenantInput>
  }

  export type WhatsAppSessionScalarWhereInput = {
    AND?: WhatsAppSessionScalarWhereInput | WhatsAppSessionScalarWhereInput[]
    OR?: WhatsAppSessionScalarWhereInput[]
    NOT?: WhatsAppSessionScalarWhereInput | WhatsAppSessionScalarWhereInput[]
    id?: StringFilter<"WhatsAppSession"> | string
    name?: StringFilter<"WhatsAppSession"> | string
    displayName?: StringNullableFilter<"WhatsAppSession"> | string | null
    status?: StringFilter<"WhatsAppSession"> | string
    config?: StringNullableFilter<"WhatsAppSession"> | string | null
    meId?: StringNullableFilter<"WhatsAppSession"> | string | null
    mePushName?: StringNullableFilter<"WhatsAppSession"> | string | null
    meLid?: StringNullableFilter<"WhatsAppSession"> | string | null
    meJid?: StringNullableFilter<"WhatsAppSession"> | string | null
    qr?: StringNullableFilter<"WhatsAppSession"> | string | null
    qrExpiresAt?: DateTimeNullableFilter<"WhatsAppSession"> | Date | string | null
    assignedWorker?: StringNullableFilter<"WhatsAppSession"> | string | null
    tenantId?: StringNullableFilter<"WhatsAppSession"> | string | null
    criadoEm?: DateTimeFilter<"WhatsAppSession"> | Date | string
    atualizadoEm?: DateTimeFilter<"WhatsAppSession"> | Date | string
    provider?: StringFilter<"WhatsAppSession"> | string
    quepasaToken?: StringNullableFilter<"WhatsAppSession"> | string | null
  }

  export type TenantQuotaUpsertWithoutTenantInput = {
    update: XOR<TenantQuotaUpdateWithoutTenantInput, TenantQuotaUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantQuotaCreateWithoutTenantInput, TenantQuotaUncheckedCreateWithoutTenantInput>
    where?: TenantQuotaWhereInput
  }

  export type TenantQuotaUpdateToOneWithWhereWithoutTenantInput = {
    where?: TenantQuotaWhereInput
    data: XOR<TenantQuotaUpdateWithoutTenantInput, TenantQuotaUncheckedUpdateWithoutTenantInput>
  }

  export type TenantQuotaUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxContacts?: IntFieldUpdateOperationsInput | number
    maxCampaigns?: IntFieldUpdateOperationsInput | number
    maxConnections?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantQuotaUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxContacts?: IntFieldUpdateOperationsInput | number
    maxCampaigns?: IntFieldUpdateOperationsInput | number
    maxConnections?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsUpsertWithoutTenantInput = {
    update: XOR<TenantSettingsUpdateWithoutTenantInput, TenantSettingsUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantSettingsCreateWithoutTenantInput, TenantSettingsUncheckedCreateWithoutTenantInput>
    where?: TenantSettingsWhereInput
  }

  export type TenantSettingsUpdateToOneWithWhereWithoutTenantInput = {
    where?: TenantSettingsWhereInput
    data: XOR<TenantSettingsUpdateWithoutTenantInput, TenantSettingsUncheckedUpdateWithoutTenantInput>
  }

  export type TenantSettingsUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    customBranding?: NullableJsonNullValueInput | InputJsonValue
    chatwootUrl?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    customBranding?: NullableJsonNullValueInput | InputJsonValue
    chatwootUrl?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootApiToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUpsertWithWhereUniqueWithoutTenantInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutTenantInput, AlertUncheckedUpdateWithoutTenantInput>
    create: XOR<AlertCreateWithoutTenantInput, AlertUncheckedCreateWithoutTenantInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutTenantInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutTenantInput, AlertUncheckedUpdateWithoutTenantInput>
  }

  export type AlertUpdateManyWithWhereWithoutTenantInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutTenantInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    severity?: EnumAlertSeverityFilter<"Alert"> | $Enums.AlertSeverity
    title?: StringFilter<"Alert"> | string
    message?: StringFilter<"Alert"> | string
    tenantId?: StringNullableFilter<"Alert"> | string | null
    userId?: StringNullableFilter<"Alert"> | string | null
    metadata?: JsonNullableFilter<"Alert">
    resolved?: BoolFilter<"Alert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    resolvedBy?: StringNullableFilter<"Alert"> | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
  }

  export type MessageTemplateUpsertWithWhereUniqueWithoutTenantInput = {
    where: MessageTemplateWhereUniqueInput
    update: XOR<MessageTemplateUpdateWithoutTenantInput, MessageTemplateUncheckedUpdateWithoutTenantInput>
    create: XOR<MessageTemplateCreateWithoutTenantInput, MessageTemplateUncheckedCreateWithoutTenantInput>
  }

  export type MessageTemplateUpdateWithWhereUniqueWithoutTenantInput = {
    where: MessageTemplateWhereUniqueInput
    data: XOR<MessageTemplateUpdateWithoutTenantInput, MessageTemplateUncheckedUpdateWithoutTenantInput>
  }

  export type MessageTemplateUpdateManyWithWhereWithoutTenantInput = {
    where: MessageTemplateScalarWhereInput
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyWithoutTenantInput>
  }

  export type MessageTemplateScalarWhereInput = {
    AND?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
    OR?: MessageTemplateScalarWhereInput[]
    NOT?: MessageTemplateScalarWhereInput | MessageTemplateScalarWhereInput[]
    id?: StringFilter<"MessageTemplate"> | string
    name?: StringFilter<"MessageTemplate"> | string
    tenantId?: StringFilter<"MessageTemplate"> | string
    category?: StringFilter<"MessageTemplate"> | string
    messageType?: EnumMessageTypeFilter<"MessageTemplate"> | $Enums.MessageType
    content?: StringFilter<"MessageTemplate"> | string
    variables?: StringNullableListFilter<"MessageTemplate">
    mediaUrl?: StringNullableFilter<"MessageTemplate"> | string | null
    active?: BoolFilter<"MessageTemplate"> | boolean
    tags?: StringNullableListFilter<"MessageTemplate">
    description?: StringNullableFilter<"MessageTemplate"> | string | null
    createdBy?: StringFilter<"MessageTemplate"> | string
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
  }

  export type AutomationFlowUpsertWithWhereUniqueWithoutTenantInput = {
    where: AutomationFlowWhereUniqueInput
    update: XOR<AutomationFlowUpdateWithoutTenantInput, AutomationFlowUncheckedUpdateWithoutTenantInput>
    create: XOR<AutomationFlowCreateWithoutTenantInput, AutomationFlowUncheckedCreateWithoutTenantInput>
  }

  export type AutomationFlowUpdateWithWhereUniqueWithoutTenantInput = {
    where: AutomationFlowWhereUniqueInput
    data: XOR<AutomationFlowUpdateWithoutTenantInput, AutomationFlowUncheckedUpdateWithoutTenantInput>
  }

  export type AutomationFlowUpdateManyWithWhereWithoutTenantInput = {
    where: AutomationFlowScalarWhereInput
    data: XOR<AutomationFlowUpdateManyMutationInput, AutomationFlowUncheckedUpdateManyWithoutTenantInput>
  }

  export type AutomationFlowScalarWhereInput = {
    AND?: AutomationFlowScalarWhereInput | AutomationFlowScalarWhereInput[]
    OR?: AutomationFlowScalarWhereInput[]
    NOT?: AutomationFlowScalarWhereInput | AutomationFlowScalarWhereInput[]
    id?: StringFilter<"AutomationFlow"> | string
    name?: StringFilter<"AutomationFlow"> | string
    description?: StringNullableFilter<"AutomationFlow"> | string | null
    tenantId?: StringFilter<"AutomationFlow"> | string
    active?: BoolFilter<"AutomationFlow"> | boolean
    trigger?: JsonFilter<"AutomationFlow">
    conditions?: JsonNullableFilter<"AutomationFlow">
    actions?: JsonFilter<"AutomationFlow">
    createdBy?: StringFilter<"AutomationFlow"> | string
    createdAt?: DateTimeFilter<"AutomationFlow"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationFlow"> | Date | string
  }

  export type IntegrationUpsertWithWhereUniqueWithoutTenantInput = {
    where: IntegrationWhereUniqueInput
    update: XOR<IntegrationUpdateWithoutTenantInput, IntegrationUncheckedUpdateWithoutTenantInput>
    create: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput>
  }

  export type IntegrationUpdateWithWhereUniqueWithoutTenantInput = {
    where: IntegrationWhereUniqueInput
    data: XOR<IntegrationUpdateWithoutTenantInput, IntegrationUncheckedUpdateWithoutTenantInput>
  }

  export type IntegrationUpdateManyWithWhereWithoutTenantInput = {
    where: IntegrationScalarWhereInput
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyWithoutTenantInput>
  }

  export type IntegrationScalarWhereInput = {
    AND?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    OR?: IntegrationScalarWhereInput[]
    NOT?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    id?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    type?: EnumIntegrationTypeFilter<"Integration"> | $Enums.IntegrationType
    tenantId?: StringFilter<"Integration"> | string
    active?: BoolFilter<"Integration"> | boolean
    config?: JsonFilter<"Integration">
    credentials?: JsonNullableFilter<"Integration">
    webhookUrl?: StringNullableFilter<"Integration"> | string | null
    lastSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    lastError?: StringNullableFilter<"Integration"> | string | null
    createdBy?: StringFilter<"Integration"> | string
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutTenantInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    severity?: StringFilter<"AuditLog"> | string
    tenantId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type TenantCreateWithoutQuotasInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutQuotasInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutQuotasInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutQuotasInput, TenantUncheckedCreateWithoutQuotasInput>
  }

  export type TenantUpsertWithoutQuotasInput = {
    update: XOR<TenantUpdateWithoutQuotasInput, TenantUncheckedUpdateWithoutQuotasInput>
    create: XOR<TenantCreateWithoutQuotasInput, TenantUncheckedCreateWithoutQuotasInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutQuotasInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutQuotasInput, TenantUncheckedUpdateWithoutQuotasInput>
  }

  export type TenantUpdateWithoutQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutSettingsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSettingsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSettingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSettingsInput, TenantUncheckedCreateWithoutSettingsInput>
  }

  export type TenantUpsertWithoutSettingsInput = {
    update: XOR<TenantUpdateWithoutSettingsInput, TenantUncheckedUpdateWithoutSettingsInput>
    create: XOR<TenantCreateWithoutSettingsInput, TenantUncheckedCreateWithoutSettingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSettingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSettingsInput, TenantUncheckedUpdateWithoutSettingsInput>
  }

  export type TenantUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserCreateWithoutTenantsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    tenantId?: string | null
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantsInput, UserUncheckedCreateWithoutTenantsInput>
  }

  export type TenantCreateWithoutUserTenantsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUserTenantsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUserTenantsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUserTenantsInput, TenantUncheckedCreateWithoutUserTenantsInput>
  }

  export type UserUpsertWithoutTenantsInput = {
    update: XOR<UserUpdateWithoutTenantsInput, UserUncheckedUpdateWithoutTenantsInput>
    create: XOR<UserCreateWithoutTenantsInput, UserUncheckedCreateWithoutTenantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTenantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTenantsInput, UserUncheckedUpdateWithoutTenantsInput>
  }

  export type UserUpdateWithoutTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantUpsertWithoutUserTenantsInput = {
    update: XOR<TenantUpdateWithoutUserTenantsInput, TenantUncheckedUpdateWithoutUserTenantsInput>
    create: XOR<TenantCreateWithoutUserTenantsInput, TenantUncheckedCreateWithoutUserTenantsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUserTenantsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUserTenantsInput, TenantUncheckedUpdateWithoutUserTenantsInput>
  }

  export type TenantUpdateWithoutUserTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUserTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CategoryCreateWithoutContactsInput = {
    id?: string
    nome: string
    cor: string
    descricao?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenant?: TenantCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutContactsInput = {
    id?: string
    nome: string
    cor: string
    descricao?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type CategoryCreateOrConnectWithoutContactsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutContactsInput, CategoryUncheckedCreateWithoutContactsInput>
  }

  export type TenantCreateWithoutContactsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutContactsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutContactsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutContactsInput, TenantUncheckedCreateWithoutContactsInput>
  }

  export type CategoryUpsertWithoutContactsInput = {
    update: XOR<CategoryUpdateWithoutContactsInput, CategoryUncheckedUpdateWithoutContactsInput>
    create: XOR<CategoryCreateWithoutContactsInput, CategoryUncheckedCreateWithoutContactsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutContactsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutContactsInput, CategoryUncheckedUpdateWithoutContactsInput>
  }

  export type CategoryUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUpsertWithoutContactsInput = {
    update: XOR<TenantUpdateWithoutContactsInput, TenantUncheckedUpdateWithoutContactsInput>
    create: XOR<TenantCreateWithoutContactsInput, TenantUncheckedCreateWithoutContactsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutContactsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutContactsInput, TenantUncheckedUpdateWithoutContactsInput>
  }

  export type TenantUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ContactCreateWithoutCategoriaInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    tags?: ContactCreatetagsInput | string[]
    observacoes?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenant?: TenantCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutCategoriaInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    tags?: ContactCreatetagsInput | string[]
    observacoes?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type ContactCreateOrConnectWithoutCategoriaInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCategoriaInput, ContactUncheckedCreateWithoutCategoriaInput>
  }

  export type ContactCreateManyCategoriaInputEnvelope = {
    data: ContactCreateManyCategoriaInput | ContactCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutCategoriesInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCategoriesInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCategoriesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCategoriesInput, TenantUncheckedCreateWithoutCategoriesInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutCategoriaInput, ContactUncheckedUpdateWithoutCategoriaInput>
    create: XOR<ContactCreateWithoutCategoriaInput, ContactUncheckedCreateWithoutCategoriaInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutCategoriaInput, ContactUncheckedUpdateWithoutCategoriaInput>
  }

  export type ContactUpdateManyWithWhereWithoutCategoriaInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type TenantUpsertWithoutCategoriesInput = {
    update: XOR<TenantUpdateWithoutCategoriesInput, TenantUncheckedUpdateWithoutCategoriesInput>
    create: XOR<TenantCreateWithoutCategoriesInput, TenantUncheckedCreateWithoutCategoriesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCategoriesInput, TenantUncheckedUpdateWithoutCategoriesInput>
  }

  export type TenantUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CampaignCreateWithoutSessionInput = {
    id?: string
    nome: string
    targetTags: string
    messageType: string
    messageContent: string
    randomDelay: number
    startImmediately: boolean
    scheduledFor?: Date | string | null
    status?: string
    totalContacts?: number
    sentCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    useTimeWindow?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionNames?: string | null
    createdBy?: string | null
    createdByName?: string | null
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    tenant?: TenantCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutSessionInput = {
    id?: string
    nome: string
    targetTags: string
    messageType: string
    messageContent: string
    randomDelay: number
    startImmediately: boolean
    scheduledFor?: Date | string | null
    status?: string
    totalContacts?: number
    sentCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    useTimeWindow?: boolean
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionNames?: string | null
    createdBy?: string | null
    createdByName?: string | null
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutSessionInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutSessionInput, CampaignUncheckedCreateWithoutSessionInput>
  }

  export type CampaignCreateManySessionInputEnvelope = {
    data: CampaignCreateManySessionInput | CampaignCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutWhatsappSessionsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWhatsappSessionsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWhatsappSessionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWhatsappSessionsInput, TenantUncheckedCreateWithoutWhatsappSessionsInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutSessionInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutSessionInput, CampaignUncheckedUpdateWithoutSessionInput>
    create: XOR<CampaignCreateWithoutSessionInput, CampaignUncheckedCreateWithoutSessionInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutSessionInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutSessionInput, CampaignUncheckedUpdateWithoutSessionInput>
  }

  export type CampaignUpdateManyWithWhereWithoutSessionInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutSessionInput>
  }

  export type TenantUpsertWithoutWhatsappSessionsInput = {
    update: XOR<TenantUpdateWithoutWhatsappSessionsInput, TenantUncheckedUpdateWithoutWhatsappSessionsInput>
    create: XOR<TenantCreateWithoutWhatsappSessionsInput, TenantUncheckedCreateWithoutWhatsappSessionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWhatsappSessionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWhatsappSessionsInput, TenantUncheckedUpdateWithoutWhatsappSessionsInput>
  }

  export type TenantUpdateWithoutWhatsappSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWhatsappSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CampaignMessageCreateWithoutCampaignInput = {
    id?: string
    contactId: string
    contactPhone: string
    contactName: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    errorMessage?: string | null
    messageId?: string | null
    selectedVariation?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionName?: string | null
    tenant?: TenantCreateNestedOneWithoutCampaignMessagesInput
  }

  export type CampaignMessageUncheckedCreateWithoutCampaignInput = {
    id?: string
    contactId: string
    contactPhone: string
    contactName: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    errorMessage?: string | null
    messageId?: string | null
    selectedVariation?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionName?: string | null
  }

  export type CampaignMessageCreateOrConnectWithoutCampaignInput = {
    where: CampaignMessageWhereUniqueInput
    create: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignMessageCreateManyCampaignInputEnvelope = {
    data: CampaignMessageCreateManyCampaignInput | CampaignMessageCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppSessionCreateWithoutCampaignsInput = {
    id?: string
    name: string
    displayName?: string | null
    status: string
    config?: string | null
    meId?: string | null
    mePushName?: string | null
    meLid?: string | null
    meJid?: string | null
    qr?: string | null
    qrExpiresAt?: Date | string | null
    assignedWorker?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    provider?: string
    quepasaToken?: string | null
    tenant?: TenantCreateNestedOneWithoutWhatsappSessionsInput
  }

  export type WhatsAppSessionUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    displayName?: string | null
    status: string
    config?: string | null
    meId?: string | null
    mePushName?: string | null
    meLid?: string | null
    meJid?: string | null
    qr?: string | null
    qrExpiresAt?: Date | string | null
    assignedWorker?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    provider?: string
    quepasaToken?: string | null
  }

  export type WhatsAppSessionCreateOrConnectWithoutCampaignsInput = {
    where: WhatsAppSessionWhereUniqueInput
    create: XOR<WhatsAppSessionCreateWithoutCampaignsInput, WhatsAppSessionUncheckedCreateWithoutCampaignsInput>
  }

  export type TenantCreateWithoutCampaignsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCampaignsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCampaignsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCampaignsInput, TenantUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignMessageWhereUniqueInput
    update: XOR<CampaignMessageUpdateWithoutCampaignInput, CampaignMessageUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignMessageWhereUniqueInput
    data: XOR<CampaignMessageUpdateWithoutCampaignInput, CampaignMessageUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignMessageUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignMessageScalarWhereInput
    data: XOR<CampaignMessageUpdateManyMutationInput, CampaignMessageUncheckedUpdateManyWithoutCampaignInput>
  }

  export type WhatsAppSessionUpsertWithoutCampaignsInput = {
    update: XOR<WhatsAppSessionUpdateWithoutCampaignsInput, WhatsAppSessionUncheckedUpdateWithoutCampaignsInput>
    create: XOR<WhatsAppSessionCreateWithoutCampaignsInput, WhatsAppSessionUncheckedCreateWithoutCampaignsInput>
    where?: WhatsAppSessionWhereInput
  }

  export type WhatsAppSessionUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: WhatsAppSessionWhereInput
    data: XOR<WhatsAppSessionUpdateWithoutCampaignsInput, WhatsAppSessionUncheckedUpdateWithoutCampaignsInput>
  }

  export type WhatsAppSessionUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: NullableStringFieldUpdateOperationsInput | string | null
    meId?: NullableStringFieldUpdateOperationsInput | string | null
    mePushName?: NullableStringFieldUpdateOperationsInput | string | null
    meLid?: NullableStringFieldUpdateOperationsInput | string | null
    meJid?: NullableStringFieldUpdateOperationsInput | string | null
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedWorker?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    quepasaToken?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneWithoutWhatsappSessionsNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: NullableStringFieldUpdateOperationsInput | string | null
    meId?: NullableStringFieldUpdateOperationsInput | string | null
    mePushName?: NullableStringFieldUpdateOperationsInput | string | null
    meLid?: NullableStringFieldUpdateOperationsInput | string | null
    meJid?: NullableStringFieldUpdateOperationsInput | string | null
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedWorker?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    quepasaToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantUpsertWithoutCampaignsInput = {
    update: XOR<TenantUpdateWithoutCampaignsInput, TenantUncheckedUpdateWithoutCampaignsInput>
    create: XOR<TenantCreateWithoutCampaignsInput, TenantUncheckedCreateWithoutCampaignsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCampaignsInput, TenantUncheckedUpdateWithoutCampaignsInput>
  }

  export type TenantUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CampaignCreateWithoutMessagesInput = {
    id?: string
    nome: string
    targetTags: string
    messageType: string
    messageContent: string
    randomDelay: number
    startImmediately: boolean
    scheduledFor?: Date | string | null
    status?: string
    totalContacts?: number
    sentCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    useTimeWindow?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionNames?: string | null
    createdBy?: string | null
    createdByName?: string | null
    session?: WhatsAppSessionCreateNestedOneWithoutCampaignsInput
    tenant?: TenantCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutMessagesInput = {
    id?: string
    nome: string
    targetTags: string
    sessionName?: string | null
    messageType: string
    messageContent: string
    randomDelay: number
    startImmediately: boolean
    scheduledFor?: Date | string | null
    status?: string
    totalContacts?: number
    sentCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    useTimeWindow?: boolean
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionNames?: string | null
    createdBy?: string | null
    createdByName?: string | null
  }

  export type CampaignCreateOrConnectWithoutMessagesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
  }

  export type TenantCreateWithoutCampaignMessagesInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCampaignMessagesInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCampaignMessagesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCampaignMessagesInput, TenantUncheckedCreateWithoutCampaignMessagesInput>
  }

  export type CampaignUpsertWithoutMessagesInput = {
    update: XOR<CampaignUpdateWithoutMessagesInput, CampaignUncheckedUpdateWithoutMessagesInput>
    create: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMessagesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMessagesInput, CampaignUncheckedUpdateWithoutMessagesInput>
  }

  export type CampaignUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    targetTags?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    randomDelay?: IntFieldUpdateOperationsInput | number
    startImmediately?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalContacts?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    useTimeWindow?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionNames?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    session?: WhatsAppSessionUpdateOneWithoutCampaignsNestedInput
    tenant?: TenantUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    targetTags?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    randomDelay?: IntFieldUpdateOperationsInput | number
    startImmediately?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalContacts?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    useTimeWindow?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionNames?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantUpsertWithoutCampaignMessagesInput = {
    update: XOR<TenantUpdateWithoutCampaignMessagesInput, TenantUncheckedUpdateWithoutCampaignMessagesInput>
    create: XOR<TenantCreateWithoutCampaignMessagesInput, TenantUncheckedCreateWithoutCampaignMessagesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCampaignMessagesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCampaignMessagesInput, TenantUncheckedUpdateWithoutCampaignMessagesInput>
  }

  export type TenantUpdateWithoutCampaignMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCampaignMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type UserTenantCreateWithoutUserInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUserTenantsInput
  }

  export type UserTenantUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTenantCreateOrConnectWithoutUserInput = {
    where: UserTenantWhereUniqueInput
    create: XOR<UserTenantCreateWithoutUserInput, UserTenantUncheckedCreateWithoutUserInput>
  }

  export type UserTenantCreateManyUserInputEnvelope = {
    data: UserTenantCreateManyUserInput | UserTenantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutUserInput = {
    id?: string
    type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    title: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutAlertsInput
    notifications?: NotificationCreateNestedManyWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    title: string
    message: string
    tenantId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutAlertInput
  }

  export type AlertCreateOrConnectWithoutUserInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertCreateManyUserInputEnvelope = {
    data: AlertCreateManyUserInput | AlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    method: $Enums.NotificationMethod
    sent?: boolean
    sentAt?: Date | string | null
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alert: AlertCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    alertId: string
    method: $Enums.NotificationMethod
    sent?: boolean
    sentAt?: Date | string | null
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserNotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationCreateOrConnectWithoutUserInput = {
    where: UserNotificationWhereUniqueInput
    create: XOR<UserNotificationCreateWithoutUserInput, UserNotificationUncheckedCreateWithoutUserInput>
  }

  export type UserNotificationCreateManyUserInputEnvelope = {
    data: UserNotificationCreateManyUserInput | UserNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageTemplateCreateWithoutCreatorInput = {
    id?: string
    name: string
    category: string
    messageType: $Enums.MessageType
    content: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    active?: boolean
    tags?: MessageTemplateCreatetagsInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMessageTemplatesInput
  }

  export type MessageTemplateUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    tenantId: string
    category: string
    messageType: $Enums.MessageType
    content: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    active?: boolean
    tags?: MessageTemplateCreatetagsInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateCreateOrConnectWithoutCreatorInput = {
    where: MessageTemplateWhereUniqueInput
    create: XOR<MessageTemplateCreateWithoutCreatorInput, MessageTemplateUncheckedCreateWithoutCreatorInput>
  }

  export type MessageTemplateCreateManyCreatorInputEnvelope = {
    data: MessageTemplateCreateManyCreatorInput | MessageTemplateCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AutomationFlowCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean
    trigger: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAutomationFlowsInput
    executions?: AutomationExecutionCreateNestedManyWithoutFlowInput
  }

  export type AutomationFlowUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    active?: boolean
    trigger: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: AutomationExecutionUncheckedCreateNestedManyWithoutFlowInput
  }

  export type AutomationFlowCreateOrConnectWithoutCreatorInput = {
    where: AutomationFlowWhereUniqueInput
    create: XOR<AutomationFlowCreateWithoutCreatorInput, AutomationFlowUncheckedCreateWithoutCreatorInput>
  }

  export type AutomationFlowCreateManyCreatorInputEnvelope = {
    data: AutomationFlowCreateManyCreatorInput | AutomationFlowCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type IntegrationCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    active?: boolean
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    lastSyncAt?: Date | string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutIntegrationsInput
    syncLogs?: IntegrationSyncCreateNestedManyWithoutIntegrationInput
  }

  export type IntegrationUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    tenantId: string
    active?: boolean
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    lastSyncAt?: Date | string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncLogs?: IntegrationSyncUncheckedCreateNestedManyWithoutIntegrationInput
  }

  export type IntegrationCreateOrConnectWithoutCreatorInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutCreatorInput, IntegrationUncheckedCreateWithoutCreatorInput>
  }

  export type IntegrationCreateManyCreatorInputEnvelope = {
    data: IntegrationCreateManyCreatorInput | IntegrationCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    severity: string
    entityType?: string | null
    entityId?: string | null
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    severity: string
    tenantId: string
    entityType?: string | null
    entityId?: string | null
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserTenantUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTenantWhereUniqueInput
    update: XOR<UserTenantUpdateWithoutUserInput, UserTenantUncheckedUpdateWithoutUserInput>
    create: XOR<UserTenantCreateWithoutUserInput, UserTenantUncheckedCreateWithoutUserInput>
  }

  export type UserTenantUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTenantWhereUniqueInput
    data: XOR<UserTenantUpdateWithoutUserInput, UserTenantUncheckedUpdateWithoutUserInput>
  }

  export type UserTenantUpdateManyWithWhereWithoutUserInput = {
    where: UserTenantScalarWhereInput
    data: XOR<UserTenantUpdateManyMutationInput, UserTenantUncheckedUpdateManyWithoutUserInput>
  }

  export type AlertUpsertWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
  }

  export type AlertUpdateManyWithWhereWithoutUserInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    alertId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    method?: EnumNotificationMethodFilter<"Notification"> | $Enums.NotificationMethod
    sent?: BoolFilter<"Notification"> | boolean
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserNotificationWhereUniqueInput
    update: XOR<UserNotificationUpdateWithoutUserInput, UserNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<UserNotificationCreateWithoutUserInput, UserNotificationUncheckedCreateWithoutUserInput>
  }

  export type UserNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserNotificationWhereUniqueInput
    data: XOR<UserNotificationUpdateWithoutUserInput, UserNotificationUncheckedUpdateWithoutUserInput>
  }

  export type UserNotificationUpdateManyWithWhereWithoutUserInput = {
    where: UserNotificationScalarWhereInput
    data: XOR<UserNotificationUpdateManyMutationInput, UserNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserNotificationScalarWhereInput = {
    AND?: UserNotificationScalarWhereInput | UserNotificationScalarWhereInput[]
    OR?: UserNotificationScalarWhereInput[]
    NOT?: UserNotificationScalarWhereInput | UserNotificationScalarWhereInput[]
    id?: StringFilter<"UserNotification"> | string
    userId?: StringFilter<"UserNotification"> | string
    title?: StringFilter<"UserNotification"> | string
    message?: StringFilter<"UserNotification"> | string
    type?: EnumUserNotificationTypeFilter<"UserNotification"> | $Enums.UserNotificationType
    data?: JsonNullableFilter<"UserNotification">
    read?: BoolFilter<"UserNotification"> | boolean
    readAt?: DateTimeNullableFilter<"UserNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"UserNotification"> | Date | string
    updatedAt?: DateTimeFilter<"UserNotification"> | Date | string
  }

  export type MessageTemplateUpsertWithWhereUniqueWithoutCreatorInput = {
    where: MessageTemplateWhereUniqueInput
    update: XOR<MessageTemplateUpdateWithoutCreatorInput, MessageTemplateUncheckedUpdateWithoutCreatorInput>
    create: XOR<MessageTemplateCreateWithoutCreatorInput, MessageTemplateUncheckedCreateWithoutCreatorInput>
  }

  export type MessageTemplateUpdateWithWhereUniqueWithoutCreatorInput = {
    where: MessageTemplateWhereUniqueInput
    data: XOR<MessageTemplateUpdateWithoutCreatorInput, MessageTemplateUncheckedUpdateWithoutCreatorInput>
  }

  export type MessageTemplateUpdateManyWithWhereWithoutCreatorInput = {
    where: MessageTemplateScalarWhereInput
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AutomationFlowUpsertWithWhereUniqueWithoutCreatorInput = {
    where: AutomationFlowWhereUniqueInput
    update: XOR<AutomationFlowUpdateWithoutCreatorInput, AutomationFlowUncheckedUpdateWithoutCreatorInput>
    create: XOR<AutomationFlowCreateWithoutCreatorInput, AutomationFlowUncheckedCreateWithoutCreatorInput>
  }

  export type AutomationFlowUpdateWithWhereUniqueWithoutCreatorInput = {
    where: AutomationFlowWhereUniqueInput
    data: XOR<AutomationFlowUpdateWithoutCreatorInput, AutomationFlowUncheckedUpdateWithoutCreatorInput>
  }

  export type AutomationFlowUpdateManyWithWhereWithoutCreatorInput = {
    where: AutomationFlowScalarWhereInput
    data: XOR<AutomationFlowUpdateManyMutationInput, AutomationFlowUncheckedUpdateManyWithoutCreatorInput>
  }

  export type IntegrationUpsertWithWhereUniqueWithoutCreatorInput = {
    where: IntegrationWhereUniqueInput
    update: XOR<IntegrationUpdateWithoutCreatorInput, IntegrationUncheckedUpdateWithoutCreatorInput>
    create: XOR<IntegrationCreateWithoutCreatorInput, IntegrationUncheckedCreateWithoutCreatorInput>
  }

  export type IntegrationUpdateWithWhereUniqueWithoutCreatorInput = {
    where: IntegrationWhereUniqueInput
    data: XOR<IntegrationUpdateWithoutCreatorInput, IntegrationUncheckedUpdateWithoutCreatorInput>
  }

  export type IntegrationUpdateManyWithWhereWithoutCreatorInput = {
    where: IntegrationScalarWhereInput
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type TenantCreateWithoutAlertsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAlertsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAlertsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAlertsInput, TenantUncheckedCreateWithoutAlertsInput>
  }

  export type UserCreateWithoutAlertsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    tenants?: UserTenantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAlertsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    tenantId?: string | null
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenants?: UserTenantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
  }

  export type NotificationCreateWithoutAlertInput = {
    id?: string
    method: $Enums.NotificationMethod
    sent?: boolean
    sentAt?: Date | string | null
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutAlertInput = {
    id?: string
    userId: string
    method: $Enums.NotificationMethod
    sent?: boolean
    sentAt?: Date | string | null
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutAlertInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutAlertInput, NotificationUncheckedCreateWithoutAlertInput>
  }

  export type NotificationCreateManyAlertInputEnvelope = {
    data: NotificationCreateManyAlertInput | NotificationCreateManyAlertInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutAlertsInput = {
    update: XOR<TenantUpdateWithoutAlertsInput, TenantUncheckedUpdateWithoutAlertsInput>
    create: XOR<TenantCreateWithoutAlertsInput, TenantUncheckedCreateWithoutAlertsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAlertsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAlertsInput, TenantUncheckedUpdateWithoutAlertsInput>
  }

  export type TenantUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAlertsInput = {
    update: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type UserUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    tenants?: UserTenantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: UserTenantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutAlertInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutAlertInput, NotificationUncheckedUpdateWithoutAlertInput>
    create: XOR<NotificationCreateWithoutAlertInput, NotificationUncheckedCreateWithoutAlertInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutAlertInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutAlertInput, NotificationUncheckedUpdateWithoutAlertInput>
  }

  export type NotificationUpdateManyWithWhereWithoutAlertInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutAlertInput>
  }

  export type AlertCreateWithoutNotificationsInput = {
    id?: string
    type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    title: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutAlertsInput
    user?: UserCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutNotificationsInput = {
    id?: string
    type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    title: string
    message: string
    tenantId?: string | null
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertCreateOrConnectWithoutNotificationsInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutNotificationsInput, AlertUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    tenants?: UserTenantCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    tenantId?: string | null
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenants?: UserTenantUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type AlertUpsertWithoutNotificationsInput = {
    update: XOR<AlertUpdateWithoutNotificationsInput, AlertUncheckedUpdateWithoutNotificationsInput>
    create: XOR<AlertCreateWithoutNotificationsInput, AlertUncheckedCreateWithoutNotificationsInput>
    where?: AlertWhereInput
  }

  export type AlertUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: AlertWhereInput
    data: XOR<AlertUpdateWithoutNotificationsInput, AlertUncheckedUpdateWithoutNotificationsInput>
  }

  export type AlertUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutAlertsNestedInput
    user?: UserUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    tenants?: UserTenantUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: UserTenantUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserNotificationsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    tenants?: UserTenantCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserNotificationsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    tenantId?: string | null
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenants?: UserTenantUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserNotificationsInput, UserUncheckedCreateWithoutUserNotificationsInput>
  }

  export type UserUpsertWithoutUserNotificationsInput = {
    update: XOR<UserUpdateWithoutUserNotificationsInput, UserUncheckedUpdateWithoutUserNotificationsInput>
    create: XOR<UserCreateWithoutUserNotificationsInput, UserUncheckedCreateWithoutUserNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserNotificationsInput, UserUncheckedUpdateWithoutUserNotificationsInput>
  }

  export type UserUpdateWithoutUserNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    tenants?: UserTenantUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: UserTenantUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutMessageTemplatesInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutMessageTemplatesInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutMessageTemplatesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutMessageTemplatesInput, TenantUncheckedCreateWithoutMessageTemplatesInput>
  }

  export type UserCreateWithoutCreatedTemplatesInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    tenants?: UserTenantCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationCreateNestedManyWithoutUserInput
    createdFlows?: AutomationFlowCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedTemplatesInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    tenantId?: string | null
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenants?: UserTenantUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    createdFlows?: AutomationFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
  }

  export type TenantUpsertWithoutMessageTemplatesInput = {
    update: XOR<TenantUpdateWithoutMessageTemplatesInput, TenantUncheckedUpdateWithoutMessageTemplatesInput>
    create: XOR<TenantCreateWithoutMessageTemplatesInput, TenantUncheckedCreateWithoutMessageTemplatesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutMessageTemplatesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutMessageTemplatesInput, TenantUncheckedUpdateWithoutMessageTemplatesInput>
  }

  export type TenantUpdateWithoutMessageTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutMessageTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutCreatedTemplatesInput = {
    update: XOR<UserUpdateWithoutCreatedTemplatesInput, UserUncheckedUpdateWithoutCreatedTemplatesInput>
    create: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTemplatesInput, UserUncheckedUpdateWithoutCreatedTemplatesInput>
  }

  export type UserUpdateWithoutCreatedTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    tenants?: UserTenantUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUpdateManyWithoutUserNestedInput
    createdFlows?: AutomationFlowUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: UserTenantUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFlows?: AutomationFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutAutomationFlowsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAutomationFlowsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAutomationFlowsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAutomationFlowsInput, TenantUncheckedCreateWithoutAutomationFlowsInput>
  }

  export type UserCreateWithoutCreatedFlowsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    tenants?: UserTenantCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedFlowsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    tenantId?: string | null
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenants?: UserTenantUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedFlowsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedFlowsInput, UserUncheckedCreateWithoutCreatedFlowsInput>
  }

  export type AutomationExecutionCreateWithoutFlowInput = {
    id?: string
    status: string
    executedAt: Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    duration?: number | null
  }

  export type AutomationExecutionUncheckedCreateWithoutFlowInput = {
    id?: string
    status: string
    executedAt: Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    duration?: number | null
  }

  export type AutomationExecutionCreateOrConnectWithoutFlowInput = {
    where: AutomationExecutionWhereUniqueInput
    create: XOR<AutomationExecutionCreateWithoutFlowInput, AutomationExecutionUncheckedCreateWithoutFlowInput>
  }

  export type AutomationExecutionCreateManyFlowInputEnvelope = {
    data: AutomationExecutionCreateManyFlowInput | AutomationExecutionCreateManyFlowInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutAutomationFlowsInput = {
    update: XOR<TenantUpdateWithoutAutomationFlowsInput, TenantUncheckedUpdateWithoutAutomationFlowsInput>
    create: XOR<TenantCreateWithoutAutomationFlowsInput, TenantUncheckedCreateWithoutAutomationFlowsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAutomationFlowsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAutomationFlowsInput, TenantUncheckedUpdateWithoutAutomationFlowsInput>
  }

  export type TenantUpdateWithoutAutomationFlowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAutomationFlowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutCreatedFlowsInput = {
    update: XOR<UserUpdateWithoutCreatedFlowsInput, UserUncheckedUpdateWithoutCreatedFlowsInput>
    create: XOR<UserCreateWithoutCreatedFlowsInput, UserUncheckedCreateWithoutCreatedFlowsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedFlowsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedFlowsInput, UserUncheckedUpdateWithoutCreatedFlowsInput>
  }

  export type UserUpdateWithoutCreatedFlowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    tenants?: UserTenantUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedFlowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: UserTenantUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AutomationExecutionUpsertWithWhereUniqueWithoutFlowInput = {
    where: AutomationExecutionWhereUniqueInput
    update: XOR<AutomationExecutionUpdateWithoutFlowInput, AutomationExecutionUncheckedUpdateWithoutFlowInput>
    create: XOR<AutomationExecutionCreateWithoutFlowInput, AutomationExecutionUncheckedCreateWithoutFlowInput>
  }

  export type AutomationExecutionUpdateWithWhereUniqueWithoutFlowInput = {
    where: AutomationExecutionWhereUniqueInput
    data: XOR<AutomationExecutionUpdateWithoutFlowInput, AutomationExecutionUncheckedUpdateWithoutFlowInput>
  }

  export type AutomationExecutionUpdateManyWithWhereWithoutFlowInput = {
    where: AutomationExecutionScalarWhereInput
    data: XOR<AutomationExecutionUpdateManyMutationInput, AutomationExecutionUncheckedUpdateManyWithoutFlowInput>
  }

  export type AutomationExecutionScalarWhereInput = {
    AND?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
    OR?: AutomationExecutionScalarWhereInput[]
    NOT?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
    id?: StringFilter<"AutomationExecution"> | string
    flowId?: StringFilter<"AutomationExecution"> | string
    status?: StringFilter<"AutomationExecution"> | string
    executedAt?: DateTimeFilter<"AutomationExecution"> | Date | string
    context?: JsonNullableFilter<"AutomationExecution">
    error?: StringNullableFilter<"AutomationExecution"> | string | null
    duration?: IntNullableFilter<"AutomationExecution"> | number | null
  }

  export type AutomationFlowCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean
    trigger: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAutomationFlowsInput
    creator: UserCreateNestedOneWithoutCreatedFlowsInput
  }

  export type AutomationFlowUncheckedCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    active?: boolean
    trigger: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationFlowCreateOrConnectWithoutExecutionsInput = {
    where: AutomationFlowWhereUniqueInput
    create: XOR<AutomationFlowCreateWithoutExecutionsInput, AutomationFlowUncheckedCreateWithoutExecutionsInput>
  }

  export type AutomationFlowUpsertWithoutExecutionsInput = {
    update: XOR<AutomationFlowUpdateWithoutExecutionsInput, AutomationFlowUncheckedUpdateWithoutExecutionsInput>
    create: XOR<AutomationFlowCreateWithoutExecutionsInput, AutomationFlowUncheckedCreateWithoutExecutionsInput>
    where?: AutomationFlowWhereInput
  }

  export type AutomationFlowUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: AutomationFlowWhereInput
    data: XOR<AutomationFlowUpdateWithoutExecutionsInput, AutomationFlowUncheckedUpdateWithoutExecutionsInput>
  }

  export type AutomationFlowUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    trigger?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAutomationFlowsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedFlowsNestedInput
  }

  export type AutomationFlowUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    trigger?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutIntegrationsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutIntegrationsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutIntegrationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutIntegrationsInput, TenantUncheckedCreateWithoutIntegrationsInput>
  }

  export type UserCreateWithoutCreatedIntegrationsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    tenants?: UserTenantCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedIntegrationsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    tenantId?: string | null
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenants?: UserTenantUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedIntegrationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedIntegrationsInput, UserUncheckedCreateWithoutCreatedIntegrationsInput>
  }

  export type IntegrationSyncCreateWithoutIntegrationInput = {
    id?: string
    type: string
    status: string
    recordsCount?: number | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt: Date | string
    completedAt?: Date | string | null
  }

  export type IntegrationSyncUncheckedCreateWithoutIntegrationInput = {
    id?: string
    type: string
    status: string
    recordsCount?: number | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt: Date | string
    completedAt?: Date | string | null
  }

  export type IntegrationSyncCreateOrConnectWithoutIntegrationInput = {
    where: IntegrationSyncWhereUniqueInput
    create: XOR<IntegrationSyncCreateWithoutIntegrationInput, IntegrationSyncUncheckedCreateWithoutIntegrationInput>
  }

  export type IntegrationSyncCreateManyIntegrationInputEnvelope = {
    data: IntegrationSyncCreateManyIntegrationInput | IntegrationSyncCreateManyIntegrationInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutIntegrationsInput = {
    update: XOR<TenantUpdateWithoutIntegrationsInput, TenantUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<TenantCreateWithoutIntegrationsInput, TenantUncheckedCreateWithoutIntegrationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutIntegrationsInput, TenantUncheckedUpdateWithoutIntegrationsInput>
  }

  export type TenantUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutCreatedIntegrationsInput = {
    update: XOR<UserUpdateWithoutCreatedIntegrationsInput, UserUncheckedUpdateWithoutCreatedIntegrationsInput>
    create: XOR<UserCreateWithoutCreatedIntegrationsInput, UserUncheckedCreateWithoutCreatedIntegrationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedIntegrationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedIntegrationsInput, UserUncheckedUpdateWithoutCreatedIntegrationsInput>
  }

  export type UserUpdateWithoutCreatedIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    tenants?: UserTenantUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: UserTenantUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IntegrationSyncUpsertWithWhereUniqueWithoutIntegrationInput = {
    where: IntegrationSyncWhereUniqueInput
    update: XOR<IntegrationSyncUpdateWithoutIntegrationInput, IntegrationSyncUncheckedUpdateWithoutIntegrationInput>
    create: XOR<IntegrationSyncCreateWithoutIntegrationInput, IntegrationSyncUncheckedCreateWithoutIntegrationInput>
  }

  export type IntegrationSyncUpdateWithWhereUniqueWithoutIntegrationInput = {
    where: IntegrationSyncWhereUniqueInput
    data: XOR<IntegrationSyncUpdateWithoutIntegrationInput, IntegrationSyncUncheckedUpdateWithoutIntegrationInput>
  }

  export type IntegrationSyncUpdateManyWithWhereWithoutIntegrationInput = {
    where: IntegrationSyncScalarWhereInput
    data: XOR<IntegrationSyncUpdateManyMutationInput, IntegrationSyncUncheckedUpdateManyWithoutIntegrationInput>
  }

  export type IntegrationSyncScalarWhereInput = {
    AND?: IntegrationSyncScalarWhereInput | IntegrationSyncScalarWhereInput[]
    OR?: IntegrationSyncScalarWhereInput[]
    NOT?: IntegrationSyncScalarWhereInput | IntegrationSyncScalarWhereInput[]
    id?: StringFilter<"IntegrationSync"> | string
    integrationId?: StringFilter<"IntegrationSync"> | string
    type?: StringFilter<"IntegrationSync"> | string
    status?: StringFilter<"IntegrationSync"> | string
    recordsCount?: IntNullableFilter<"IntegrationSync"> | number | null
    errorMessage?: StringNullableFilter<"IntegrationSync"> | string | null
    metadata?: JsonNullableFilter<"IntegrationSync">
    startedAt?: DateTimeFilter<"IntegrationSync"> | Date | string
    completedAt?: DateTimeNullableFilter<"IntegrationSync"> | Date | string | null
  }

  export type IntegrationCreateWithoutSyncLogsInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    active?: boolean
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    lastSyncAt?: Date | string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutIntegrationsInput
    creator: UserCreateNestedOneWithoutCreatedIntegrationsInput
  }

  export type IntegrationUncheckedCreateWithoutSyncLogsInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    tenantId: string
    active?: boolean
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    lastSyncAt?: Date | string | null
    lastError?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateOrConnectWithoutSyncLogsInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutSyncLogsInput, IntegrationUncheckedCreateWithoutSyncLogsInput>
  }

  export type IntegrationUpsertWithoutSyncLogsInput = {
    update: XOR<IntegrationUpdateWithoutSyncLogsInput, IntegrationUncheckedUpdateWithoutSyncLogsInput>
    create: XOR<IntegrationCreateWithoutSyncLogsInput, IntegrationUncheckedCreateWithoutSyncLogsInput>
    where?: IntegrationWhereInput
  }

  export type IntegrationUpdateToOneWithWhereWithoutSyncLogsInput = {
    where?: IntegrationWhereInput
    data: XOR<IntegrationUpdateWithoutSyncLogsInput, IntegrationUncheckedUpdateWithoutSyncLogsInput>
  }

  export type IntegrationUpdateWithoutSyncLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    active?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutIntegrationsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedIntegrationsNestedInput
  }

  export type IntegrationUncheckedUpdateWithoutSyncLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    tenantId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    tenants?: UserTenantCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    tenantId?: string | null
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tenants?: UserTenantUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    createdTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdFlows?: AutomationFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type TenantCreateWithoutAuditLogsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    campaigns?: CampaignCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    slug: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    userTenants?: UserTenantUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTenantInput
    campaignMessages?: CampaignMessageUncheckedCreateNestedManyWithoutTenantInput
    whatsappSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutTenantInput
    quotas?: TenantQuotaUncheckedCreateNestedOneWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    messageTemplates?: MessageTemplateUncheckedCreateNestedManyWithoutTenantInput
    automationFlows?: AutomationFlowUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    tenants?: UserTenantUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: UserTenantUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TenantUpsertWithoutAuditLogsInput = {
    update: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    userTenants?: UserTenantUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTenantNestedInput
    campaignMessages?: CampaignMessageUncheckedUpdateManyWithoutTenantNestedInput
    whatsappSessions?: WhatsAppSessionUncheckedUpdateManyWithoutTenantNestedInput
    quotas?: TenantQuotaUncheckedUpdateOneWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    messageTemplates?: MessageTemplateUncheckedUpdateManyWithoutTenantNestedInput
    automationFlows?: AutomationFlowUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    nome: string
    email: string
    senha: string
    role?: string
    ativo?: boolean
    ultimoLogin?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type UserTenantCreateManyTenantInput = {
    id?: string
    userId: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyTenantInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    tags?: ContactCreatetagsInput | string[]
    observacoes?: string | null
    categoriaId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type CategoryCreateManyTenantInput = {
    id?: string
    nome: string
    cor: string
    descricao?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type CampaignCreateManyTenantInput = {
    id?: string
    nome: string
    targetTags: string
    sessionName?: string | null
    messageType: string
    messageContent: string
    randomDelay: number
    startImmediately: boolean
    scheduledFor?: Date | string | null
    status?: string
    totalContacts?: number
    sentCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    useTimeWindow?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionNames?: string | null
    createdBy?: string | null
    createdByName?: string | null
  }

  export type CampaignMessageCreateManyTenantInput = {
    id?: string
    campaignId: string
    contactId: string
    contactPhone: string
    contactName: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    errorMessage?: string | null
    messageId?: string | null
    selectedVariation?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionName?: string | null
  }

  export type WhatsAppSessionCreateManyTenantInput = {
    id?: string
    name: string
    displayName?: string | null
    status: string
    config?: string | null
    meId?: string | null
    mePushName?: string | null
    meLid?: string | null
    meJid?: string | null
    qr?: string | null
    qrExpiresAt?: Date | string | null
    assignedWorker?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    provider?: string
    quepasaToken?: string | null
  }

  export type AlertCreateManyTenantInput = {
    id?: string
    type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    title: string
    message: string
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateCreateManyTenantInput = {
    id?: string
    name: string
    category: string
    messageType: $Enums.MessageType
    content: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    active?: boolean
    tags?: MessageTemplateCreatetagsInput | string[]
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationFlowCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean
    trigger: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateManyTenantInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    active?: boolean
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    lastSyncAt?: Date | string | null
    lastError?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyTenantInput = {
    id?: string
    action: string
    severity: string
    userId?: string | null
    entityType?: string | null
    entityId?: string | null
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: UserTenantUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: UserTenantUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    createdTemplates?: MessageTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdFlows?: AutomationFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTenantUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTenantsNestedInput
  }

  export type UserTenantUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTenantUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    categoria?: CategoryUpdateOneWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    categoriaId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    categoriaId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    targetTags?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    randomDelay?: IntFieldUpdateOperationsInput | number
    startImmediately?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalContacts?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    useTimeWindow?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionNames?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    session?: WhatsAppSessionUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    targetTags?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    randomDelay?: IntFieldUpdateOperationsInput | number
    startImmediately?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalContacts?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    useTimeWindow?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionNames?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    targetTags?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    randomDelay?: IntFieldUpdateOperationsInput | number
    startImmediately?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalContacts?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    useTimeWindow?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionNames?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignMessageUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedVariation?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: CampaignUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type CampaignMessageUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedVariation?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignMessageUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedVariation?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsAppSessionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: NullableStringFieldUpdateOperationsInput | string | null
    meId?: NullableStringFieldUpdateOperationsInput | string | null
    mePushName?: NullableStringFieldUpdateOperationsInput | string | null
    meLid?: NullableStringFieldUpdateOperationsInput | string | null
    meJid?: NullableStringFieldUpdateOperationsInput | string | null
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedWorker?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    quepasaToken?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: NullableStringFieldUpdateOperationsInput | string | null
    meId?: NullableStringFieldUpdateOperationsInput | string | null
    mePushName?: NullableStringFieldUpdateOperationsInput | string | null
    meLid?: NullableStringFieldUpdateOperationsInput | string | null
    meJid?: NullableStringFieldUpdateOperationsInput | string | null
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedWorker?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    quepasaToken?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: NullableStringFieldUpdateOperationsInput | string | null
    meId?: NullableStringFieldUpdateOperationsInput | string | null
    mePushName?: NullableStringFieldUpdateOperationsInput | string | null
    meLid?: NullableStringFieldUpdateOperationsInput | string | null
    meJid?: NullableStringFieldUpdateOperationsInput | string | null
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    qrExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedWorker?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
    quepasaToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAlertsNestedInput
    notifications?: NotificationUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    tags?: MessageTemplateUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedTemplatesNestedInput
  }

  export type MessageTemplateUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    tags?: MessageTemplateUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    tags?: MessageTemplateUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationFlowUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    trigger?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedFlowsNestedInput
    executions?: AutomationExecutionUpdateManyWithoutFlowNestedInput
  }

  export type AutomationFlowUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    trigger?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: AutomationExecutionUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type AutomationFlowUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    trigger?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    active?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedIntegrationsNestedInput
    syncLogs?: IntegrationSyncUpdateManyWithoutIntegrationNestedInput
  }

  export type IntegrationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    active?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncLogs?: IntegrationSyncUncheckedUpdateManyWithoutIntegrationNestedInput
  }

  export type IntegrationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    active?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyCategoriaInput = {
    id?: string
    nome: string
    telefone: string
    email?: string | null
    tags?: ContactCreatetagsInput | string[]
    observacoes?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type ContactUpdateWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManySessionInput = {
    id?: string
    nome: string
    targetTags: string
    messageType: string
    messageContent: string
    randomDelay: number
    startImmediately: boolean
    scheduledFor?: Date | string | null
    status?: string
    totalContacts?: number
    sentCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    startTime?: string | null
    endTime?: string | null
    useTimeWindow?: boolean
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionNames?: string | null
    createdBy?: string | null
    createdByName?: string | null
  }

  export type CampaignUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    targetTags?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    randomDelay?: IntFieldUpdateOperationsInput | number
    startImmediately?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalContacts?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    useTimeWindow?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionNames?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    tenant?: TenantUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    targetTags?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    randomDelay?: IntFieldUpdateOperationsInput | number
    startImmediately?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalContacts?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    useTimeWindow?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionNames?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    targetTags?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    randomDelay?: IntFieldUpdateOperationsInput | number
    startImmediately?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalContacts?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    useTimeWindow?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionNames?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignMessageCreateManyCampaignInput = {
    id?: string
    contactId: string
    contactPhone: string
    contactName: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    errorMessage?: string | null
    messageId?: string | null
    selectedVariation?: string | null
    tenantId?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessionName?: string | null
  }

  export type CampaignMessageUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedVariation?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneWithoutCampaignMessagesNestedInput
  }

  export type CampaignMessageUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedVariation?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignMessageUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedVariation?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserTenantCreateManyUserInput = {
    id?: string
    tenantId: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertCreateManyUserInput = {
    id?: string
    type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    title: string
    message: string
    tenantId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    alertId: string
    method: $Enums.NotificationMethod
    sent?: boolean
    sentAt?: Date | string | null
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateCreateManyCreatorInput = {
    id?: string
    name: string
    tenantId: string
    category: string
    messageType: $Enums.MessageType
    content: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    mediaUrl?: string | null
    active?: boolean
    tags?: MessageTemplateCreatetagsInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationFlowCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    tenantId: string
    active?: boolean
    trigger: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateManyCreatorInput = {
    id?: string
    name: string
    type: $Enums.IntegrationType
    tenantId: string
    active?: boolean
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    lastSyncAt?: Date | string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    severity: string
    tenantId: string
    entityType?: string | null
    entityId?: string | null
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UserTenantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUserTenantsNestedInput
  }

  export type UserTenantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTenantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutAlertsNestedInput
    notifications?: NotificationUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumNotificationMethodFieldUpdateOperationsInput | $Enums.NotificationMethod
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alert?: AlertUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    method?: EnumNotificationMethodFieldUpdateOperationsInput | $Enums.NotificationMethod
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    method?: EnumNotificationMethodFieldUpdateOperationsInput | $Enums.NotificationMethod
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumUserNotificationTypeFieldUpdateOperationsInput | $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumUserNotificationTypeFieldUpdateOperationsInput | $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumUserNotificationTypeFieldUpdateOperationsInput | $Enums.UserNotificationType
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    tags?: MessageTemplateUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMessageTemplatesNestedInput
  }

  export type MessageTemplateUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    tags?: MessageTemplateUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    tags?: MessageTemplateUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationFlowUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    trigger?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAutomationFlowsNestedInput
    executions?: AutomationExecutionUpdateManyWithoutFlowNestedInput
  }

  export type AutomationFlowUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    trigger?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: AutomationExecutionUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type AutomationFlowUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    trigger?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    active?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutIntegrationsNestedInput
    syncLogs?: IntegrationSyncUpdateManyWithoutIntegrationNestedInput
  }

  export type IntegrationUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    tenantId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncLogs?: IntegrationSyncUncheckedUpdateManyWithoutIntegrationNestedInput
  }

  export type IntegrationUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    tenantId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyAlertInput = {
    id?: string
    userId: string
    method: $Enums.NotificationMethod
    sent?: boolean
    sentAt?: Date | string | null
    read?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumNotificationMethodFieldUpdateOperationsInput | $Enums.NotificationMethod
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    method?: EnumNotificationMethodFieldUpdateOperationsInput | $Enums.NotificationMethod
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    method?: EnumNotificationMethodFieldUpdateOperationsInput | $Enums.NotificationMethod
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationExecutionCreateManyFlowInput = {
    id?: string
    status: string
    executedAt: Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    duration?: number | null
  }

  export type AutomationExecutionUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationExecutionUncheckedUpdateWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationExecutionUncheckedUpdateManyWithoutFlowInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntegrationSyncCreateManyIntegrationInput = {
    id?: string
    type: string
    status: string
    recordsCount?: number | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt: Date | string
    completedAt?: Date | string | null
  }

  export type IntegrationSyncUpdateWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recordsCount?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntegrationSyncUncheckedUpdateWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recordsCount?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntegrationSyncUncheckedUpdateManyWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recordsCount?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhatsAppSessionCountOutputTypeDefaultArgs instead
     */
    export type WhatsAppSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhatsAppSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertCountOutputTypeDefaultArgs instead
     */
    export type AlertCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutomationFlowCountOutputTypeDefaultArgs instead
     */
    export type AutomationFlowCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutomationFlowCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegrationCountOutputTypeDefaultArgs instead
     */
    export type IntegrationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegrationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantQuotaDefaultArgs instead
     */
    export type TenantQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantQuotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantSettingsDefaultArgs instead
     */
    export type TenantSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserTenantDefaultArgs instead
     */
    export type UserTenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserTenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GlobalSettingsDefaultArgs instead
     */
    export type GlobalSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GlobalSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhatsAppSessionDefaultArgs instead
     */
    export type WhatsAppSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhatsAppSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignMessageDefaultArgs instead
     */
    export type CampaignMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertDefaultArgs instead
     */
    export type AlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserNotificationDefaultArgs instead
     */
    export type UserNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserNotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageTemplateDefaultArgs instead
     */
    export type MessageTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutomationFlowDefaultArgs instead
     */
    export type AutomationFlowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutomationFlowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutomationExecutionDefaultArgs instead
     */
    export type AutomationExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutomationExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegrationDefaultArgs instead
     */
    export type IntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegrationSyncDefaultArgs instead
     */
    export type IntegrationSyncArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegrationSyncDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}